
=== File: package.json ===

{
  "name": "my-app",
  "main": "expo-router/entry",
  "version": "1.0.0",
  "scripts": {
    "start": "expo start",
    "build": "expo export --platform web",
    "reset-project": "node ./scripts/reset-project.js",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web",
    "test": "jest --watchAll",
    "lint": "expo lint"
  },
  "jest": {
    "preset": "jest-expo"
  },
  "dependencies": {
    "@expo/metro-runtime": "~6.1.2",
    "@expo/ngrok": "^4.1.3",
    "@expo/vector-icons": "^15.0.2",
    "@react-native-async-storage/async-storage": "^2.2.0",
    "@react-native-community/slider": "5.0.1",
    "@react-navigation/bottom-tabs": "^7.3.10",
    "@react-navigation/elements": "^2.3.8",
    "@react-navigation/native": "^7.1.6",
    "expo": "~54.0.30",
    "expo-apple-authentication": "^8.0.8",
    "expo-auth-session": "~7.0.10",
    "expo-blur": "~15.0.8",
    "expo-clipboard": "^8.0.8",
    "expo-constants": "~18.0.9",
    "expo-crypto": "~15.0.8",
    "expo-dev-client": "~6.0.20",
    "expo-font": "~14.0.8",
    "expo-haptics": "~15.0.8",
    "expo-image": "~3.0.11",
    "expo-linking": "~8.0.11",
    "expo-location": "~19.0.8",
    "expo-router": "~6.0.21",
    "expo-secure-store": "^15.0.8",
    "expo-splash-screen": "~31.0.13",
    "expo-status-bar": "~3.0.9",
    "expo-symbols": "~1.0.8",
    "expo-system-ui": "~6.0.9",
    "expo-web-browser": "~15.0.10",
    "http-proxy-middleware": "^3.0.5",
    "nativewind": "^4.2.1",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-native": "0.81.5",
    "react-native-gesture-handler": "~2.28.0",
    "react-native-maps": "1.20.1",
    "react-native-reanimated": "~4.1.1",
    "react-native-safe-area-context": "~5.6.0",
    "react-native-screens": "~4.16.0",
    "react-native-web": "^0.21.0",
    "react-native-webview": "13.15.0",
    "react-native-worklets": "0.5.1",
    "serve": "^14.2.5",
    "socket.io-client": "^4.8.1",
    "tailwindcss": "^3.4.19"
  },
  "devDependencies": {
    "@babel/core": "^7.25.2",
    "@types/react": "~19.1.10",
    "eslint": "^9.25.0",
    "eslint-config-expo": "~10.0.0",
    "jest": "^29.2.1",
    "jest-expo": "~54.0.12",
    "typescript": "~5.9.2"
  },
  "private": true
}

=== File: app.json ===

{
  "expo": {
    "name": "Mibu",
    "slug": "mibu-travel",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/images/icon.png",
    "scheme": "mibu",
    "userInterfaceStyle": "automatic",
    "newArchEnabled": true,
    "ios": {
      "supportsTablet": true
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/images/adaptive-icon.png",
        "backgroundColor": "#F5E6D3"
      },
      "edgeToEdgeEnabled": true
    },
    "web": {
      "bundler": "metro",
      "output": "static",
      "favicon": "./assets/images/favicon.png"
    },
    "plugins": [
      "expo-router",
      [
        "expo-splash-screen",
        {
          "image": "./assets/images/splash-icon.png",
          "imageWidth": 200,
          "resizeMode": "contain",
          "backgroundColor": "#F5E6D3"
        }
      ]
    ],
    "experiments": {
      "typedRoutes": true
    }
  }
}

=== File: app/admin-announcements.tsx ===

import { AdminAnnouncementsScreen } from '@/src/screens/AdminAnnouncementsScreen';

export default function AdminAnnouncementsPage() {
  return <AdminAnnouncementsScreen />;
}

=== File: app/admin-dashboard.tsx ===

import { AdminDashboardScreen } from '../src/screens/AdminDashboardScreen';

export default function AdminDashboard() {
  return <AdminDashboardScreen />;
}

=== File: app/admin-exclusions.tsx ===

import { AdminExclusionsScreen } from '../src/screens/AdminExclusionsScreen';

export default AdminExclusionsScreen;

=== File: app/announcement-manage.tsx ===

import { AnnouncementManageScreen } from '../src/screens/AnnouncementManageScreen';

export default function AnnouncementManagePage() {
  return <AnnouncementManageScreen />;
}

=== File: app/auth/callback.tsx ===

import React, { useEffect } from 'react';
import { View, Text, ActivityIndicator, StyleSheet, Platform } from 'react-native';
import { router, useLocalSearchParams } from 'expo-router';
import { useApp } from '../../src/context/AppContext';
import { API_BASE_URL } from '../../src/constants/translations';

export default function AuthCallback() {
  const { setUser } = useApp();
  const params = useLocalSearchParams();

  useEffect(() => {
    handleCallback();
  }, []);

  const navigateAfterLogin = (role: string, isApproved?: boolean) => {
    if (role === 'merchant') {
      if (isApproved === false) {
        router.replace('/pending-approval');
      } else {
        router.replace('/merchant-dashboard');
      }
    } else if (role === 'specialist') {
      if (isApproved === false) {
        router.replace('/pending-approval');
      } else {
        router.replace('/specialist-dashboard');
      }
    } else {
      router.replace('/(tabs)');
    }
  };

  const handleCallback = async () => {
    const token = params.token as string;
    const portal = params.portal as string;

    if (token) {
      try {
        const response = await fetch(`${API_BASE_URL}/api/auth/user`, {
          headers: {
            'Authorization': `Bearer ${token}`,
          },
        });

        if (response.ok) {
          const userData = await response.json();
          if (userData && (userData.name || userData.id)) {
            const userRole = userData.role || portal || 'traveler';
            
            setUser({
              id: userData.id,
              name: userData.name || userData.email?.split('@')[0] || 'User',
              email: userData.email || null,
              avatar: userData.avatar || userData.profileImageUrl || null,
              firstName: userData.firstName || userData.name?.split(' ')[0] || null,
              role: userRole,
              isApproved: userData.isApproved,
              isSuperAdmin: userData.isSuperAdmin || false,
              accessibleRoles: userData.accessibleRoles || [],
              provider: userData.provider || 'google',
              providerId: userData.id,
            }, token);
            
            navigateAfterLogin(userRole, userData.isApproved);
            return;
          }
        }
      } catch (error) {
        console.error('Auth callback error:', error);
      }
    }

    if (Platform.OS === 'web') {
      if (window.opener) {
        window.close();
      }
    }

    router.replace('/login');
  };

  return (
    <View style={styles.container}>
      <ActivityIndicator size="large" color="#6366f1" />
      <Text style={styles.text}>æ­£åœ¨ç™»å…¥...</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  text: {
    marginTop: 16,
    fontSize: 16,
    color: '#64748b',
  },
});

=== File: app/index.tsx ===

import { Redirect } from 'expo-router';
import { useApp } from '../src/context/AppContext';

export default function Index() {
  const { state } = useApp();
  
  if (!state.isAuthenticated || !state.user) {
    return <Redirect href="/login" />;
  }

  const { role, activeRole, isApproved, isSuperAdmin } = state.user;
  
  // For super admin, use activeRole to determine interface
  const effectiveRole = isSuperAdmin ? (activeRole || role) : role;

  if (effectiveRole === 'merchant') {
    // Super admins skip approval check
    if (!isSuperAdmin && isApproved === false) {
      return <Redirect href="/pending-approval" />;
    }
    return <Redirect href="/merchant-dashboard" />;
  }

  if (effectiveRole === 'specialist') {
    // Super admins skip approval check
    if (!isSuperAdmin && isApproved === false) {
      return <Redirect href="/pending-approval" />;
    }
    return <Redirect href="/specialist-dashboard" />;
  }

  if (effectiveRole === 'admin') {
    return <Redirect href="/admin-dashboard" />;
  }

  return <Redirect href="/(tabs)" />;
}

=== File: app/_layout.tsx ===

import "../global.css";
import { DarkTheme, DefaultTheme, ThemeProvider } from '@react-navigation/native';
import { useFonts } from 'expo-font';
import { Stack } from 'expo-router';
import { StatusBar } from 'expo-status-bar';
import 'react-native-reanimated';

import { useColorScheme } from '@/hooks/useColorScheme';
import { AppProvider } from '../src/context/AppContext';

export default function RootLayout() {
  const colorScheme = useColorScheme();
  const [loaded] = useFonts({
    SpaceMono: require('../assets/fonts/SpaceMono-Regular.ttf'),
  });

  if (!loaded) {
    return null;
  }

  return (
    <AppProvider>
      <ThemeProvider value={colorScheme === 'dark' ? DarkTheme : DefaultTheme}>
        <Stack>
          <Stack.Screen name="login" options={{ headerShown: false }} />
          <Stack.Screen name="(tabs)" options={{ headerShown: false }} />
          <Stack.Screen name="merchant-dashboard" options={{ headerShown: false }} />
          <Stack.Screen name="specialist-dashboard" options={{ headerShown: false }} />
          <Stack.Screen name="pending-approval" options={{ headerShown: false }} />
          <Stack.Screen name="admin-exclusions" options={{ headerShown: false }} />
          <Stack.Screen name="sos" options={{ headerShown: false }} />
          <Stack.Screen name="+not-found" />
        </Stack>
        <StatusBar style="auto" />
      </ThemeProvider>
    </AppProvider>
  );
}

=== File: app/login.tsx ===

import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Platform,
  Modal,
  Image,
  Alert,
  TextInput,
} from 'react-native';
import { router } from 'expo-router';
import * as WebBrowser from 'expo-web-browser';
import * as Linking from 'expo-linking';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Ionicons } from '@expo/vector-icons';
import * as AppleAuthentication from 'expo-apple-authentication';
import { useApp } from '../src/context/AppContext';
import { API_BASE_URL } from '../src/constants/translations';
import { UserRole } from '../src/types';
import { MibuBrand } from '../constants/Colors';

const AUTH_TOKEN_KEY = '@mibu_token';

// OAuth ç™»å…¥å°ˆç”¨é–‹ç™¼ç’°å¢ƒ URLï¼ˆå¾Œç«¯è¦æ±‚ï¼‰
const OAUTH_BASE_URL = 'https://591965a7-25f6-479c-b527-3890b1193c21-00-1m08cwv9a4rev.picard.replit.dev';

type PortalType = 'traveler' | 'merchant' | 'specialist' | 'admin';

interface PortalConfig {
  type: PortalType;
  label: string;
  color: string;
  bgColor: string;
  subtitle: string;
  guestAllowed: boolean;
}

const PORTAL_CONFIGS: Record<string, PortalConfig[]> = {
  'zh-TW': [
    { type: 'traveler', label: 'æ—…å®¢', color: MibuBrand.brown, bgColor: MibuBrand.highlight, subtitle: 'æ¢ç´¢å°ç£å„åœ°ç²¾å½©æ™¯é»', guestAllowed: true },
    { type: 'admin', label: 'ç®¡ç†ç«¯', color: MibuBrand.warning, bgColor: MibuBrand.highlight, subtitle: 'ç³»çµ±ç®¡ç†å“¡å°ˆç”¨å…¥å£', guestAllowed: false },
  ],
  'en': [
    { type: 'traveler', label: 'Traveler', color: MibuBrand.brown, bgColor: MibuBrand.highlight, subtitle: 'Explore amazing destinations', guestAllowed: true },
    { type: 'admin', label: 'Admin', color: MibuBrand.warning, bgColor: MibuBrand.highlight, subtitle: 'System administrator portal', guestAllowed: false },
  ],
  'ja': [
    { type: 'traveler', label: 'æ—…è¡Œè€…', color: MibuBrand.brown, bgColor: MibuBrand.highlight, subtitle: 'ç´ æ™´ã‚‰ã—ã„ç›®çš„åœ°ã‚’æ¢ç´¢', guestAllowed: true },
    { type: 'admin', label: 'ç®¡ç†è€…', color: MibuBrand.warning, bgColor: MibuBrand.highlight, subtitle: 'ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†è€…ãƒãƒ¼ã‚¿ãƒ«', guestAllowed: false },
  ],
  'ko': [
    { type: 'traveler', label: 'ì—¬í–‰ì', color: MibuBrand.brown, bgColor: MibuBrand.highlight, subtitle: 'ë†€ë¼ìš´ ì—¬í–‰ì§€ íƒí—˜', guestAllowed: true },
    { type: 'admin', label: 'ê´€ë¦¬ì', color: MibuBrand.warning, bgColor: MibuBrand.highlight, subtitle: 'ì‹œìŠ¤í…œ ê´€ë¦¬ì í¬í„¸', guestAllowed: false },
  ],
};

const LANGUAGE_OPTIONS: { code: 'zh-TW' | 'en' | 'ja' | 'ko'; label: string; flag: string }[] = [
  { code: 'zh-TW', label: 'ç¹é«”ä¸­æ–‡', flag: 'ğŸ‡¹ğŸ‡¼' },
  { code: 'en', label: 'English', flag: 'ğŸ‡ºğŸ‡¸' },
  { code: 'ja', label: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' },
  { code: 'ko', label: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·' },
];

export default function LoginScreen() {
  const { setUser, state, setLanguage } = useApp();
  const [loading, setLoading] = useState(false);
  const [checkingAuth, setCheckingAuth] = useState(false);
  const [selectedPortal, setSelectedPortal] = useState<PortalType>('traveler');
  const [showPortalMenu, setShowPortalMenu] = useState(false);
  const [showLanguageMenu, setShowLanguageMenu] = useState(false);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const redirectUri = Linking.createURL('auth/callback');
  const portals = PORTAL_CONFIGS[state.language] || PORTAL_CONFIGS['zh-TW'];
  const currentPortal = portals.find(p => p.type === selectedPortal) || portals[0];

  const handleDeepLink = useCallback(async (event: { url: string }) => {
    const parsed = Linking.parse(event.url);
    
    if (parsed.path === 'auth/callback' || event.url.includes('auth/callback') || event.url.includes('token=') || event.url.includes('error=')) {
      // Handle error codes from callback
      if (parsed.queryParams?.error) {
        await WebBrowser.dismissBrowser();
        setLoading(false);
        const errorCode = parsed.queryParams?.error as string;
        const errorMessage = parsed.queryParams?.message as string;
        const isZh = state.language === 'zh-TW';
        
        switch (errorCode) {
          case 'NO_MERCHANT_DATA':
            Alert.alert(
              isZh ? 'å°šæœªè¨»å†Šå•†å®¶' : 'Not a Merchant',
              isZh ? 'æ‚¨å°šæœªè¨»å†Šç‚ºå•†å®¶ï¼Œè«‹å…ˆç”³è«‹å•†å®¶å¸³è™Ÿ' : (errorMessage || 'Please register as a merchant first'),
              [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
            );
            break;
          case 'NO_SPECIALIST_DATA':
            Alert.alert(
              isZh ? 'å°šæœªè¨»å†Šå°ˆå“¡' : 'Not a Specialist',
              isZh ? 'æ‚¨å°šæœªè¨»å†Šç‚ºå°ˆå“¡ï¼Œè«‹å…ˆç”³è«‹å°ˆå“¡å¸³è™Ÿ' : (errorMessage || 'Please register as a specialist first'),
              [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
            );
            break;
          case 'WRONG_PORTAL':
            Alert.alert(
              isZh ? 'å…¥å£éŒ¯èª¤' : 'Wrong Portal',
              isZh ? 'è«‹åˆ‡æ›è‡³æ­£ç¢ºçš„å…¥å£ç™»å…¥' : (errorMessage || 'Please switch to the correct portal'),
              [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
            );
            break;
          case 'PERMISSION_DENIED':
            Alert.alert(
              isZh ? 'æ¬Šé™ä¸è¶³' : 'Permission Denied',
              isZh ? 'æ‚¨æ²’æœ‰æ¬Šé™å­˜å–æ­¤åŠŸèƒ½' : (errorMessage || 'You do not have permission to access this feature'),
              [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
            );
            break;
          default:
            Alert.alert(
              isZh ? 'ç™»å…¥å¤±æ•—' : 'Login Failed',
              errorMessage || (isZh ? 'è«‹ç¨å¾Œå†è©¦' : 'Please try again'),
              [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
            );
        }
        return;
      }
      
      if (parsed.queryParams?.token) {
        await WebBrowser.dismissBrowser();
        await fetchUserWithTokenDirect(parsed.queryParams.token as string);
      }
    }
  }, [state.language]);

  const fetchUserWithTokenDirect = async (token: string) => {
    try {
      await AsyncStorage.setItem(AUTH_TOKEN_KEY, token);
      
      // *** é—œéµä¿®æ”¹ï¼šå¾ AsyncStorage è®€å‡ºä¹‹å‰å„²å­˜çš„å…¥å£é¸æ“‡ ***
      const targetPortal = await AsyncStorage.getItem('post_login_portal');
      // *** ç”¨å®Œå¾Œç«‹å³åˆªé™¤ï¼Œé¿å…å½±éŸ¿ä¸‹æ¬¡ç™»å…¥ ***
      await AsyncStorage.removeItem('post_login_portal');
      
      console.log('ğŸ” fetchUserWithTokenDirect - targetPortal from storage:', targetPortal);
      
      const response = await fetch(`${API_BASE_URL}/api/auth/user`, {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });
      
      if (response.ok) {
        const userData = await response.json();
        if (userData && userData.name) {
          // ä½¿ç”¨å¾ AsyncStorage è®€å‡ºçš„ targetPortal
          const portalToUse = targetPortal || selectedPortal;
          let finalActiveRole = userData.activeRole || userData.role || portalToUse;
          
          if (userData.isSuperAdmin && portalToUse !== finalActiveRole) {
            try {
              const switchResponse = await fetch(`${API_BASE_URL}/api/auth/switch-role`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ role: portalToUse }),
              });
              
              if (switchResponse.ok) {
                const switchData = await switchResponse.json();
                finalActiveRole = switchData.activeRole || portalToUse;
              }
            } catch (switchError) {
              console.error('Failed to switch role:', switchError);
              finalActiveRole = portalToUse;
            }
          }
          
          // Use API role for navigation, activeRole for super admins
          const userRole = userData.role || 'traveler';
          const navigationRole = userData.isSuperAdmin ? finalActiveRole : userRole;
          
          console.log('ğŸ” User data from API:', { 
            role: userData.role, 
            activeRole: userData.activeRole, 
            isSuperAdmin: userData.isSuperAdmin,
            isApproved: userData.isApproved,
            navigationRole,
            targetPortal: portalToUse
          });
          
          setUser({
            id: userData.id,
            name: userData.name,
            email: userData.email || null,
            avatar: userData.avatar || null,
            firstName: userData.firstName || userData.name.split(' ')[0],
            role: userRole,
            activeRole: finalActiveRole,
            isApproved: userData.isApproved,
            isSuperAdmin: userData.isSuperAdmin || false,
            accessibleRoles: userData.accessibleRoles || [],
            provider: 'google',
            providerId: userData.id,
          }, token);
          setLoading(false);
          // *** é—œéµä¿®æ”¹ï¼šå‚³å…¥ targetPortal çµ¦ navigateAfterLogin ***
          navigateAfterLogin(navigationRole, userData.isApproved, userData.isSuperAdmin, portalToUse);
        }
      } else {
        console.error('Failed to fetch user data:', response.status);
        setLoading(false);
      }
    } catch (error) {
      console.error('Failed to fetch user with token:', error);
      setLoading(false);
    }
  };

  const navigateAfterLogin = (role: string, isApproved?: boolean, isSuperAdmin?: boolean, targetPortal?: string) => {
    console.log('ğŸ”€ navigateAfterLogin called with:', { role, isApproved, isSuperAdmin, targetPortal });
    
    // *** é—œéµä¿®æ”¹ï¼šå§‹çµ‚å„ªå…ˆä½¿ç”¨ targetPortalï¼ˆç”¨æˆ¶é¸æ“‡çš„å…¥å£ï¼‰ï¼Œè€Œéå¾Œç«¯è¿”å›çš„ role ***
    const portalToUse = targetPortal || role;
    console.log('ğŸ”€ Using portal:', portalToUse);
    
    if (portalToUse === 'merchant') {
      if (isApproved === false) {
        console.log('ğŸ”€ Merchant not approved, going to pending');
        router.replace('/pending-approval');
      } else {
        console.log('ğŸ”€ Navigating to merchant-dashboard');
        router.replace('/merchant-dashboard');
      }
    } else if (portalToUse === 'specialist') {
      if (isApproved === false) {
        console.log('ğŸ”€ Specialist not approved, going to pending');
        router.replace('/pending-approval');
      } else {
        console.log('ğŸ”€ Navigating to specialist-dashboard');
        router.replace('/specialist-dashboard');
      }
    } else if (portalToUse === 'admin') {
      console.log('ğŸ”€ Navigating to admin-dashboard');
      router.replace('/admin-dashboard');
    } else {
      console.log('ğŸ”€ Navigating to tabs (traveler)');
      router.replace('/(tabs)');
    }
  };

  useEffect(() => {
    const subscription = Linking.addEventListener('url', handleDeepLink);
    
    Linking.getInitialURL().then((url) => {
      if (url) {
        handleDeepLink({ url });
      }
    });
    
    return () => {
      subscription.remove();
    };
  }, [handleDeepLink]);

  const handleLogin = async () => {
    setLoading(true);
    try {
      // *** é—œéµä¿®æ”¹ï¼šåœ¨ç™¼èµ·ç™»å…¥å‰ï¼Œå„²å­˜ä½¿ç”¨è€…é¸æ“‡çš„å…¥å£ ***
      await AsyncStorage.setItem('post_login_portal', selectedPortal);
      
      // Use /api/login with portal parameter - OAuth ä½¿ç”¨é–‹ç™¼ç’°å¢ƒ URL
      const authUrl = `${OAUTH_BASE_URL}/api/login?portal=${selectedPortal}&redirect_uri=${encodeURIComponent(redirectUri)}`;
      
      if (Platform.OS === 'web') {
        const width = 500;
        const height = 600;
        const left = (window.screenX || 0) + ((window.outerWidth || 800) - width) / 2;
        const top = (window.screenY || 0) + ((window.outerHeight || 600) - height) / 2;
        
        const authWindow = window.open(
          authUrl,
          'auth',
          `width=${width},height=${height},left=${left},top=${top}`
        );

        const checkInterval = setInterval(async () => {
          try {
            if (authWindow?.closed) {
              clearInterval(checkInterval);
              await fetchUserAfterAuth();
              setLoading(false);
            }
          } catch (e) {
          }
        }, 500);

        setTimeout(() => {
          clearInterval(checkInterval);
          setLoading(false);
        }, 120000);
      } else {
        const handleAuthCallback = async (event: { url: string }) => {
          const parsed = Linking.parse(event.url);
          
          if (event.url.includes('auth/callback') || event.url.includes('token=') || event.url.includes('error=')) {
            subscription.remove();
            
            await WebBrowser.dismissBrowser();
            
            // Handle error codes from callback
            if (parsed.queryParams?.error) {
              setLoading(false);
              const errorCode = parsed.queryParams?.error as string;
              const errorMessage = parsed.queryParams?.message as string;
              const isZh = state.language === 'zh-TW';
              
              switch (errorCode) {
                case 'NO_MERCHANT_DATA':
                  Alert.alert(
                    isZh ? 'å°šæœªè¨»å†Šå•†å®¶' : 'Not a Merchant',
                    isZh ? 'æ‚¨å°šæœªè¨»å†Šç‚ºå•†å®¶ï¼Œè«‹å…ˆç”³è«‹å•†å®¶å¸³è™Ÿ' : (errorMessage || 'Please register as a merchant first'),
                    [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
                  );
                  break;
                case 'NO_SPECIALIST_DATA':
                  Alert.alert(
                    isZh ? 'å°šæœªè¨»å†Šå°ˆå“¡' : 'Not a Specialist',
                    isZh ? 'æ‚¨å°šæœªè¨»å†Šç‚ºå°ˆå“¡ï¼Œè«‹å…ˆç”³è«‹å°ˆå“¡å¸³è™Ÿ' : (errorMessage || 'Please register as a specialist first'),
                    [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
                  );
                  break;
                case 'WRONG_PORTAL':
                  Alert.alert(
                    isZh ? 'å…¥å£éŒ¯èª¤' : 'Wrong Portal',
                    isZh ? 'è«‹åˆ‡æ›è‡³æ­£ç¢ºçš„å…¥å£ç™»å…¥' : (errorMessage || 'Please switch to the correct portal'),
                    [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
                  );
                  break;
                case 'PERMISSION_DENIED':
                  Alert.alert(
                    isZh ? 'æ¬Šé™ä¸è¶³' : 'Permission Denied',
                    isZh ? 'æ‚¨æ²’æœ‰æ¬Šé™å­˜å–æ­¤åŠŸèƒ½' : (errorMessage || 'You do not have permission to access this feature'),
                    [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
                  );
                  break;
                default:
                  Alert.alert(
                    isZh ? 'ç™»å…¥å¤±æ•—' : 'Login Failed',
                    errorMessage || (isZh ? 'è«‹ç¨å¾Œå†è©¦' : 'Please try again'),
                    [{ text: isZh ? 'ç¢ºå®š' : 'OK' }]
                  );
              }
              return;
            }
            
            if (parsed.queryParams?.token) {
              await fetchUserWithToken(parsed.queryParams.token as string);
            } else {
              console.error('Auth callback received but no token found');
              setLoading(false);
            }
          }
        };
        
        const subscription = Linking.addEventListener('url', handleAuthCallback);
        
        await WebBrowser.openBrowserAsync(authUrl, {
          showInRecents: true,
          dismissButtonStyle: 'close',
        });
        
        setTimeout(() => {
          subscription.remove();
          setLoading(false);
        }, 120000);
      }
    } catch (error) {
      console.error('Auth error:', error);
      // æ¸…ç†å¯èƒ½æ®˜ç•™çš„å­˜å„²
      await AsyncStorage.removeItem('post_login_portal');
      setLoading(false);
    }
  };

  const fetchUserWithToken = async (token: string) => {
    try {
      await AsyncStorage.setItem(AUTH_TOKEN_KEY, token);
      
      // *** é—œéµä¿®æ”¹ï¼šå¾ AsyncStorage è®€å‡ºä¹‹å‰å„²å­˜çš„å…¥å£é¸æ“‡ ***
      const targetPortal = await AsyncStorage.getItem('post_login_portal');
      // *** ç”¨å®Œå¾Œç«‹å³åˆªé™¤ï¼Œé¿å…å½±éŸ¿ä¸‹æ¬¡ç™»å…¥ ***
      await AsyncStorage.removeItem('post_login_portal');
      
      console.log('ğŸ” fetchUserWithToken - targetPortal from storage:', targetPortal);
      
      const response = await fetch(`${API_BASE_URL}/api/auth/user`, {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });
      
      if (response.ok) {
        const userData = await response.json();
        if (userData && userData.id) {
          const displayName = userData.firstName || userData.name || userData.email?.split('@')[0] || 'User';
          
          // ä½¿ç”¨å¾ AsyncStorage è®€å‡ºçš„ targetPortal
          const portalToUse = targetPortal || selectedPortal;
          let finalActiveRole = userData.activeRole || userData.role || portalToUse;
          
          if (userData.isSuperAdmin && portalToUse !== finalActiveRole) {
            try {
              const switchResponse = await fetch(`${API_BASE_URL}/api/auth/switch-role`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ role: portalToUse }),
              });
              
              if (switchResponse.ok) {
                const switchData = await switchResponse.json();
                finalActiveRole = switchData.activeRole || portalToUse;
              }
            } catch (switchError) {
              console.error('Failed to switch role:', switchError);
              finalActiveRole = portalToUse;
            }
          }
          
          // Use API role for navigation, activeRole for super admins
          const userRole = userData.role || 'traveler';
          const navigationRole = userData.isSuperAdmin ? finalActiveRole : userRole;
          
          console.log('ğŸ” fetchUserWithToken - User data:', { 
            role: userData.role, 
            activeRole: userData.activeRole, 
            isSuperAdmin: userData.isSuperAdmin,
            isApproved: userData.isApproved,
            navigationRole,
            targetPortal: portalToUse
          });
          
          setUser({
            id: userData.id,
            name: displayName,
            email: userData.email || null,
            firstName: userData.firstName || null,
            lastName: userData.lastName || null,
            avatar: userData.profileImageUrl || userData.avatar || null,
            profileImageUrl: userData.profileImageUrl || null,
            role: userRole,
            activeRole: finalActiveRole,
            isApproved: userData.isApproved,
            isSuperAdmin: userData.isSuperAdmin || false,
            accessibleRoles: userData.accessibleRoles || [],
            provider: userData.provider || 'google',
            providerId: userData.id,
          }, token);
          setLoading(false);
          // *** é—œéµä¿®æ”¹ï¼šå‚³å…¥ targetPortal çµ¦ navigateAfterLogin ***
          navigateAfterLogin(navigationRole, userData.isApproved, userData.isSuperAdmin, portalToUse);
        } else {
          console.error('Invalid user data: missing id');
          setLoading(false);
        }
      } else {
        console.error('Failed to fetch user:', response.status);
        setLoading(false);
      }
    } catch (error) {
      console.error('Failed to fetch user with token:', error);
      setLoading(false);
    }
  };

  const fetchUserAfterAuth = async () => {
    try {
      // *** é—œéµä¿®æ”¹ï¼šå¾ AsyncStorage è®€å‡ºä¹‹å‰å„²å­˜çš„å…¥å£é¸æ“‡ ***
      const targetPortal = await AsyncStorage.getItem('post_login_portal');
      // *** ç”¨å®Œå¾Œç«‹å³åˆªé™¤ï¼Œé¿å…å½±éŸ¿ä¸‹æ¬¡ç™»å…¥ ***
      await AsyncStorage.removeItem('post_login_portal');
      
      console.log('ğŸ” fetchUserAfterAuth - targetPortal from storage:', targetPortal);
      
      const response = await fetch(`${API_BASE_URL}/api/auth/user`, {
        credentials: 'include',
      });
      
      if (response.ok) {
        const userData = await response.json();
        if (userData && userData.name) {
          // ä½¿ç”¨å¾ AsyncStorage è®€å‡ºçš„ targetPortal
          const portalToUse = targetPortal || selectedPortal;
          let finalActiveRole = userData.activeRole || userData.role || portalToUse;
          const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
          
          if (userData.isSuperAdmin && portalToUse !== finalActiveRole && token) {
            try {
              const switchResponse = await fetch(`${API_BASE_URL}/api/auth/switch-role`, {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${token}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ role: portalToUse }),
              });
              
              if (switchResponse.ok) {
                const switchData = await switchResponse.json();
                finalActiveRole = switchData.activeRole || portalToUse;
              }
            } catch (switchError) {
              console.error('Failed to switch role:', switchError);
              finalActiveRole = portalToUse;
            }
          }
          
          // Use API role for navigation, activeRole for super admins
          const userRole = userData.role || 'traveler';
          const navigationRole = userData.isSuperAdmin ? finalActiveRole : userRole;
          
          console.log('ğŸ” fetchUserAfterAuth - User data:', { 
            role: userData.role, 
            activeRole: userData.activeRole, 
            isSuperAdmin: userData.isSuperAdmin,
            isApproved: userData.isApproved,
            navigationRole,
            targetPortal: portalToUse
          });
          
          setUser({
            id: userData.id,
            name: userData.name,
            email: userData.email || null,
            avatar: userData.avatar || null,
            firstName: userData.firstName || userData.name.split(' ')[0],
            role: userRole,
            activeRole: finalActiveRole,
            isApproved: userData.isApproved,
            isSuperAdmin: userData.isSuperAdmin || false,
            accessibleRoles: userData.accessibleRoles || [],
            provider: 'google',
            providerId: userData.id,
          });
          // *** é—œéµä¿®æ”¹ï¼šå‚³å…¥ targetPortal çµ¦ navigateAfterLogin ***
          navigateAfterLogin(navigationRole, userData.isApproved, userData.isSuperAdmin, portalToUse);
        }
      }
    } catch (error) {
      console.error('Failed to fetch user after auth:', error);
    }
  };

  const handleGuestLogin = () => {
    setUser({
      id: 'guest',
      name: 'Guest User',
      email: null,
      avatar: null,
      firstName: 'Guest',
      role: 'traveler',
      provider: 'guest',
      providerId: 'guest',
    });
    router.replace('/(tabs)');
  };

  const handleEmailLogin = async () => {
    if (!email.trim() || !password) {
      Alert.alert(
        state.language === 'zh-TW' ? 'éŒ¯èª¤' : 'Error',
        state.language === 'zh-TW' ? 'è«‹è¼¸å…¥ Email å’Œå¯†ç¢¼' : 'Please enter email and password'
      );
      return;
    }

    try {
      setLoading(true);
      const response = await fetch(`${API_BASE_URL}/api/auth/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: email.trim(),
          password,
          portal: selectedPortal,
        }),
      });

      const data = await response.json();

      if (data.success && data.token) {
        await AsyncStorage.setItem(AUTH_TOKEN_KEY, data.token);
        await AsyncStorage.setItem('@mibu_user', JSON.stringify(data.user));
        await AsyncStorage.setItem('@mibu_target_portal', selectedPortal);

        setUser({
          id: data.user.id,
          email: data.user.email,
          name: data.user.name,
          role: data.user.role as UserRole,
          isApproved: data.user.isApproved,
          isSuperAdmin: data.user.isSuperAdmin,
          provider: 'email',
          providerId: data.user.id,
        });

        navigateAfterLogin(data.user.role as UserRole, data.user.isApproved, data.user.isSuperAdmin, selectedPortal);
      } else {
        Alert.alert(
          state.language === 'zh-TW' ? 'ç™»å…¥å¤±æ•—' : 'Login Failed',
          data.message || (state.language === 'zh-TW' ? 'å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤' : 'Invalid email or password')
        );
      }
    } catch (error) {
      console.error('Email login error:', error);
      Alert.alert(
        state.language === 'zh-TW' ? 'éŒ¯èª¤' : 'Error',
        state.language === 'zh-TW' ? 'ç™»å…¥å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Login failed. Please try again.'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleAppleLogin = async () => {
    try {
      setLoading(true);
      console.log('[Apple Auth] Starting Apple Sign In...');
      
      const credential = await AppleAuthentication.signInAsync({
        requestedScopes: [
          AppleAuthentication.AppleAuthenticationScope.FULL_NAME,
          AppleAuthentication.AppleAuthenticationScope.EMAIL,
        ],
      });

      console.log('[Apple Auth] Credential received:', {
        hasIdentityToken: !!credential.identityToken,
        identityTokenPreview: credential.identityToken?.substring(0, 50) + '...',
        user: credential.user,
        email: credential.email,
        fullName: credential.fullName,
      });

      if (credential.identityToken) {
        const apiUrl = `${API_BASE_URL}/api/auth/apple`;
        const requestBody = {
          identityToken: credential.identityToken,
          user: credential.user,
          portal: selectedPortal,
          email: credential.email,
          fullName: credential.fullName ? {
            givenName: credential.fullName.givenName,
            familyName: credential.fullName.familyName,
          } : undefined,
        };
        
        const bodyString = JSON.stringify(requestBody);
        console.log('[Apple Auth] Sending request to:', apiUrl);
        console.log('[Apple Auth] Request body keys:', Object.keys(requestBody));
        console.log('[Apple Auth] Full JSON body:', bodyString.substring(0, 200) + '...');
        console.log('[Apple Auth] Body starts with identityToken?:', bodyString.startsWith('{"identityToken":'));
        
        if (!requestBody.identityToken) {
          console.error('[Apple Auth] No identityToken!');
          return;
        }
        
        console.log('[Apple Auth] About to send request...');
        let response;
        try {
          response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: bodyString,
          });
          console.log('[Apple Auth] Request completed, status:', response.status);
        } catch (fetchError: any) {
          console.error('[Apple Auth] FETCH ERROR:', fetchError);
          console.error('[Apple Auth] FETCH ERROR message:', fetchError.message);
          Alert.alert(
            state.language === 'zh-TW' ? 'ç¶²è·¯éŒ¯èª¤' : 'Network Error',
            state.language === 'zh-TW' ? 'ç„¡æ³•é€£æ¥åˆ°ä¼ºæœå™¨' : 'Could not connect to server'
          );
          return;
        }

        console.log('[Apple Auth] Response status:', response.status);
        const responseText = await response.text();
        console.log('[Apple Auth] Response raw:', responseText);
        
        let data;
        try {
          data = JSON.parse(responseText);
        } catch (e) {
          console.error('[Apple Auth] Failed to parse response as JSON');
          data = { error: responseText };
        }
        
        console.log('[Apple Auth] Response data:', {
          success: data.success,
          hasToken: !!data.token,
          hasUser: !!data.user,
          error: data.error,
          message: data.message,
        });

        if (data.token && data.user) {
          const userRole = data.user.role as UserRole || 'traveler';
          const finalActiveRole = data.user.activeRole as UserRole || userRole;
          
          await setUser({
            id: data.user.id,
            name: data.user.name || credential.fullName?.givenName || 'User',
            email: data.user.email || credential.email || null,
            avatar: data.user.avatar || null,
            firstName: data.user.firstName || credential.fullName?.givenName || 'User',
            role: userRole,
            activeRole: finalActiveRole,
            isApproved: data.user.isApproved,
            isSuperAdmin: data.user.isSuperAdmin || false,
            accessibleRoles: data.user.accessibleRoles || [],
            provider: 'apple',
            providerId: credential.user,
          }, data.token);
          
          navigateAfterLogin(userRole, data.user.isApproved, data.user.isSuperAdmin, selectedPortal);
        } else {
          Alert.alert(
            state.language === 'zh-TW' ? 'ç™»å…¥å¤±æ•—' : 'Login Failed',
            data.error || (state.language === 'zh-TW' ? 'è«‹ç¨å¾Œå†è©¦' : 'Please try again later')
          );
        }
      }
    } catch (error: any) {
      if (error.code === 'ERR_REQUEST_CANCELED') {
        console.log('[Apple Auth] User canceled Apple Sign In');
      } else {
        console.error('[Apple Auth] Error:', {
          code: error.code,
          message: error.message,
          name: error.name,
          stack: error.stack?.substring(0, 200),
        });
        Alert.alert(
          state.language === 'zh-TW' ? 'ç™»å…¥éŒ¯èª¤' : 'Login Error',
          state.language === 'zh-TW' ? 'ç„¡æ³•å®Œæˆ Apple ç™»å…¥' : 'Could not complete Apple Sign In'
        );
      }
    } finally {
      setLoading(false);
    }
  };

  if (checkingAuth) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={MibuBrand.brown} />
      </View>
    );
  }

  const t = {
    'zh-TW': {
      switchPortal: 'åˆ‡æ›ç”¨æˆ¶åˆ¥',
      login: 'Google ç™»å…¥',
      guest: 'è¨ªå®¢ç™»å…¥',
      guestNote: 'è¨ªå®¢æ¨¡å¼çš„è³‡æ–™åƒ…ä¿å­˜åœ¨æ­¤è£ç½®',
    },
    'en': {
      switchPortal: 'Switch Portal',
      login: 'Google Sign In',
      guest: 'Guest Login',
      guestNote: 'Guest mode data is only saved on this device',
    },
    'ja': {
      switchPortal: 'ãƒãƒ¼ã‚¿ãƒ«åˆ‡æ›¿',
      login: 'Googleãƒ­ã‚°ã‚¤ãƒ³',
      guest: 'ã‚²ã‚¹ãƒˆãƒ­ã‚°ã‚¤ãƒ³',
      guestNote: 'ã‚²ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ã®ãƒ‡ãƒ¼ã‚¿ã¯ã“ã®ãƒ‡ãƒã‚¤ã‚¹ã«ã®ã¿ä¿å­˜',
    },
    'ko': {
      switchPortal: 'í¬í„¸ ì „í™˜',
      login: 'Google ë¡œê·¸ì¸',
      guest: 'ê²ŒìŠ¤íŠ¸ ë¡œê·¸ì¸',
      guestNote: 'ê²ŒìŠ¤íŠ¸ ëª¨ë“œ ë°ì´í„°ëŠ” ì´ ê¸°ê¸°ì—ë§Œ ì €ì¥ë©ë‹ˆë‹¤',
    },
  };

  const texts = t[state.language] || t['zh-TW'];

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <View style={styles.headerLeft}>
          <Image 
            source={require('../assets/images/icon.png')} 
            style={styles.logo}
            resizeMode="contain"
          />
          <Text style={styles.headerTitle}>MIBU</Text>
        </View>
        <TouchableOpacity 
          style={styles.globeButton}
          onPress={() => setShowLanguageMenu(!showLanguageMenu)}
        >
          <Ionicons name="globe-outline" size={28} color={MibuBrand.copper} />
        </TouchableOpacity>
        {showLanguageMenu && (
          <View style={styles.languageMenu}>
            {LANGUAGE_OPTIONS.map((lang) => (
              <TouchableOpacity
                key={lang.code}
                style={[
                  styles.languageMenuItem,
                  state.language === lang.code && styles.languageMenuItemActive,
                ]}
                onPress={() => {
                  setLanguage(lang.code);
                  setShowLanguageMenu(false);
                }}
              >
                <Text style={styles.languageFlag}>{lang.flag}</Text>
                <Text style={[
                  styles.languageMenuText,
                  state.language === lang.code && styles.languageMenuTextActive,
                ]}>
                  {lang.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        )}
      </View>

      <View style={styles.portalSwitcher}>
        <TouchableOpacity 
          style={styles.switchButton}
          onPress={() => setShowPortalMenu(!showPortalMenu)}
        >
          <Text style={[styles.switchButtonText, { color: currentPortal.color }]}>
            {texts.switchPortal}
          </Text>
        </TouchableOpacity>

        {showPortalMenu && (
          <View style={styles.portalMenu}>
            {portals.map((portal) => (
              <TouchableOpacity
                key={portal.type}
                style={[
                  styles.portalMenuItem,
                  selectedPortal === portal.type && { backgroundColor: portal.bgColor },
                ]}
                onPress={() => {
                  setSelectedPortal(portal.type);
                  setShowPortalMenu(false);
                }}
              >
                <Text style={[
                  styles.portalMenuText,
                  selectedPortal === portal.type && { color: portal.color, fontWeight: '700' },
                ]}>
                  {portal.label}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        )}
      </View>

      <View style={styles.content}>
        <Text style={styles.title}>Mibu</Text>
        <Text style={styles.subtitle}>ä»Šå¤©å»å“ªç©?è€å¤©èªªäº†ç®—</Text>

        <View style={styles.buttonContainer}>
          {(selectedPortal === 'merchant' || selectedPortal === 'specialist') ? (
            <>
              <TextInput
                style={styles.emailInput}
                placeholder={state.language === 'zh-TW' ? 'Email' : 'Email'}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                placeholderTextColor={MibuBrand.copper}
              />
              <TextInput
                style={styles.emailInput}
                placeholder={state.language === 'zh-TW' ? 'å¯†ç¢¼' : 'Password'}
                value={password}
                onChangeText={setPassword}
                secureTextEntry
                placeholderTextColor={MibuBrand.copper}
              />
              <TouchableOpacity 
                style={[styles.loginButton, { backgroundColor: currentPortal.color }]} 
                onPress={handleEmailLogin}
                disabled={loading}
              >
                {loading ? (
                  <ActivityIndicator color="#ffffff" />
                ) : (
                  <>
                    <Ionicons name="log-in-outline" size={22} color="#ffffff" />
                    <Text style={styles.loginButtonText}>{texts.login}</Text>
                  </>
                )}
              </TouchableOpacity>

              <TouchableOpacity
                style={[styles.registerButton, { borderColor: currentPortal.color }]}
                onPress={() => router.push(selectedPortal === 'merchant' ? '/register-merchant' : '/register-specialist')}
              >
                <Ionicons name="person-add-outline" size={20} color={currentPortal.color} />
                <Text style={[styles.registerButtonText, { color: currentPortal.color }]}>
                  {state.language === 'zh-TW' ? 'ç”³è«‹è¨»å†Š' : 'Register'}
                </Text>
              </TouchableOpacity>
            </>
          ) : (
            <>
              <TouchableOpacity 
                style={[styles.loginButton, { backgroundColor: currentPortal.color }]} 
                onPress={handleLogin}
                disabled={loading}
              >
                {loading ? (
                  <ActivityIndicator color="#ffffff" />
                ) : (
                  <>
                    <Ionicons name="arrow-redo" size={22} color="#ffffff" />
                    <Text style={styles.loginButtonText}>{texts.login}</Text>
                  </>
                )}
              </TouchableOpacity>

              {Platform.OS === 'ios' && (
                <AppleAuthentication.AppleAuthenticationButton
                  buttonType={AppleAuthentication.AppleAuthenticationButtonType.SIGN_IN}
                  buttonStyle={AppleAuthentication.AppleAuthenticationButtonStyle.BLACK}
                  cornerRadius={28}
                  style={{ width: '100%', height: 52, marginTop: 12 }}
                  onPress={handleAppleLogin}
                />
              )}

              <View style={styles.dividerContainer}>
                <View style={styles.dividerLine} />
                <Text style={styles.dividerText}>{state.language === 'zh-TW' ? 'æˆ–ä½¿ç”¨ Email' : 'or use Email'}</Text>
                <View style={styles.dividerLine} />
              </View>

              <TextInput
                style={styles.emailInput}
                placeholder={state.language === 'zh-TW' ? 'Email' : 'Email'}
                value={email}
                onChangeText={setEmail}
                keyboardType="email-address"
                autoCapitalize="none"
                placeholderTextColor={MibuBrand.copper}
              />
              <TextInput
                style={styles.emailInput}
                placeholder={state.language === 'zh-TW' ? 'å¯†ç¢¼' : 'Password'}
                value={password}
                onChangeText={setPassword}
                secureTextEntry
                placeholderTextColor={MibuBrand.copper}
              />
              <TouchableOpacity 
                style={[styles.emailLoginButton, { borderColor: currentPortal.color }]} 
                onPress={handleEmailLogin}
                disabled={loading}
              >
                {loading ? (
                  <ActivityIndicator color={currentPortal.color} />
                ) : (
                  <>
                    <Ionicons name="log-in-outline" size={20} color={currentPortal.color} />
                    <Text style={[styles.emailLoginButtonText, { color: currentPortal.color }]}>
                      {state.language === 'zh-TW' ? 'ç™»å…¥' : 'Login'}
                    </Text>
                  </>
                )}
              </TouchableOpacity>

              <TouchableOpacity
                style={styles.registerLink}
                onPress={() => router.push('/register')}
              >
                <Text style={styles.registerLinkText}>
                  {state.language === 'zh-TW' ? 'é‚„æ²’æœ‰å¸³è™Ÿï¼Ÿ' : "Don't have an account? "}
                  <Text style={styles.registerLinkHighlight}>
                    {state.language === 'zh-TW' ? 'ç«‹å³è¨»å†Š' : 'Register now'}
                  </Text>
                </Text>
              </TouchableOpacity>

              {currentPortal.guestAllowed && (
                <TouchableOpacity style={styles.guestButton} onPress={handleGuestLogin}>
                  <Text style={styles.guestButtonText}>{texts.guest}</Text>
                </TouchableOpacity>
              )}
            </>
          )}

          <Text style={styles.note}>
            {currentPortal.guestAllowed ? texts.guestNote : currentPortal.subtitle}
          </Text>
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: MibuBrand.creamLight,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 16,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  logo: {
    width: 48,
    height: 48,
    borderRadius: 12,
  },
  headerTitle: {
    fontSize: 22,
    fontWeight: '800',
    color: MibuBrand.dark,
    letterSpacing: 2,
  },
  globeButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
    justifyContent: 'center',
    alignItems: 'center',
  },
  portalSwitcher: {
    alignItems: 'flex-end',
    paddingHorizontal: 20,
    zIndex: 100,
  },
  switchButton: {
    paddingVertical: 8,
    paddingHorizontal: 16,
  },
  switchButtonText: {
    fontSize: 15,
    fontWeight: '600',
  },
  portalMenu: {
    position: 'absolute',
    top: 40,
    right: 20,
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    paddingVertical: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
    minWidth: 140,
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
  },
  portalMenuItem: {
    paddingVertical: 14,
    paddingHorizontal: 20,
  },
  portalMenuText: {
    fontSize: 16,
    color: '#64748b',
  },
  languageMenu: {
    position: 'absolute',
    top: 110,
    right: 20,
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    paddingVertical: 8,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
    minWidth: 160,
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
    zIndex: 1000,
  },
  languageMenuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
    paddingHorizontal: 16,
    gap: 10,
  },
  languageMenuItemActive: {
    backgroundColor: MibuBrand.highlight,
  },
  languageFlag: {
    fontSize: 20,
  },
  languageMenuText: {
    fontSize: 15,
    color: '#64748b',
  },
  languageMenuTextActive: {
    color: MibuBrand.brown,
    fontWeight: '700',
  },
  appleButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
    backgroundColor: '#000000',
    paddingVertical: 16,
    borderRadius: 28,
    marginTop: 12,
  },
  appleButtonText: {
    fontSize: 17,
    fontWeight: '600',
    color: '#ffffff',
  },
  content: {
    flex: 1,
    paddingHorizontal: 32,
    justifyContent: 'center',
    marginTop: -60,
  },
  title: {
    fontSize: 48,
    fontWeight: '700',
    color: MibuBrand.brown,
    textAlign: 'center',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: MibuBrand.copper,
    textAlign: 'center',
    marginBottom: 48,
  },
  buttonContainer: {
    gap: 12,
  },
  loginButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
    paddingVertical: 18,
    paddingHorizontal: 32,
    borderRadius: 20,
    shadowColor: MibuBrand.brownDark,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  loginButtonText: {
    fontSize: 18,
    fontWeight: '700',
    color: '#ffffff',
  },
  guestButton: {
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: MibuBrand.warmWhite,
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  guestButtonText: {
    fontSize: 17,
    fontWeight: '600',
    color: MibuBrand.dark,
  },
  registerButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: MibuBrand.warmWhite,
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 20,
    borderWidth: 2,
    marginTop: 12,
  },
  registerButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  emailInput: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    paddingHorizontal: 20,
    paddingVertical: 16,
    fontSize: 16,
    color: MibuBrand.brownDark,
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
  },
  dividerContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 16,
  },
  dividerLine: {
    flex: 1,
    height: 1,
    backgroundColor: MibuBrand.tanLight,
  },
  dividerText: {
    paddingHorizontal: 16,
    fontSize: 14,
    color: MibuBrand.copper,
  },
  emailLoginButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: MibuBrand.warmWhite,
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 20,
    borderWidth: 2,
  },
  emailLoginButtonText: {
    fontSize: 16,
    fontWeight: '600',
  },
  registerLink: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  registerLinkText: {
    fontSize: 15,
    color: MibuBrand.copper,
  },
  registerLinkHighlight: {
    fontWeight: '700',
    color: MibuBrand.brown,
  },
  note: {
    fontSize: 14,
    color: MibuBrand.brown,
    textAlign: 'center',
    marginTop: 16,
  },
});

=== File: app/merchant/analytics.tsx ===

import { MerchantAnalyticsScreen } from '../../src/screens/MerchantAnalyticsScreen';

export default function MerchantAnalyticsPage() {
  return <MerchantAnalyticsScreen />;
}

=== File: app/merchant/coupons.tsx ===

import { MerchantCouponsScreen } from '../../src/screens/MerchantCouponsScreen';

export default function MerchantCouponsPage() {
  return <MerchantCouponsScreen />;
}

=== File: app/merchant-dashboard.tsx ===

import { MerchantDashboardScreen } from '../src/screens/MerchantDashboardScreen';

export default MerchantDashboardScreen;

=== File: app/merchant/_layout.tsx ===

import { Stack } from 'expo-router';

export default function MerchantLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
      }}
    />
  );
}

=== File: app/merchant/places.tsx ===

import { MerchantPlacesScreen } from '../../src/screens/MerchantPlacesScreen';

export default function MerchantPlacesPage() {
  return <MerchantPlacesScreen />;
}

=== File: app/merchant/products.tsx ===

import { MerchantProductsScreen } from '../../src/screens/MerchantProductsScreen';

export default function MerchantProductsPage() {
  return <MerchantProductsScreen />;
}

=== File: app/merchant/profile.tsx ===

import { MerchantProfileScreen } from '../../src/screens/MerchantProfileScreen';

export default function MerchantProfilePage() {
  return <MerchantProfileScreen />;
}

=== File: app/merchant-register.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TextInput,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../src/context/AppContext';
import { apiService } from '../src/services/api';
import { MibuBrand } from '../constants/Colors';
import { MerchantApplyParams } from '../src/types';

const BUSINESS_CATEGORIES = [
  { value: 'restaurant', labelZh: 'é¤é£²æ¥­', labelEn: 'Restaurant' },
  { value: 'hotel', labelZh: 'ä½å®¿æ¥­', labelEn: 'Hotel/Accommodation' },
  { value: 'attraction', labelZh: 'æ™¯é»/éŠæ¨‚', labelEn: 'Attraction/Entertainment' },
  { value: 'shopping', labelZh: 'è³¼ç‰©é›¶å”®', labelEn: 'Shopping/Retail' },
  { value: 'transportation', labelZh: 'äº¤é€šæœå‹™', labelEn: 'Transportation' },
  { value: 'experience', labelZh: 'é«”é©—æ´»å‹•', labelEn: 'Experience/Activity' },
  { value: 'culture', labelZh: 'æ–‡åŒ–è—è¡“', labelEn: 'Culture/Art' },
  { value: 'other', labelZh: 'å…¶ä»–', labelEn: 'Other' },
];

export default function MerchantRegisterScreen() {
  const { state } = useApp();
  const router = useRouter();
  const isZh = state.language === 'zh-TW';

  const [loading, setLoading] = useState(false);
  const [showCategoryPicker, setShowCategoryPicker] = useState(false);

  const [ownerName, setOwnerName] = useState('');
  const [businessName, setBusinessName] = useState('');
  const [taxId, setTaxId] = useState('');
  const [businessCategory, setBusinessCategory] = useState('');
  const [address, setAddress] = useState('');
  const [phone, setPhone] = useState('');
  const [mobile, setMobile] = useState('');
  const [email, setEmail] = useState('');

  const translations = {
    title: isZh ? 'å•†å®¶è¨»å†Š' : 'Merchant Registration',
    subtitle: isZh ? 'å¡«å¯«è³‡æ–™ä»¥ç”³è«‹æˆç‚ºåˆä½œå•†å®¶' : 'Fill in your details to apply as a partner merchant',
    ownerName: isZh ? 'è² è²¬äººå§“å' : 'Owner Name',
    ownerNamePlaceholder: isZh ? 'è«‹è¼¸å…¥è² è²¬äººå§“å' : 'Enter owner name',
    businessName: isZh ? 'å•†å®¶åç¨±' : 'Business Name',
    businessNamePlaceholder: isZh ? 'è«‹è¼¸å…¥å•†å®¶åç¨±' : 'Enter business name',
    taxId: isZh ? 'çµ±ä¸€ç·¨è™Ÿï¼ˆé¸å¡«ï¼‰' : 'Tax ID (Optional)',
    taxIdPlaceholder: isZh ? 'è«‹è¼¸å…¥çµ±ä¸€ç·¨è™Ÿ' : 'Enter tax ID',
    businessCategory: isZh ? 'ç‡Ÿæ¥­é¡åˆ¥' : 'Business Category',
    businessCategoryPlaceholder: isZh ? 'è«‹é¸æ“‡ç‡Ÿæ¥­é¡åˆ¥' : 'Select business category',
    address: isZh ? 'å•†å®¶åœ°å€' : 'Business Address',
    addressPlaceholder: isZh ? 'è«‹è¼¸å…¥å•†å®¶åœ°å€' : 'Enter business address',
    phone: isZh ? 'é›»è©±ï¼ˆé¸å¡«ï¼‰' : 'Phone (Optional)',
    phonePlaceholder: isZh ? 'è«‹è¼¸å…¥é›»è©±' : 'Enter phone number',
    mobile: isZh ? 'æ‰‹æ©Ÿ' : 'Mobile',
    mobilePlaceholder: isZh ? 'è«‹è¼¸å…¥æ‰‹æ©Ÿè™Ÿç¢¼' : 'Enter mobile number',
    email: isZh ? 'Email' : 'Email',
    emailPlaceholder: isZh ? 'è«‹è¼¸å…¥ Email' : 'Enter email',
    cancel: isZh ? 'å–æ¶ˆ' : 'Cancel',
    submit: isZh ? 'é€å¯©' : 'Submit for Review',
    submitting: isZh ? 'æäº¤ä¸­...' : 'Submitting...',
    success: isZh ? 'é€å¯©æˆåŠŸ' : 'Submitted Successfully',
    successMessage: isZh ? 'æ‚¨çš„ç”³è«‹å·²æäº¤ï¼Œè«‹ç­‰å¾…å¯©æ ¸é€šéã€‚' : 'Your application has been submitted. Please wait for approval.',
    error: isZh ? 'éŒ¯èª¤' : 'Error',
    errorMessage: isZh ? 'æäº¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Submission failed. Please try again.',
    requiredFields: isZh ? 'è«‹å¡«å¯«æ‰€æœ‰å¿…å¡«æ¬„ä½' : 'Please fill in all required fields',
    invalidEmail: isZh ? 'è«‹è¼¸å…¥æœ‰æ•ˆçš„ Email' : 'Please enter a valid email',
  };

  const validateForm = (): boolean => {
    if (!ownerName.trim() || !businessName.trim() || !businessCategory || !address.trim() || !mobile.trim() || !email.trim()) {
      Alert.alert(translations.error, translations.requiredFields);
      return false;
    }
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (!emailRegex.test(email.trim())) {
      Alert.alert(translations.error, translations.invalidEmail);
      return false;
    }
    return true;
  };

  const handleSubmit = async () => {
    if (!validateForm()) return;

    setLoading(true);
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) {
        router.replace('/login');
        return;
      }

      const params: MerchantApplyParams = {
        ownerName: ownerName.trim(),
        businessName: businessName.trim(),
        taxId: taxId.trim() || undefined,
        businessCategory,
        address: address.trim(),
        phone: phone.trim() || undefined,
        mobile: mobile.trim(),
        email: email.trim(),
      };

      await apiService.applyMerchant(token, params);

      Alert.alert(translations.success, translations.successMessage, [
        { text: 'OK', onPress: () => router.replace('/pending-approval') },
      ]);
    } catch (error: any) {
      console.error('Merchant registration failed:', error);
      Alert.alert(translations.error, error?.message || translations.errorMessage);
    } finally {
      setLoading(false);
    }
  };

  const handleCancel = () => {
    router.replace('/');
  };

  const selectedCategory = BUSINESS_CATEGORIES.find(c => c.value === businessCategory);

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <View style={styles.header}>
        <TouchableOpacity onPress={handleCancel} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color={MibuBrand.dark} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{translations.title}</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView 
        style={styles.content} 
        contentContainerStyle={styles.scrollContent}
        showsVerticalScrollIndicator={false}
      >
        <Text style={styles.subtitle}>{translations.subtitle}</Text>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.ownerName} *</Text>
          <TextInput
            style={styles.input}
            value={ownerName}
            onChangeText={setOwnerName}
            placeholder={translations.ownerNamePlaceholder}
            placeholderTextColor="#9ca3af"
          />
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.businessName} *</Text>
          <TextInput
            style={styles.input}
            value={businessName}
            onChangeText={setBusinessName}
            placeholder={translations.businessNamePlaceholder}
            placeholderTextColor="#9ca3af"
          />
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.taxId}</Text>
          <TextInput
            style={styles.input}
            value={taxId}
            onChangeText={setTaxId}
            placeholder={translations.taxIdPlaceholder}
            placeholderTextColor="#9ca3af"
            keyboardType="number-pad"
          />
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.businessCategory} *</Text>
          <TouchableOpacity 
            style={styles.picker}
            onPress={() => setShowCategoryPicker(!showCategoryPicker)}
          >
            <Text style={[styles.pickerText, !selectedCategory && styles.placeholderText]}>
              {selectedCategory 
                ? (isZh ? selectedCategory.labelZh : selectedCategory.labelEn)
                : translations.businessCategoryPlaceholder
              }
            </Text>
            <Ionicons 
              name={showCategoryPicker ? 'chevron-up' : 'chevron-down'} 
              size={20} 
              color="#64748b" 
            />
          </TouchableOpacity>
          {showCategoryPicker && (
            <View style={styles.pickerOptions}>
              {BUSINESS_CATEGORIES.map((cat) => (
                <TouchableOpacity
                  key={cat.value}
                  style={[
                    styles.pickerOption,
                    businessCategory === cat.value && styles.pickerOptionSelected
                  ]}
                  onPress={() => {
                    setBusinessCategory(cat.value);
                    setShowCategoryPicker(false);
                  }}
                >
                  <Text style={[
                    styles.pickerOptionText,
                    businessCategory === cat.value && styles.pickerOptionTextSelected
                  ]}>
                    {isZh ? cat.labelZh : cat.labelEn}
                  </Text>
                  {businessCategory === cat.value && (
                    <Ionicons name="checkmark" size={18} color={MibuBrand.brown} />
                  )}
                </TouchableOpacity>
              ))}
            </View>
          )}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.address} *</Text>
          <TextInput
            style={styles.input}
            value={address}
            onChangeText={setAddress}
            placeholder={translations.addressPlaceholder}
            placeholderTextColor="#9ca3af"
          />
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.phone}</Text>
          <TextInput
            style={styles.input}
            value={phone}
            onChangeText={setPhone}
            placeholder={translations.phonePlaceholder}
            placeholderTextColor="#9ca3af"
            keyboardType="phone-pad"
          />
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.mobile} *</Text>
          <TextInput
            style={styles.input}
            value={mobile}
            onChangeText={setMobile}
            placeholder={translations.mobilePlaceholder}
            placeholderTextColor="#9ca3af"
            keyboardType="phone-pad"
          />
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>{translations.email} *</Text>
          <TextInput
            style={styles.input}
            value={email}
            onChangeText={setEmail}
            placeholder={translations.emailPlaceholder}
            placeholderTextColor="#9ca3af"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </View>

        <View style={styles.buttonContainer}>
          <TouchableOpacity 
            style={styles.cancelButton}
            onPress={handleCancel}
            disabled={loading}
          >
            <Text style={styles.cancelButtonText}>{translations.cancel}</Text>
          </TouchableOpacity>

          <TouchableOpacity 
            style={[styles.submitButton, loading && styles.submitButtonDisabled]}
            onPress={handleSubmit}
            disabled={loading}
          >
            {loading ? (
              <ActivityIndicator size="small" color="#fff" />
            ) : (
              <>
                <Ionicons name="send" size={18} color="#fff" />
                <Text style={styles.submitButtonText}>{translations.submit}</Text>
              </>
            )}
          </TouchableOpacity>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 60,
    paddingBottom: 16,
    backgroundColor: MibuBrand.cream,
    borderBottomWidth: 1,
    borderBottomColor: MibuBrand.tanLight,
  },
  backButton: {
    padding: 8,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: MibuBrand.dark,
  },
  placeholder: {
    width: 40,
  },
  content: {
    flex: 1,
  },
  scrollContent: {
    padding: 20,
    paddingBottom: 40,
  },
  subtitle: {
    fontSize: 14,
    color: '#64748b',
    marginBottom: 24,
    textAlign: 'center',
  },
  formGroup: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: MibuBrand.dark,
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#fff',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 16,
    color: MibuBrand.dark,
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
  },
  picker: {
    backgroundColor: '#fff',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
  },
  pickerText: {
    fontSize: 16,
    color: MibuBrand.dark,
  },
  placeholderText: {
    color: '#9ca3af',
  },
  pickerOptions: {
    backgroundColor: '#fff',
    borderRadius: 12,
    marginTop: 8,
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
    overflow: 'hidden',
  },
  pickerOption: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: MibuBrand.tanLight,
  },
  pickerOptionSelected: {
    backgroundColor: MibuBrand.highlight,
  },
  pickerOptionText: {
    fontSize: 15,
    color: MibuBrand.dark,
  },
  pickerOptionTextSelected: {
    fontWeight: '600',
    color: MibuBrand.brown,
  },
  buttonContainer: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 24,
  },
  cancelButton: {
    flex: 1,
    backgroundColor: '#fff',
    borderRadius: 12,
    paddingVertical: 16,
    alignItems: 'center',
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#64748b',
  },
  submitButton: {
    flex: 2,
    backgroundColor: MibuBrand.brown,
    borderRadius: 12,
    paddingVertical: 16,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
  },
  submitButtonDisabled: {
    opacity: 0.7,
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#fff',
  },
});

=== File: app/merchant/transactions.tsx ===

import { MerchantTransactionsScreen } from '../../src/screens/MerchantTransactionsScreen';

export default MerchantTransactionsScreen;

=== File: app/merchant/verify.tsx ===

import { MerchantVerifyScreen } from '../../src/screens/MerchantVerifyScreen';

export default MerchantVerifyScreen;

=== File: app/+not-found.tsx ===

import { Link, Stack } from 'expo-router';
import { StyleSheet } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';

export default function NotFoundScreen() {
  return (
    <>
      <Stack.Screen options={{ title: 'Oops!' }} />
      <ThemedView style={styles.container}>
        <ThemedText type="title">This screen does not exist.</ThemedText>
        <Link href="/" style={styles.link}>
          <ThemedText type="link">Go to home screen!</ThemedText>
        </Link>
      </ThemedView>
    </>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  link: {
    marginTop: 15,
    paddingVertical: 15,
  },
});

=== File: app/pending-approval.tsx ===

import { PendingApprovalScreen } from '../src/screens/PendingApprovalScreen';

export default PendingApprovalScreen;

=== File: app/profile.tsx ===

import { ProfileScreen } from '../src/screens/ProfileScreen';

export default function Profile() {
  return <ProfileScreen />;
}

=== File: app/register-merchant.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../src/context/AppContext';
import { API_BASE_URL } from '../src/constants/translations';
import { MibuBrand } from '../constants/Colors';

const BUSINESS_CATEGORIES = [
  { value: 'restaurant', label: { zh: 'é¤é£²', en: 'Restaurant' } },
  { value: 'hotel', label: { zh: 'ä½å®¿', en: 'Hotel' } },
  { value: 'attraction', label: { zh: 'æ™¯é»', en: 'Attraction' } },
  { value: 'shopping', label: { zh: 'è³¼ç‰©', en: 'Shopping' } },
  { value: 'activity', label: { zh: 'æ´»å‹•', en: 'Activity' } },
  { value: 'other', label: { zh: 'å…¶ä»–', en: 'Other' } },
];

export default function RegisterMerchantScreen() {
  const router = useRouter();
  const { state } = useApp();
  const isZh = state.language === 'zh-TW';

  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: '',
    businessName: '',
    contactName: '',
    taxId: '',
    businessCategory: '',
    address: '',
    otherContact: '',
  });
  const [showCategoryPicker, setShowCategoryPicker] = useState(false);

  const texts = {
    title: isZh ? 'å•†å®¶è¨»å†Š' : 'Merchant Registration',
    email: isZh ? 'Emailï¼ˆå¸³è™Ÿï¼‰' : 'Email (Account)',
    password: isZh ? 'å¯†ç¢¼ï¼ˆè‡³å°‘6å­—ï¼‰' : 'Password (min 6 chars)',
    confirmPassword: isZh ? 'ç¢ºèªå¯†ç¢¼' : 'Confirm Password',
    businessName: isZh ? 'å•†å®¶åç¨±' : 'Business Name',
    contactName: isZh ? 'è¯çµ¡äººåç¨±' : 'Contact Name',
    taxId: isZh ? 'çµ±ä¸€ç·¨è™Ÿï¼ˆé¸å¡«ï¼‰' : 'Tax ID (Optional)',
    businessCategory: isZh ? 'ç”¢æ¥­é¡åˆ¥' : 'Business Category',
    address: isZh ? 'ç‡Ÿæ¥­åœ°å€' : 'Business Address',
    otherContact: isZh ? 'å…¶ä»–è¯çµ¡æ–¹å¼ï¼ˆé¸å¡«ï¼‰' : 'Other Contact (Optional)',
    submit: isZh ? 'æäº¤ç”³è«‹' : 'Submit Application',
    back: isZh ? 'è¿”å›ç™»å…¥' : 'Back to Login',
    selectCategory: isZh ? 'è«‹é¸æ“‡ç”¢æ¥­é¡åˆ¥' : 'Select Business Category',
    required: isZh ? 'å¿…å¡«' : 'Required',
  };

  const validateForm = () => {
    if (!formData.email.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹è¼¸å…¥ Email' : 'Please enter email');
      return false;
    }
    if (!formData.email.includes('@')) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'Email æ ¼å¼ä¸æ­£ç¢º' : 'Invalid email format');
      return false;
    }
    if (formData.password.length < 6) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'å¯†ç¢¼è‡³å°‘éœ€è¦6å€‹å­—' : 'Password must be at least 6 characters');
      return false;
    }
    if (formData.password !== formData.confirmPassword) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'å¯†ç¢¼ä¸ä¸€è‡´' : 'Passwords do not match');
      return false;
    }
    if (!formData.businessName.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹è¼¸å…¥å•†å®¶åç¨±' : 'Please enter business name');
      return false;
    }
    if (!formData.contactName.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹è¼¸å…¥è¯çµ¡äººåç¨±' : 'Please enter contact name');
      return false;
    }
    if (!formData.businessCategory) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹é¸æ“‡ç”¢æ¥­é¡åˆ¥' : 'Please select business category');
      return false;
    }
    if (!formData.address.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹è¼¸å…¥ç‡Ÿæ¥­åœ°å€' : 'Please enter business address');
      return false;
    }
    return true;
  };

  const handleSubmit = async () => {
    if (!validateForm()) return;

    try {
      setLoading(true);
      const response = await fetch(`${API_BASE_URL}/api/auth/register/merchant`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: formData.email.trim(),
          password: formData.password,
          businessName: formData.businessName.trim(),
          contactName: formData.contactName.trim(),
          taxId: formData.taxId.trim() || undefined,
          businessCategory: formData.businessCategory,
          address: formData.address.trim(),
          otherContact: formData.otherContact.trim() || undefined,
        }),
      });

      const data = await response.json();

      if (data.success) {
        router.replace('/register-success');
      } else {
        Alert.alert(isZh ? 'è¨»å†Šå¤±æ•—' : 'Registration Failed', data.message || (isZh ? 'è«‹ç¨å¾Œå†è©¦' : 'Please try again later'));
      }
    } catch (error) {
      console.error('Registration error:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è¨»å†Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Registration failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  const getCategoryLabel = (value: string) => {
    const cat = BUSINESS_CATEGORIES.find(c => c.value === value);
    return cat ? cat.label[isZh ? 'zh' : 'en'] : texts.selectCategory;
  };

  return (
    <KeyboardAvoidingView style={styles.container} behavior={Platform.OS === 'ios' ? 'padding' : 'height'}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="chevron-back" size={24} color={MibuBrand.brown} />
          <Text style={styles.backText}>{texts.back}</Text>
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView} contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
        <Text style={styles.title}>{texts.title}</Text>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.email} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.email}
            onChangeText={(text) => setFormData(prev => ({ ...prev, email: text }))}
            placeholder="example@email.com"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.password} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.password}
            onChangeText={(text) => setFormData(prev => ({ ...prev, password: text }))}
            placeholder="******"
            secureTextEntry
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.confirmPassword} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.confirmPassword}
            onChangeText={(text) => setFormData(prev => ({ ...prev, confirmPassword: text }))}
            placeholder="******"
            secureTextEntry
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.businessName} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.businessName}
            onChangeText={(text) => setFormData(prev => ({ ...prev, businessName: text }))}
            placeholder={isZh ? 'è«‹è¼¸å…¥å•†å®¶åç¨±' : 'Enter business name'}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.contactName} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.contactName}
            onChangeText={(text) => setFormData(prev => ({ ...prev, contactName: text }))}
            placeholder={isZh ? 'è«‹è¼¸å…¥è¯çµ¡äººå§“å' : 'Enter contact name'}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.businessCategory} <Text style={styles.required}>*</Text></Text>
          <TouchableOpacity style={styles.selectInput} onPress={() => setShowCategoryPicker(!showCategoryPicker)}>
            <Text style={[styles.selectText, !formData.businessCategory && styles.placeholder]}>
              {getCategoryLabel(formData.businessCategory)}
            </Text>
            <Ionicons name="chevron-down" size={20} color={MibuBrand.copper} />
          </TouchableOpacity>
          {showCategoryPicker && (
            <View style={styles.picker}>
              {BUSINESS_CATEGORIES.map(cat => (
                <TouchableOpacity
                  key={cat.value}
                  style={[styles.pickerItem, formData.businessCategory === cat.value && styles.pickerItemSelected]}
                  onPress={() => {
                    setFormData(prev => ({ ...prev, businessCategory: cat.value }));
                    setShowCategoryPicker(false);
                  }}
                >
                  <Text style={[styles.pickerText, formData.businessCategory === cat.value && styles.pickerTextSelected]}>
                    {cat.label[isZh ? 'zh' : 'en']}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          )}
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.address} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.address}
            onChangeText={(text) => setFormData(prev => ({ ...prev, address: text }))}
            placeholder={isZh ? 'è«‹è¼¸å…¥ç‡Ÿæ¥­åœ°å€' : 'Enter business address'}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.taxId}</Text>
          <TextInput
            style={styles.input}
            value={formData.taxId}
            onChangeText={(text) => setFormData(prev => ({ ...prev, taxId: text }))}
            placeholder={isZh ? 'çµ±ä¸€ç·¨è™Ÿ' : 'Tax ID'}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.otherContact}</Text>
          <TextInput
            style={styles.input}
            value={formData.otherContact}
            onChangeText={(text) => setFormData(prev => ({ ...prev, otherContact: text }))}
            placeholder={isZh ? 'LINE ID æˆ–é›»è©±' : 'LINE ID or Phone'}
          />
        </View>

        <TouchableOpacity style={styles.submitButton} onPress={handleSubmit} disabled={loading}>
          {loading ? (
            <ActivityIndicator color="#ffffff" />
          ) : (
            <Text style={styles.submitButtonText}>{texts.submit}</Text>
          )}
        </TouchableOpacity>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: MibuBrand.creamLight },
  header: { paddingTop: 60, paddingHorizontal: 20, paddingBottom: 12 },
  backButton: { flexDirection: 'row', alignItems: 'center' },
  backText: { fontSize: 16, color: MibuBrand.brown, marginLeft: 4 },
  scrollView: { flex: 1 },
  content: { paddingHorizontal: 24, paddingBottom: 60 },
  title: { fontSize: 28, fontWeight: '800', color: MibuBrand.brownDark, marginBottom: 24, textAlign: 'center' },
  inputGroup: { marginBottom: 16 },
  label: { fontSize: 14, fontWeight: '600', color: MibuBrand.brownDark, marginBottom: 8 },
  required: { color: '#ef4444' },
  input: { backgroundColor: MibuBrand.warmWhite, borderRadius: 12, paddingHorizontal: 16, paddingVertical: 14, fontSize: 16, color: MibuBrand.brownDark, borderWidth: 1, borderColor: MibuBrand.tanLight },
  selectInput: { backgroundColor: MibuBrand.warmWhite, borderRadius: 12, paddingHorizontal: 16, paddingVertical: 14, flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', borderWidth: 1, borderColor: MibuBrand.tanLight },
  selectText: { fontSize: 16, color: MibuBrand.brownDark },
  placeholder: { color: MibuBrand.copper },
  picker: { backgroundColor: MibuBrand.warmWhite, borderRadius: 12, marginTop: 8, borderWidth: 1, borderColor: MibuBrand.tanLight, overflow: 'hidden' },
  pickerItem: { paddingHorizontal: 16, paddingVertical: 12, borderBottomWidth: 1, borderBottomColor: MibuBrand.tanLight },
  pickerItemSelected: { backgroundColor: MibuBrand.highlight },
  pickerText: { fontSize: 15, color: MibuBrand.brownDark },
  pickerTextSelected: { color: MibuBrand.brown, fontWeight: '600' },
  submitButton: { backgroundColor: MibuBrand.success, borderRadius: 28, paddingVertical: 16, alignItems: 'center', marginTop: 24 },
  submitButtonText: { fontSize: 17, fontWeight: '700', color: '#ffffff' },
});

=== File: app/register-specialist.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  TextInput,
  TouchableOpacity,
  ScrollView,
  StyleSheet,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../src/context/AppContext';
import { API_BASE_URL } from '../src/constants/translations';
import { MibuBrand } from '../constants/Colors';

export default function RegisterSpecialistScreen() {
  const router = useRouter();
  const { state } = useApp();
  const isZh = state.language === 'zh-TW';

  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    confirmPassword: '',
    name: '',
    otherContact: '',
    serviceRegion: '',
  });

  const texts = {
    title: isZh ? 'å°ˆå“¡è¨»å†Š' : 'Specialist Registration',
    email: isZh ? 'Emailï¼ˆå¸³è™Ÿï¼‰' : 'Email (Account)',
    password: isZh ? 'å¯†ç¢¼ï¼ˆè‡³å°‘6å­—ï¼‰' : 'Password (min 6 chars)',
    confirmPassword: isZh ? 'ç¢ºèªå¯†ç¢¼' : 'Confirm Password',
    name: isZh ? 'åç¨±' : 'Name',
    otherContact: isZh ? 'å…¶ä»–è¯çµ¡æ–¹å¼ï¼ˆé¸å¡«ï¼‰' : 'Other Contact (Optional)',
    serviceRegion: isZh ? 'æœå‹™åœ°å€ï¼ˆé¸å¡«ï¼‰' : 'Service Region (Optional)',
    submit: isZh ? 'æäº¤ç”³è«‹' : 'Submit Application',
    back: isZh ? 'è¿”å›ç™»å…¥' : 'Back to Login',
    required: isZh ? 'å¿…å¡«' : 'Required',
  };

  const validateForm = () => {
    if (!formData.email.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹è¼¸å…¥ Email' : 'Please enter email');
      return false;
    }
    if (!formData.email.includes('@')) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'Email æ ¼å¼ä¸æ­£ç¢º' : 'Invalid email format');
      return false;
    }
    if (formData.password.length < 6) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'å¯†ç¢¼è‡³å°‘éœ€è¦6å€‹å­—' : 'Password must be at least 6 characters');
      return false;
    }
    if (formData.password !== formData.confirmPassword) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'å¯†ç¢¼ä¸ä¸€è‡´' : 'Passwords do not match');
      return false;
    }
    if (!formData.name.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹è¼¸å…¥åç¨±' : 'Please enter name');
      return false;
    }
    return true;
  };

  const handleSubmit = async () => {
    if (!validateForm()) return;

    try {
      setLoading(true);
      const response = await fetch(`${API_BASE_URL}/api/auth/register/specialist`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: formData.email.trim(),
          password: formData.password,
          name: formData.name.trim(),
          otherContact: formData.otherContact.trim() || undefined,
          serviceRegion: formData.serviceRegion.trim() || undefined,
        }),
      });

      const data = await response.json();

      if (data.success) {
        router.replace('/register-success');
      } else {
        Alert.alert(isZh ? 'è¨»å†Šå¤±æ•—' : 'Registration Failed', data.message || (isZh ? 'è«‹ç¨å¾Œå†è©¦' : 'Please try again later'));
      }
    } catch (error) {
      console.error('Registration error:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è¨»å†Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Registration failed. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView style={styles.container} behavior={Platform.OS === 'ios' ? 'padding' : 'height'}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="chevron-back" size={24} color="#9B7BB8" />
          <Text style={[styles.backText, { color: '#9B7BB8' }]}>{texts.back}</Text>
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView} contentContainerStyle={styles.content} showsVerticalScrollIndicator={false}>
        <Text style={styles.title}>{texts.title}</Text>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.email} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.email}
            onChangeText={(text) => setFormData(prev => ({ ...prev, email: text }))}
            placeholder="example@email.com"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.password} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.password}
            onChangeText={(text) => setFormData(prev => ({ ...prev, password: text }))}
            placeholder="******"
            secureTextEntry
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.confirmPassword} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.confirmPassword}
            onChangeText={(text) => setFormData(prev => ({ ...prev, confirmPassword: text }))}
            placeholder="******"
            secureTextEntry
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.name} <Text style={styles.required}>*</Text></Text>
          <TextInput
            style={styles.input}
            value={formData.name}
            onChangeText={(text) => setFormData(prev => ({ ...prev, name: text }))}
            placeholder={isZh ? 'è«‹è¼¸å…¥æ‚¨çš„åç¨±' : 'Enter your name'}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.serviceRegion}</Text>
          <TextInput
            style={styles.input}
            value={formData.serviceRegion}
            onChangeText={(text) => setFormData(prev => ({ ...prev, serviceRegion: text }))}
            placeholder={isZh ? 'ä¾‹å¦‚ï¼šå°åŒ—ã€å®œè˜­' : 'e.g., Taipei, Yilan'}
          />
        </View>

        <View style={styles.inputGroup}>
          <Text style={styles.label}>{texts.otherContact}</Text>
          <TextInput
            style={styles.input}
            value={formData.otherContact}
            onChangeText={(text) => setFormData(prev => ({ ...prev, otherContact: text }))}
            placeholder={isZh ? 'LINE ID æˆ–é›»è©±' : 'LINE ID or Phone'}
          />
        </View>

        <TouchableOpacity style={styles.submitButton} onPress={handleSubmit} disabled={loading}>
          {loading ? (
            <ActivityIndicator color="#ffffff" />
          ) : (
            <Text style={styles.submitButtonText}>{texts.submit}</Text>
          )}
        </TouchableOpacity>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: '#F5F0FA' },
  header: { paddingTop: 60, paddingHorizontal: 20, paddingBottom: 12 },
  backButton: { flexDirection: 'row', alignItems: 'center' },
  backText: { fontSize: 16, marginLeft: 4 },
  scrollView: { flex: 1 },
  content: { paddingHorizontal: 24, paddingBottom: 60 },
  title: { fontSize: 28, fontWeight: '800', color: '#5B3D6B', marginBottom: 24, textAlign: 'center' },
  inputGroup: { marginBottom: 16 },
  label: { fontSize: 14, fontWeight: '600', color: '#5B3D6B', marginBottom: 8 },
  required: { color: '#ef4444' },
  input: { backgroundColor: '#ffffff', borderRadius: 12, paddingHorizontal: 16, paddingVertical: 14, fontSize: 16, color: '#333333', borderWidth: 1, borderColor: '#E0D6E8' },
  submitButton: { backgroundColor: '#9B7BB8', borderRadius: 28, paddingVertical: 16, alignItems: 'center', marginTop: 24 },
  submitButtonText: { fontSize: 17, fontWeight: '700', color: '#ffffff' },
});

=== File: app/register-success.tsx ===

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Image } from 'react-native';
import { useRouter } from 'expo-router';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../src/context/AppContext';
import { MibuBrand } from '../constants/Colors';

export default function RegisterSuccessScreen() {
  const router = useRouter();
  const { state } = useApp();
  const isZh = state.language === 'zh-TW';

  const texts = {
    title: isZh ? 'ç”³è«‹å·²é€å‡ºï¼' : 'Application Submitted!',
    message: isZh ? 'å·²æ”¶åˆ°æ‚¨çš„ç”³è«‹ï¼Œç«‹é¦¬ç‚ºæ‚¨è™•ç†' : 'We have received your application and will process it shortly',
    note: isZh ? 'å¯©æ ¸é€šéå¾Œï¼Œæ‚¨å°‡æ”¶åˆ°é€šçŸ¥ï¼Œå±Šæ™‚å³å¯ä½¿ç”¨å¸³è™Ÿç™»å…¥' : 'Once approved, you will receive a notification and can log in with your account',
    backToLogin: isZh ? 'è¿”å›ç™»å…¥é é¢' : 'Back to Login',
  };

  return (
    <View style={styles.container}>
      <View style={styles.content}>
        <View style={styles.iconContainer}>
          <Ionicons name="checkmark-circle" size={80} color={MibuBrand.success} />
        </View>

        <Image
          source={require('../assets/images/icon.png')}
          style={styles.logo}
          resizeMode="contain"
        />

        <Text style={styles.title}>{texts.title}</Text>
        <Text style={styles.message}>{texts.message}</Text>
        <Text style={styles.note}>{texts.note}</Text>

        <TouchableOpacity style={styles.button} onPress={() => router.replace('/login')}>
          <Ionicons name="arrow-back" size={20} color="#ffffff" />
          <Text style={styles.buttonText}>{texts.backToLogin}</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
    alignItems: 'center',
    justifyContent: 'center',
    padding: 24,
  },
  content: {
    alignItems: 'center',
    maxWidth: 340,
  },
  iconContainer: {
    marginBottom: 20,
  },
  logo: {
    width: 80,
    height: 80,
    marginBottom: 24,
  },
  title: {
    fontSize: 26,
    fontWeight: '800',
    color: MibuBrand.brownDark,
    textAlign: 'center',
    marginBottom: 16,
  },
  message: {
    fontSize: 18,
    fontWeight: '600',
    color: MibuBrand.brown,
    textAlign: 'center',
    marginBottom: 12,
    lineHeight: 26,
  },
  note: {
    fontSize: 14,
    color: MibuBrand.copper,
    textAlign: 'center',
    lineHeight: 22,
    marginBottom: 40,
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: MibuBrand.brown,
    paddingVertical: 16,
    paddingHorizontal: 32,
    borderRadius: 28,
    width: '100%',
  },
  buttonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
});

=== File: app/register.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  TextInput,
  Alert,
  KeyboardAvoidingView,
  Platform,
  ScrollView,
} from 'react-native';
import { router } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../src/context/AppContext';
import { API_BASE_URL } from '../src/constants/translations';
import { MibuBrand } from '../constants/Colors';

const AUTH_TOKEN_KEY = '@mibu_token';

const TRANSLATIONS = {
  'zh-TW': {
    title: 'å»ºç«‹å¸³è™Ÿ',
    subtitle: 'é–‹å§‹ä½ çš„æ—…ç¨‹æ¢ç´¢ä¹‹æ—…',
    email: 'Email',
    password: 'å¯†ç¢¼ï¼ˆè‡³å°‘ 6 å€‹å­—å…ƒï¼‰',
    confirmPassword: 'ç¢ºèªå¯†ç¢¼',
    firstName: 'åå­—ï¼ˆé¸å¡«ï¼‰',
    register: 'è¨»å†Š',
    hasAccount: 'å·²æœ‰å¸³è™Ÿï¼Ÿ',
    login: 'è¿”å›ç™»å…¥',
    error: 'éŒ¯èª¤',
    success: 'æˆåŠŸ',
    registerSuccess: 'è¨»å†ŠæˆåŠŸï¼',
    registerFailed: 'è¨»å†Šå¤±æ•—',
    passwordTooShort: 'å¯†ç¢¼è‡³å°‘éœ€è¦ 6 å€‹å­—å…ƒ',
    passwordMismatch: 'å…©æ¬¡è¼¸å…¥çš„å¯†ç¢¼ä¸ä¸€è‡´',
    emailRequired: 'è«‹è¼¸å…¥ Email',
    emailExists: 'æ­¤é›»å­éƒµä»¶å·²è¢«è¨»å†Š',
    tryAgain: 'è«‹ç¨å¾Œå†è©¦',
  },
  'en': {
    title: 'Create Account',
    subtitle: 'Start your journey of exploration',
    email: 'Email',
    password: 'Password (at least 6 characters)',
    confirmPassword: 'Confirm Password',
    firstName: 'First Name (optional)',
    register: 'Register',
    hasAccount: 'Already have an account?',
    login: 'Back to Login',
    error: 'Error',
    success: 'Success',
    registerSuccess: 'Registration successful!',
    registerFailed: 'Registration failed',
    passwordTooShort: 'Password must be at least 6 characters',
    passwordMismatch: 'Passwords do not match',
    emailRequired: 'Please enter your email',
    emailExists: 'This email is already registered',
    tryAgain: 'Please try again later',
  },
  'ja': {
    title: 'ã‚¢ã‚«ã‚¦ãƒ³ãƒˆä½œæˆ',
    subtitle: 'æ¢æ¤œã®æ—…ã‚’å§‹ã‚ã‚ˆã†',
    email: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹',
    password: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆ6æ–‡å­—ä»¥ä¸Šï¼‰',
    confirmPassword: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ç¢ºèª',
    firstName: 'åå‰ï¼ˆä»»æ„ï¼‰',
    register: 'ç™»éŒ²',
    hasAccount: 'ã‚¢ã‚«ã‚¦ãƒ³ãƒˆã‚’ãŠæŒã¡ã§ã™ã‹ï¼Ÿ',
    login: 'ãƒ­ã‚°ã‚¤ãƒ³ã«æˆ»ã‚‹',
    error: 'ã‚¨ãƒ©ãƒ¼',
    success: 'æˆåŠŸ',
    registerSuccess: 'ç™»éŒ²æˆåŠŸï¼',
    registerFailed: 'ç™»éŒ²å¤±æ•—',
    passwordTooShort: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯6æ–‡å­—ä»¥ä¸Šå¿…è¦ã§ã™',
    passwordMismatch: 'ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒä¸€è‡´ã—ã¾ã›ã‚“',
    emailRequired: 'ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„',
    emailExists: 'ã“ã®ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã¾ã™',
    tryAgain: 'å¾Œã§ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„',
  },
  'ko': {
    title: 'ê³„ì • ë§Œë“¤ê¸°',
    subtitle: 'íƒí—˜ì˜ ì—¬ì •ì„ ì‹œì‘í•˜ì„¸ìš”',
    email: 'ì´ë©”ì¼',
    password: 'ë¹„ë°€ë²ˆí˜¸ (6ì ì´ìƒ)',
    confirmPassword: 'ë¹„ë°€ë²ˆí˜¸ í™•ì¸',
    firstName: 'ì´ë¦„ (ì„ íƒ)',
    register: 'ê°€ì…',
    hasAccount: 'ì´ë¯¸ ê³„ì •ì´ ìˆìœ¼ì‹ ê°€ìš”?',
    login: 'ë¡œê·¸ì¸ìœ¼ë¡œ ëŒì•„ê°€ê¸°',
    error: 'ì˜¤ë¥˜',
    success: 'ì„±ê³µ',
    registerSuccess: 'ê°€ì… ì™„ë£Œ!',
    registerFailed: 'ê°€ì… ì‹¤íŒ¨',
    passwordTooShort: 'ë¹„ë°€ë²ˆí˜¸ëŠ” 6ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤',
    passwordMismatch: 'ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤',
    emailRequired: 'ì´ë©”ì¼ì„ ì…ë ¥í•´ì£¼ì„¸ìš”',
    emailExists: 'ì´ë¯¸ ë“±ë¡ëœ ì´ë©”ì¼ì…ë‹ˆë‹¤',
    tryAgain: 'ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”',
  },
};

export default function RegisterScreen() {
  const { setUser, state } = useApp();
  const [loading, setLoading] = useState(false);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [firstName, setFirstName] = useState('');
  const [showPassword, setShowPassword] = useState(false);
  const [showConfirmPassword, setShowConfirmPassword] = useState(false);

  const t = TRANSLATIONS[state.language] || TRANSLATIONS['zh-TW'];

  const handleRegister = async () => {
    if (!email.trim()) {
      Alert.alert(t.error, t.emailRequired);
      return;
    }

    if (password.length < 6) {
      Alert.alert(t.error, t.passwordTooShort);
      return;
    }

    if (password !== confirmPassword) {
      Alert.alert(t.error, t.passwordMismatch);
      return;
    }

    try {
      setLoading(true);
      const response = await fetch(`${API_BASE_URL}/api/auth/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          email: email.trim().toLowerCase(),
          password,
          firstName: firstName.trim() || undefined,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        if (data.errorCode === 'E1005') {
          Alert.alert(t.error, t.emailExists);
        } else {
          Alert.alert(t.error, data.message || t.registerFailed);
        }
        return;
      }

      if (data.token && data.user) {
        await AsyncStorage.setItem(AUTH_TOKEN_KEY, data.token);
        await AsyncStorage.setItem('@mibu_user', JSON.stringify(data.user));

        setUser({
          id: data.user.id,
          email: data.user.email,
          name: data.user.firstName || data.user.email.split('@')[0],
          firstName: data.user.firstName,
          lastName: data.user.lastName,
          role: data.user.role || 'traveler',
          isApproved: data.user.isApproved,
          provider: 'email',
          providerId: data.user.id,
        }, data.token);

        router.replace('/(tabs)');
      } else {
        Alert.alert(t.error, t.registerFailed);
      }
    } catch (error) {
      console.error('Register error:', error);
      Alert.alert(t.error, t.tryAgain);
    } finally {
      setLoading(false);
    }
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        keyboardShouldPersistTaps="handled"
      >
        <TouchableOpacity
          style={styles.backButton}
          onPress={() => router.back()}
        >
          <Ionicons name="arrow-back" size={24} color={MibuBrand.brown} />
        </TouchableOpacity>

        <View style={styles.header}>
          <Text style={styles.title}>{t.title}</Text>
          <Text style={styles.subtitle}>{t.subtitle}</Text>
        </View>

        <View style={styles.form}>
          <View style={styles.inputContainer}>
            <Ionicons name="mail-outline" size={20} color={MibuBrand.copper} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={t.email}
              value={email}
              onChangeText={setEmail}
              keyboardType="email-address"
              autoCapitalize="none"
              autoComplete="email"
              placeholderTextColor={MibuBrand.tan}
            />
          </View>

          <View style={styles.inputContainer}>
            <Ionicons name="lock-closed-outline" size={20} color={MibuBrand.copper} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={t.password}
              value={password}
              onChangeText={setPassword}
              secureTextEntry={!showPassword}
              autoCapitalize="none"
              placeholderTextColor={MibuBrand.tan}
            />
            <TouchableOpacity onPress={() => setShowPassword(!showPassword)}>
              <Ionicons
                name={showPassword ? 'eye-off-outline' : 'eye-outline'}
                size={20}
                color={MibuBrand.copper}
              />
            </TouchableOpacity>
          </View>

          <View style={styles.inputContainer}>
            <Ionicons name="lock-closed-outline" size={20} color={MibuBrand.copper} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={t.confirmPassword}
              value={confirmPassword}
              onChangeText={setConfirmPassword}
              secureTextEntry={!showConfirmPassword}
              autoCapitalize="none"
              placeholderTextColor={MibuBrand.tan}
            />
            <TouchableOpacity onPress={() => setShowConfirmPassword(!showConfirmPassword)}>
              <Ionicons
                name={showConfirmPassword ? 'eye-off-outline' : 'eye-outline'}
                size={20}
                color={MibuBrand.copper}
              />
            </TouchableOpacity>
          </View>

          <View style={styles.inputContainer}>
            <Ionicons name="person-outline" size={20} color={MibuBrand.copper} style={styles.inputIcon} />
            <TextInput
              style={styles.input}
              placeholder={t.firstName}
              value={firstName}
              onChangeText={setFirstName}
              autoCapitalize="words"
              placeholderTextColor={MibuBrand.tan}
            />
          </View>

          <TouchableOpacity
            style={[styles.registerButton, loading && styles.registerButtonDisabled]}
            onPress={handleRegister}
            disabled={loading}
          >
            {loading ? (
              <ActivityIndicator color="#ffffff" />
            ) : (
              <>
                <Ionicons name="person-add-outline" size={20} color="#ffffff" />
                <Text style={styles.registerButtonText}>{t.register}</Text>
              </>
            )}
          </TouchableOpacity>
        </View>

        <View style={styles.footer}>
          <Text style={styles.footerText}>{t.hasAccount}</Text>
          <TouchableOpacity onPress={() => router.back()}>
            <Text style={styles.loginLink}>{t.login}</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  scrollContent: {
    flexGrow: 1,
    paddingHorizontal: 24,
    paddingTop: 60,
    paddingBottom: 40,
  },
  backButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: MibuBrand.warmWhite,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
    marginBottom: 20,
  },
  header: {
    marginBottom: 40,
  },
  title: {
    fontSize: 32,
    fontWeight: '700',
    color: MibuBrand.brown,
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: MibuBrand.copper,
  },
  form: {
    gap: 16,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 4,
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
  },
  inputIcon: {
    marginRight: 12,
  },
  input: {
    flex: 1,
    fontSize: 16,
    color: MibuBrand.brownDark,
    paddingVertical: 16,
  },
  registerButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 10,
    backgroundColor: MibuBrand.brown,
    paddingVertical: 18,
    borderRadius: 20,
    marginTop: 8,
    shadowColor: MibuBrand.brownDark,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  registerButtonDisabled: {
    opacity: 0.7,
  },
  registerButtonText: {
    fontSize: 18,
    fontWeight: '700',
    color: '#ffffff',
  },
  footer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    gap: 8,
    marginTop: 32,
  },
  footerText: {
    fontSize: 15,
    color: MibuBrand.copper,
  },
  loginLink: {
    fontSize: 15,
    fontWeight: '600',
    color: MibuBrand.brown,
  },
});

=== File: app/sos.tsx ===

import { SOSScreen } from '../src/screens/SOSScreen';

export default SOSScreen;

=== File: app/specialist-dashboard.tsx ===

import { SpecialistDashboardScreen } from '../src/screens/SpecialistDashboardScreen';

export default SpecialistDashboardScreen;

=== File: app/specialist/history.tsx ===

import { SpecialistHistoryScreen } from '../../src/screens/SpecialistHistoryScreen';

export default function SpecialistHistoryPage() {
  return <SpecialistHistoryScreen />;
}

=== File: app/specialist/_layout.tsx ===

import { Stack } from 'expo-router';

export default function SpecialistLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
      }}
    />
  );
}

=== File: app/specialist/profile.tsx ===

import { SpecialistProfileScreen } from '../../src/screens/SpecialistProfileScreen';

export default function SpecialistProfilePage() {
  return <SpecialistProfileScreen />;
}

=== File: app/specialist/tracking.tsx ===

import { SpecialistTrackingScreen } from '../../src/screens/SpecialistTrackingScreen';

export default SpecialistTrackingScreen;

=== File: app/specialist/travelers.tsx ===

import { SpecialistTravelersScreen } from '../../src/screens/SpecialistTravelersScreen';

export default SpecialistTravelersScreen;

=== File: app/(tabs)/collection.tsx ===

import { CollectionScreen } from '../../src/screens/CollectionScreen';

export default CollectionScreen;

=== File: app/(tabs)/gacha/index.tsx ===

import { GachaModuleScreen } from '../../../src/screens/GachaModuleScreen';

export default GachaModuleScreen;

=== File: app/(tabs)/gacha/items.tsx ===

import { ItemsScreen } from '../../../src/screens/ItemsScreen';

export default ItemsScreen;

=== File: app/(tabs)/gacha/_layout.tsx ===

import { Stack } from 'expo-router';
import React from 'react';

export default function GachaLayout() {
  return (
    <Stack
      screenOptions={{
        headerShown: false,
      }}
    >
      <Stack.Screen name="index" />
      <Stack.Screen name="items" options={{ presentation: 'modal' }} />
    </Stack>
  );
}

=== File: app/(tabs)/index.tsx ===

import { HomeScreen } from '../../src/screens/HomeScreen';

export default HomeScreen;

=== File: app/(tabs)/_layout.tsx ===

import { Tabs } from 'expo-router';
import React, { useEffect } from 'react';
import { Platform, View, Text } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

import { HapticTab } from '@/components/HapticTab';
import TabBarBackground from '@/components/ui/TabBarBackground';
import { useApp } from '../../src/context/AppContext';
import { MibuBrand } from '../../constants/Colors';

function TabIconWithBadge({ 
  icon, 
  focused, 
  color, 
  badgeCount 
}: { 
  icon: string; 
  focused: boolean; 
  color: string; 
  badgeCount?: number;
}) {
  return (
    <View style={{ position: 'relative' }}>
      <Ionicons name={(focused ? icon : `${icon}-outline`) as any} size={24} color={color} />
      {badgeCount !== undefined && badgeCount > 0 && (
        <View style={{
          position: 'absolute',
          top: -4,
          right: -8,
          backgroundColor: '#ef4444',
          borderRadius: 10,
          minWidth: 16,
          height: 16,
          alignItems: 'center',
          justifyContent: 'center',
          paddingHorizontal: 4,
        }}>
          <Text style={{ color: '#ffffff', fontSize: 10, fontWeight: '700' }}>
            {badgeCount > 99 ? '99+' : badgeCount}
          </Text>
        </View>
      )}
    </View>
  );
}

export default function TabLayout() {
  const { t, state, refreshUnreadCount } = useApp();
  
  useEffect(() => {
    if (state.isAuthenticated) {
      refreshUnreadCount();
    }
  }, [state.isAuthenticated, refreshUnreadCount]);

  return (
    <Tabs
      screenOptions={{
        tabBarActiveTintColor: MibuBrand.brown,
        tabBarInactiveTintColor: MibuBrand.copper,
        headerShown: false,
        tabBarButton: HapticTab,
        tabBarBackground: TabBarBackground,
        tabBarStyle: Platform.select({
          ios: {
            position: 'absolute',
            backgroundColor: 'rgba(253, 248, 243, 0.98)',
            borderTopWidth: 0,
            height: 88,
            paddingBottom: 24,
            paddingTop: 8,
          },
          default: {
            backgroundColor: MibuBrand.creamLight,
            borderTopWidth: 1,
            borderTopColor: MibuBrand.tanLight,
            height: 64,
            paddingBottom: 8,
            paddingTop: 8,
          },
        }),
        tabBarLabelStyle: {
          fontSize: 11,
          fontWeight: '600',
        },
      }}
    >
      <Tabs.Screen
        name="index"
        options={{
          title: t.navHome,
          tabBarIcon: ({ color, focused }) => (
            <Ionicons name={focused ? 'home' : 'home-outline'} size={24} color={color} />
          ),
        }}
      />
      <Tabs.Screen
        name="gacha"
        options={{
          title: t.navGacha,
          tabBarIcon: ({ color, focused }) => (
            <TabIconWithBadge 
              icon="gift" 
              focused={focused} 
              color={color} 
              badgeCount={state.unreadItemCount} 
            />
          ),
        }}
      />
      <Tabs.Screen
        name="collection"
        options={{
          href: null,
        }}
      />
      <Tabs.Screen
        name="planner"
        options={{
          href: null,
        }}
      />
      <Tabs.Screen
        name="settings"
        options={{
          title: t.navSettings,
          tabBarIcon: ({ color, focused }) => (
            <Ionicons name={focused ? 'settings' : 'settings-outline'} size={24} color={color} />
          ),
        }}
      />
    </Tabs>
  );
}

=== File: app/(tabs)/planner/index.tsx ===

import React, { useState } from 'react';
import { View, StyleSheet, Platform } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { SegmentedControl } from '../../../src/components/ui/SegmentedControl';
import { LocationScreen } from '../../../src/screens/LocationScreen';
import { ItineraryScreen } from '../../../src/screens/ItineraryScreen';
import { ChatScreen } from '../../../src/screens/ChatScreen';
import { useApp } from '../../../src/context/AppContext';

type SubView = 'location' | 'itinerary' | 'chat';

export default function PlannerScreen() {
  const [activeView, setActiveView] = useState<SubView>('location');
  const { t } = useApp();
  const insets = useSafeAreaInsets();

  const segments = [
    { key: 'location', label: t.navLocation || 'å®šä½' },
    { key: 'itinerary', label: t.navItinerary || 'è¡Œç¨‹' },
    { key: 'chat', label: t.navChat || 'èŠå¤©' },
  ];

  const renderContent = () => {
    switch (activeView) {
      case 'location':
        return <LocationScreen />;
      case 'itinerary':
        return <ItineraryScreen />;
      case 'chat':
        return <ChatScreen />;
      default:
        return <LocationScreen />;
    }
  };

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      <View style={styles.header}>
        <SegmentedControl
          segments={segments}
          selectedKey={activeView}
          onSelect={(key) => setActiveView(key as SubView)}
        />
      </View>
      <View style={styles.content}>
        {renderContent()}
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    backgroundColor: '#ffffff',
    paddingBottom: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
  },
  content: {
    flex: 1,
  },
});

=== File: app/(tabs)/planner/_layout.tsx ===

import { Stack } from 'expo-router';
import React from 'react';

export default function PlannerLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      <Stack.Screen name="index" />
    </Stack>
  );
}

=== File: app/(tabs)/settings.tsx ===

import { SettingsScreen } from '../../src/screens/SettingsScreen';

export default SettingsScreen;

=== File: components/Collapsible.tsx ===

import { PropsWithChildren, useState } from 'react';
import { StyleSheet, TouchableOpacity } from 'react-native';

import { ThemedText } from '@/components/ThemedText';
import { ThemedView } from '@/components/ThemedView';
import { IconSymbol } from '@/components/ui/IconSymbol';
import { Colors } from '@/constants/Colors';
import { useColorScheme } from '@/hooks/useColorScheme';

export function Collapsible({ children, title }: PropsWithChildren & { title: string }) {
  const [isOpen, setIsOpen] = useState(false);
  const theme = useColorScheme() ?? 'light';

  return (
    <ThemedView>
      <TouchableOpacity
        style={styles.heading}
        onPress={() => setIsOpen((value) => !value)}
        activeOpacity={0.8}>
        <IconSymbol
          name="chevron.right"
          size={18}
          weight="medium"
          color={theme === 'light' ? Colors.light.icon : Colors.dark.icon}
          style={{ transform: [{ rotate: isOpen ? '90deg' : '0deg' }] }}
        />

        <ThemedText type="defaultSemiBold">{title}</ThemedText>
      </TouchableOpacity>
      {isOpen && <ThemedView style={styles.content}>{children}</ThemedView>}
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  heading: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  content: {
    marginTop: 6,
    marginLeft: 24,
  },
});

=== File: components/ExternalLink.tsx ===

import { Href, Link } from 'expo-router';
import { openBrowserAsync } from 'expo-web-browser';
import { type ComponentProps } from 'react';
import { Platform } from 'react-native';

type Props = Omit<ComponentProps<typeof Link>, 'href'> & { href: Href & string };

export function ExternalLink({ href, ...rest }: Props) {
  return (
    <Link
      target="_blank"
      {...rest}
      href={href}
      onPress={async (event) => {
        if (Platform.OS !== 'web') {
          // Prevent the default behavior of linking to the default browser on native.
          event.preventDefault();
          // Open the link in an in-app browser.
          await openBrowserAsync(href);
        }
      }}
    />
  );
}

=== File: components/HapticTab.tsx ===

import { BottomTabBarButtonProps } from '@react-navigation/bottom-tabs';
import { PlatformPressable } from '@react-navigation/elements';
import * as Haptics from 'expo-haptics';

export function HapticTab(props: BottomTabBarButtonProps) {
  return (
    <PlatformPressable
      {...props}
      onPressIn={(ev) => {
        if (process.env.EXPO_OS === 'ios') {
          // Add a soft haptic feedback when pressing down on the tabs.
          Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Light);
        }
        props.onPressIn?.(ev);
      }}
    />
  );
}

=== File: components/HelloWave.tsx ===

import { useEffect } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  useAnimatedStyle,
  useSharedValue,
  withRepeat,
  withSequence,
  withTiming,
} from 'react-native-reanimated';

import { ThemedText } from '@/components/ThemedText';

export function HelloWave() {
  const rotationAnimation = useSharedValue(0);

  useEffect(() => {
    rotationAnimation.value = withRepeat(
      withSequence(withTiming(25, { duration: 150 }), withTiming(0, { duration: 150 })),
      4 // Run the animation 4 times
    );
  }, [rotationAnimation]);

  const animatedStyle = useAnimatedStyle(() => ({
    transform: [{ rotate: `${rotationAnimation.value}deg` }],
  }));

  return (
    <Animated.View style={animatedStyle}>
      <ThemedText style={styles.text}>ğŸ‘‹</ThemedText>
    </Animated.View>
  );
}

const styles = StyleSheet.create({
  text: {
    fontSize: 28,
    lineHeight: 32,
    marginTop: -6,
  },
});

=== File: components/ParallaxScrollView.tsx ===

import type { PropsWithChildren, ReactElement } from 'react';
import { StyleSheet } from 'react-native';
import Animated, {
  interpolate,
  useAnimatedRef,
  useAnimatedStyle,
  useScrollViewOffset,
} from 'react-native-reanimated';

import { ThemedView } from '@/components/ThemedView';
import { useBottomTabOverflow } from '@/components/ui/TabBarBackground';
import { useColorScheme } from '@/hooks/useColorScheme';

const HEADER_HEIGHT = 250;

type Props = PropsWithChildren<{
  headerImage: ReactElement;
  headerBackgroundColor: { dark: string; light: string };
}>;

export default function ParallaxScrollView({
  children,
  headerImage,
  headerBackgroundColor,
}: Props) {
  const colorScheme = useColorScheme() ?? 'light';
  const scrollRef = useAnimatedRef<Animated.ScrollView>();
  const scrollOffset = useScrollViewOffset(scrollRef);
  const bottom = useBottomTabOverflow();
  const headerAnimatedStyle = useAnimatedStyle(() => {
    return {
      transform: [
        {
          translateY: interpolate(
            scrollOffset.value,
            [-HEADER_HEIGHT, 0, HEADER_HEIGHT],
            [-HEADER_HEIGHT / 2, 0, HEADER_HEIGHT * 0.75]
          ),
        },
        {
          scale: interpolate(scrollOffset.value, [-HEADER_HEIGHT, 0, HEADER_HEIGHT], [2, 1, 1]),
        },
      ],
    };
  });

  return (
    <ThemedView style={styles.container}>
      <Animated.ScrollView
        ref={scrollRef}
        scrollEventThrottle={16}
        scrollIndicatorInsets={{ bottom }}
        contentContainerStyle={{ paddingBottom: bottom }}>
        <Animated.View
          style={[
            styles.header,
            { backgroundColor: headerBackgroundColor[colorScheme] },
            headerAnimatedStyle,
          ]}>
          {headerImage}
        </Animated.View>
        <ThemedView style={styles.content}>{children}</ThemedView>
      </Animated.ScrollView>
    </ThemedView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    height: HEADER_HEIGHT,
    overflow: 'hidden',
  },
  content: {
    flex: 1,
    padding: 32,
    gap: 16,
    overflow: 'hidden',
  },
});

=== File: components/ThemedText.tsx ===

import { StyleSheet, Text, type TextProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedTextProps = TextProps & {
  lightColor?: string;
  darkColor?: string;
  type?: 'default' | 'title' | 'defaultSemiBold' | 'subtitle' | 'link';
};

export function ThemedText({
  style,
  lightColor,
  darkColor,
  type = 'default',
  ...rest
}: ThemedTextProps) {
  const color = useThemeColor({ light: lightColor, dark: darkColor }, 'text');

  return (
    <Text
      style={[
        { color },
        type === 'default' ? styles.default : undefined,
        type === 'title' ? styles.title : undefined,
        type === 'defaultSemiBold' ? styles.defaultSemiBold : undefined,
        type === 'subtitle' ? styles.subtitle : undefined,
        type === 'link' ? styles.link : undefined,
        style,
      ]}
      {...rest}
    />
  );
}

const styles = StyleSheet.create({
  default: {
    fontSize: 16,
    lineHeight: 24,
  },
  defaultSemiBold: {
    fontSize: 16,
    lineHeight: 24,
    fontWeight: '600',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    lineHeight: 32,
  },
  subtitle: {
    fontSize: 20,
    fontWeight: 'bold',
  },
  link: {
    lineHeight: 30,
    fontSize: 16,
    color: '#0a7ea4',
  },
});

=== File: components/ThemedView.tsx ===

import { View, type ViewProps } from 'react-native';

import { useThemeColor } from '@/hooks/useThemeColor';

export type ThemedViewProps = ViewProps & {
  lightColor?: string;
  darkColor?: string;
};

export function ThemedView({ style, lightColor, darkColor, ...otherProps }: ThemedViewProps) {
  const backgroundColor = useThemeColor({ light: lightColor, dark: darkColor }, 'background');

  return <View style={[{ backgroundColor }, style]} {...otherProps} />;
}

=== File: components/ui/IconSymbol.ios.tsx ===

import { SymbolView, SymbolViewProps, SymbolWeight } from 'expo-symbols';
import { StyleProp, ViewStyle } from 'react-native';

export function IconSymbol({
  name,
  size = 24,
  color,
  style,
  weight = 'regular',
}: {
  name: SymbolViewProps['name'];
  size?: number;
  color: string;
  style?: StyleProp<ViewStyle>;
  weight?: SymbolWeight;
}) {
  return (
    <SymbolView
      weight={weight}
      tintColor={color}
      resizeMode="scaleAspectFit"
      name={name}
      style={[
        {
          width: size,
          height: size,
        },
        style,
      ]}
    />
  );
}

=== File: components/ui/IconSymbol.tsx ===

// Fallback for using MaterialIcons on Android and web.

import MaterialIcons from '@expo/vector-icons/MaterialIcons';
import { SymbolWeight, SymbolViewProps } from 'expo-symbols';
import { ComponentProps } from 'react';
import { OpaqueColorValue, type StyleProp, type TextStyle } from 'react-native';

type IconMapping = Record<SymbolViewProps['name'], ComponentProps<typeof MaterialIcons>['name']>;
type IconSymbolName = keyof typeof MAPPING;

/**
 * Add your SF Symbols to Material Icons mappings here.
 * - see Material Icons in the [Icons Directory](https://icons.expo.fyi).
 * - see SF Symbols in the [SF Symbols](https://developer.apple.com/sf-symbols/) app.
 */
const MAPPING = {
  'house.fill': 'home',
  'paperplane.fill': 'send',
  'chevron.left.forwardslash.chevron.right': 'code',
  'chevron.right': 'chevron-right',
} as IconMapping;

/**
 * An icon component that uses native SF Symbols on iOS, and Material Icons on Android and web.
 * This ensures a consistent look across platforms, and optimal resource usage.
 * Icon `name`s are based on SF Symbols and require manual mapping to Material Icons.
 */
export function IconSymbol({
  name,
  size = 24,
  color,
  style,
}: {
  name: IconSymbolName;
  size?: number;
  color: string | OpaqueColorValue;
  style?: StyleProp<TextStyle>;
  weight?: SymbolWeight;
}) {
  return <MaterialIcons color={color} size={size} name={MAPPING[name]} style={style} />;
}

=== File: components/ui/TabBarBackground.ios.tsx ===

import { useBottomTabBarHeight } from '@react-navigation/bottom-tabs';
import { BlurView } from 'expo-blur';
import { StyleSheet } from 'react-native';

export default function BlurTabBarBackground() {
  return (
    <BlurView
      // System chrome material automatically adapts to the system's theme
      // and matches the native tab bar appearance on iOS.
      tint="systemChromeMaterial"
      intensity={100}
      style={StyleSheet.absoluteFill}
    />
  );
}

export function useBottomTabOverflow() {
  return useBottomTabBarHeight();
}

=== File: components/ui/TabBarBackground.tsx ===

// This is a shim for web and Android where the tab bar is generally opaque.
export default undefined;

export function useBottomTabOverflow() {
  return 0;
}

=== File: src/components/LoadingAdScreen.tsx ===

import React, { useEffect, useState } from 'react';
import { View, Text, Modal, Dimensions, Image, TouchableOpacity, SafeAreaView } from 'react-native';
import Animated, {
  useSharedValue,
  useAnimatedStyle,
  withRepeat,
  withTiming,
  withSequence,
  withDelay,
  Easing,
} from 'react-native-reanimated';
import { Ionicons } from '@expo/vector-icons';
import { MibuBrand } from '../../constants/Colors';

const { width: SCREEN_WIDTH } = Dimensions.get('window');
const AD_WIDTH = SCREEN_WIDTH - 48;
const AD_HEIGHT = 120;

interface LoadingAdScreenProps {
  visible: boolean;
  onComplete: () => void;
  isApiComplete: boolean;
  translations: {
    generatingItinerary: string;
    sponsorAd: string;
    pleaseWait: string;
    almostReady: string;
  };
}

const FORCED_WAIT_SECONDS = 5;

const PawPrint = ({ delay, x, y }: { delay: number; x: number; y: number }) => {
  const opacity = useSharedValue(0.3);
  const scale = useSharedValue(0.8);

  useEffect(() => {
    opacity.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(1, { duration: 600, easing: Easing.inOut(Easing.ease) }),
          withTiming(0.3, { duration: 600, easing: Easing.inOut(Easing.ease) })
        ),
        -1,
        true
      )
    );
    scale.value = withDelay(
      delay,
      withRepeat(
        withSequence(
          withTiming(1.1, { duration: 600, easing: Easing.inOut(Easing.ease) }),
          withTiming(0.8, { duration: 600, easing: Easing.inOut(Easing.ease) })
        ),
        -1,
        true
      )
    );
  }, []);

  const animatedStyle = useAnimatedStyle(() => ({
    opacity: opacity.value,
    transform: [{ scale: scale.value }],
  }));

  return (
    <Animated.View
      style={[
        {
          position: 'absolute',
          left: x,
          top: y,
        },
        animatedStyle,
      ]}
    >
      <View style={{ alignItems: 'center' }}>
        <View style={{ flexDirection: 'row', gap: 3, marginBottom: 2 }}>
          <View style={{ width: 6, height: 6, borderRadius: 3, backgroundColor: '#6B8DD6' }} />
          <View style={{ width: 6, height: 6, borderRadius: 3, backgroundColor: '#6B8DD6' }} />
        </View>
        <View style={{ flexDirection: 'row', gap: 2 }}>
          <View style={{ width: 5, height: 5, borderRadius: 2.5, backgroundColor: '#6B8DD6' }} />
          <View style={{ width: 10, height: 12, borderRadius: 5, backgroundColor: '#6B8DD6' }} />
          <View style={{ width: 5, height: 5, borderRadius: 2.5, backgroundColor: '#6B8DD6' }} />
        </View>
      </View>
    </Animated.View>
  );
};

export function LoadingAdScreen({ visible, onComplete, isApiComplete, translations }: LoadingAdScreenProps) {
  const [countdown, setCountdown] = useState(FORCED_WAIT_SECONDS);
  const [isTimerComplete, setIsTimerComplete] = useState(false);

  useEffect(() => {
    if (visible) {
      setCountdown(FORCED_WAIT_SECONDS);
      setIsTimerComplete(false);
    }
  }, [visible]);

  useEffect(() => {
    if (!visible) return;

    const timer = setInterval(() => {
      setCountdown((prev) => {
        if (prev <= 1) {
          clearInterval(timer);
          setIsTimerComplete(true);
          return 0;
        }
        return prev - 1;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, [visible]);

  useEffect(() => {
    if (isTimerComplete && isApiComplete) {
      onComplete();
    }
  }, [isTimerComplete, isApiComplete, onComplete]);

  const statusText = isApiComplete ? translations.almostReady : translations.pleaseWait;

  return (
    <Modal visible={visible} animationType="fade" transparent={false}>
      <SafeAreaView style={{ flex: 1, backgroundColor: '#F5F5F5' }}>
        <View
          style={{
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'space-between',
            paddingHorizontal: 16,
            paddingVertical: 12,
            backgroundColor: '#FFFFFF',
            borderBottomWidth: 1,
            borderBottomColor: '#E8E8E8',
          }}
        >
          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 8 }}>
            <TouchableOpacity style={{ padding: 4 }}>
              <Ionicons name="chevron-back" size={24} color="#666666" />
            </TouchableOpacity>
            <Image
              source={require('../../assets/images/icon.png')}
              style={{ width: 36, height: 36 }}
              resizeMode="contain"
            />
            <Text style={{ fontSize: 18, fontWeight: '700', color: '#333333' }}>MIBU</Text>
          </View>
          <View style={{ flexDirection: 'row', alignItems: 'center', gap: 16 }}>
            <Ionicons name="globe-outline" size={22} color="#666666" />
            <View
              style={{
                width: 32,
                height: 32,
                borderRadius: 16,
                backgroundColor: '#E0E0E0',
                alignItems: 'center',
                justifyContent: 'center',
              }}
            >
              <Text style={{ fontSize: 12, fontWeight: '600', color: '#666666' }}>MI</Text>
            </View>
            <Ionicons name="log-out-outline" size={22} color="#666666" />
          </View>
        </View>

        <View
          style={{
            flex: 1,
            alignItems: 'center',
            justifyContent: 'center',
            paddingHorizontal: 24,
          }}
        >
          <View
            style={{
              width: 120,
              height: 80,
              position: 'relative',
              marginBottom: 40,
            }}
          >
            <PawPrint delay={0} x={0} y={30} />
            <PawPrint delay={200} x={40} y={0} />
            <PawPrint delay={400} x={80} y={30} />
            <PawPrint delay={600} x={20} y={55} />
            <PawPrint delay={800} x={60} y={55} />
          </View>

          <Text
            style={{
              fontSize: 24,
              fontWeight: '800',
              color: '#333333',
              textAlign: 'center',
              marginBottom: 12,
            }}
          >
            {translations.generatingItinerary}
          </Text>

          <Text
            style={{
              fontSize: 15,
              color: '#888888',
              textAlign: 'center',
              marginBottom: 20,
            }}
          >
            {statusText}
          </Text>
        </View>

        <View
          style={{
            paddingHorizontal: 24,
            paddingBottom: 40,
          }}
        >
          <View
            style={{
              width: '100%',
              height: AD_HEIGHT,
              backgroundColor: '#FAFAFA',
              borderRadius: 12,
              borderWidth: 2,
              borderColor: '#D0D0D0',
              borderStyle: 'dashed',
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <Text
              style={{
                fontSize: 13,
                fontWeight: '600',
                color: '#B0B0B0',
                letterSpacing: 1,
                marginBottom: 4,
              }}
            >
              ADVERTISEMENT
            </Text>
            <Text
              style={{
                fontSize: 14,
                color: '#C0C0C0',
              }}
            >
              Ad Space
            </Text>
          </View>
        </View>
      </SafeAreaView>
    </Modal>
  );
}

=== File: src/components/MerchantRegistrationForm.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MerchantApplyParams } from '../types';

interface MerchantRegistrationFormProps {
  onSuccess: () => void;
  onCancel: () => void;
}

const BUSINESS_CATEGORIES = [
  { value: 'restaurant', labelZh: 'é¤é£²', labelEn: 'Restaurant' },
  { value: 'retail', labelZh: 'é›¶å”®', labelEn: 'Retail' },
  { value: 'hotel', labelZh: 'ä½å®¿', labelEn: 'Hotel' },
  { value: 'entertainment', labelZh: 'å¨›æ¨‚', labelEn: 'Entertainment' },
  { value: 'service', labelZh: 'æœå‹™', labelEn: 'Service' },
  { value: 'other', labelZh: 'å…¶ä»–', labelEn: 'Other' },
];

export function MerchantRegistrationForm({ onSuccess, onCancel }: MerchantRegistrationFormProps) {
  const { state } = useApp();
  const isZh = state.language === 'zh-TW';

  const [loading, setLoading] = useState(false);
  const [formData, setFormData] = useState<MerchantApplyParams>({
    ownerName: '',
    businessName: '',
    taxId: '',
    businessCategory: 'restaurant',
    address: '',
    phone: '',
    mobile: '',
    email: state.user?.email || '',
  });

  const translations = {
    title: isZh ? 'å•†å®¶å…¥é§ç”³è«‹' : 'Merchant Application',
    subtitle: isZh ? 'å¡«å¯«ä»¥ä¸‹è³‡æ–™ï¼Œæˆ‘å€‘å°‡åœ¨ 1-3 å€‹å·¥ä½œå¤©å…§å¯©æ ¸' : 'Fill in the details below. Review takes 1-3 business days.',
    ownerName: isZh ? 'è² è²¬äººå§“å *' : 'Owner Name *',
    businessName: isZh ? 'å•†å®¶åç¨± *' : 'Business Name *',
    taxId: isZh ? 'çµ±ä¸€ç·¨è™Ÿ' : 'Tax ID',
    businessCategory: isZh ? 'å•†å®¶é¡å‹ *' : 'Business Category *',
    address: isZh ? 'å•†å®¶åœ°å€ *' : 'Business Address *',
    phone: isZh ? 'å¸‚è©±' : 'Phone',
    mobile: isZh ? 'æ‰‹æ©Ÿè™Ÿç¢¼ *' : 'Mobile *',
    email: isZh ? 'è¯çµ¡ä¿¡ç®± *' : 'Contact Email *',
    submit: isZh ? 'æäº¤ç”³è«‹' : 'Submit Application',
    cancel: isZh ? 'å–æ¶ˆ' : 'Cancel',
    requiredFields: isZh ? 'è«‹å¡«å¯«æ‰€æœ‰å¿…å¡«æ¬„ä½' : 'Please fill all required fields',
    submitSuccess: isZh ? 'ç”³è«‹å·²æäº¤ï¼Œè«‹ç­‰å¾…å¯©æ ¸' : 'Application submitted. Awaiting review.',
    submitFailed: isZh ? 'æäº¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Submission failed. Please try again.',
  };

  const handleSubmit = async () => {
    if (!formData.ownerName.trim() || !formData.businessName.trim() || 
        !formData.businessCategory || !formData.address.trim() ||
        !formData.mobile.trim() || !formData.email.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', translations.requiredFields);
      return;
    }

    setLoading(true);
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      await apiService.applyMerchant(token, formData);
      Alert.alert(
        isZh ? 'æˆåŠŸ' : 'Success',
        translations.submitSuccess,
        [{ text: 'OK', onPress: onSuccess }]
      );
    } catch (error) {
      console.error('Apply failed:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', translations.submitFailed);
    } finally {
      setLoading(false);
    }
  };

  const updateField = (field: keyof MerchantApplyParams, value: string) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
    >
      <View style={styles.header}>
        <TouchableOpacity onPress={onCancel} style={styles.closeButton}>
          <Ionicons name="close" size={24} color="#64748b" />
        </TouchableOpacity>
        <View style={styles.headerIcon}>
          <Ionicons name="storefront" size={32} color="#6366f1" />
        </View>
        <Text style={styles.title}>{translations.title}</Text>
        <Text style={styles.subtitle}>{translations.subtitle}</Text>
      </View>

      <ScrollView style={styles.form} showsVerticalScrollIndicator={false}>
        <View style={styles.section}>
          <Text style={styles.label}>{translations.ownerName}</Text>
          <TextInput
            style={styles.input}
            value={formData.ownerName}
            onChangeText={text => updateField('ownerName', text)}
            placeholder={isZh ? 'è«‹è¼¸å…¥è² è²¬äººå§“å' : 'Enter owner name'}
            placeholderTextColor="#94a3b8"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>{translations.businessName}</Text>
          <TextInput
            style={styles.input}
            value={formData.businessName}
            onChangeText={text => updateField('businessName', text)}
            placeholder={isZh ? 'è«‹è¼¸å…¥å•†å®¶åç¨±' : 'Enter business name'}
            placeholderTextColor="#94a3b8"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>{translations.businessCategory}</Text>
          <View style={styles.categoryGrid}>
            {BUSINESS_CATEGORIES.map(cat => (
              <TouchableOpacity
                key={cat.value}
                style={[
                  styles.categoryOption,
                  formData.businessCategory === cat.value && styles.categoryOptionActive,
                ]}
                onPress={() => updateField('businessCategory', cat.value)}
              >
                <Text style={[
                  styles.categoryText,
                  formData.businessCategory === cat.value && styles.categoryTextActive,
                ]}>
                  {isZh ? cat.labelZh : cat.labelEn}
                </Text>
              </TouchableOpacity>
            ))}
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>{translations.taxId}</Text>
          <TextInput
            style={styles.input}
            value={formData.taxId}
            onChangeText={text => updateField('taxId', text)}
            placeholder={isZh ? 'é¸å¡«' : 'Optional'}
            placeholderTextColor="#94a3b8"
            keyboardType="number-pad"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>{translations.address}</Text>
          <TextInput
            style={[styles.input, styles.textArea]}
            value={formData.address}
            onChangeText={text => updateField('address', text)}
            placeholder={isZh ? 'è«‹è¼¸å…¥å•†å®¶åœ°å€' : 'Enter business address'}
            placeholderTextColor="#94a3b8"
            multiline
          />
        </View>

        <View style={styles.row}>
          <View style={styles.halfSection}>
            <Text style={styles.label}>{translations.phone}</Text>
            <TextInput
              style={styles.input}
              value={formData.phone}
              onChangeText={text => updateField('phone', text)}
              placeholder="02-1234-5678"
              placeholderTextColor="#94a3b8"
              keyboardType="phone-pad"
            />
          </View>
          <View style={styles.halfSection}>
            <Text style={styles.label}>{translations.mobile}</Text>
            <TextInput
              style={styles.input}
              value={formData.mobile}
              onChangeText={text => updateField('mobile', text)}
              placeholder="0912-345-678"
              placeholderTextColor="#94a3b8"
              keyboardType="phone-pad"
            />
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.label}>{translations.email}</Text>
          <TextInput
            style={styles.input}
            value={formData.email}
            onChangeText={text => updateField('email', text)}
            placeholder="contact@example.com"
            placeholderTextColor="#94a3b8"
            keyboardType="email-address"
            autoCapitalize="none"
          />
        </View>

        <View style={styles.buttons}>
          <TouchableOpacity style={styles.cancelButton} onPress={onCancel}>
            <Text style={styles.cancelButtonText}>{translations.cancel}</Text>
          </TouchableOpacity>
          <TouchableOpacity
            style={[styles.submitButton, loading && styles.submitButtonDisabled]}
            onPress={handleSubmit}
            disabled={loading}
          >
            {loading ? (
              <ActivityIndicator color="#ffffff" size="small" />
            ) : (
              <>
                <Ionicons name="paper-plane" size={18} color="#ffffff" />
                <Text style={styles.submitButtonText}>{translations.submit}</Text>
              </>
            )}
          </TouchableOpacity>
        </View>

        <View style={{ height: 40 }} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#ffffff',
  },
  header: {
    alignItems: 'center',
    paddingTop: 20,
    paddingBottom: 24,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
  },
  closeButton: {
    position: 'absolute',
    right: 16,
    top: 16,
    padding: 8,
  },
  headerIcon: {
    width: 64,
    height: 64,
    backgroundColor: '#eef2ff',
    borderRadius: 32,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 14,
    color: '#64748b',
    textAlign: 'center',
    paddingHorizontal: 32,
  },
  form: {
    flex: 1,
    padding: 20,
  },
  section: {
    marginBottom: 20,
  },
  label: {
    fontSize: 14,
    fontWeight: '600',
    color: '#334155',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f8fafc',
    borderRadius: 12,
    padding: 14,
    fontSize: 16,
    color: '#1e293b',
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  categoryGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  categoryOption: {
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    backgroundColor: '#f8fafc',
  },
  categoryOptionActive: {
    backgroundColor: '#eef2ff',
    borderColor: '#6366f1',
  },
  categoryText: {
    fontSize: 14,
    color: '#64748b',
  },
  categoryTextActive: {
    color: '#6366f1',
    fontWeight: '600',
  },
  row: {
    flexDirection: 'row',
    gap: 12,
  },
  halfSection: {
    flex: 1,
    marginBottom: 20,
  },
  buttons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 20,
  },
  cancelButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#f1f5f9',
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#64748b',
  },
  submitButton: {
    flex: 2,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#6366f1',
  },
  submitButtonDisabled: {
    opacity: 0.7,
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
});

=== File: src/components/ModuleNav.tsx ===

import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { Language } from '../types';

export type GachaSubView = 'gacha' | 'collection' | 'itembox';

interface GachaTopNavProps {
  currentTab: GachaSubView;
  onChange: (tab: GachaSubView) => void;
  language: Language;
  hasNewCollection?: boolean;
  hasNewItems?: boolean;
}

const TAB_LABELS: Record<GachaSubView, Record<Language, string>> = {
  gacha: {
    'zh-TW': 'æ‰­è›‹',
    'en': 'Gacha',
    'ja': 'ã‚¬ãƒãƒ£',
    'ko': 'ê°€ì± ',
  },
  collection: {
    'zh-TW': 'åœ–é‘‘',
    'en': 'Collection',
    'ja': 'å›³é‘‘',
    'ko': 'ë„ê°',
  },
  itembox: {
    'zh-TW': 'é“å…·ç®±',
    'en': 'Item Box',
    'ja': 'ã‚¢ã‚¤ãƒ†ãƒ ',
    'ko': 'ì•„ì´í…œ',
  },
};

export function GachaTopNav({
  currentTab,
  onChange,
  language,
  hasNewCollection = false,
  hasNewItems = false,
}: GachaTopNavProps) {
  const tabs: { key: GachaSubView; hasNew: boolean }[] = [
    { key: 'gacha', hasNew: false },
    { key: 'collection', hasNew: hasNewCollection },
  ];

  return (
    <View
      style={{
        flexDirection: 'row',
        backgroundColor: '#ffffff',
        paddingHorizontal: 16,
        paddingTop: 8,
        paddingBottom: 4,
        borderBottomWidth: 1,
        borderBottomColor: '#f1f5f9',
      }}
    >
      {tabs.map(({ key, hasNew }) => {
        const isActive = currentTab === key;
        const label = TAB_LABELS[key][language] || TAB_LABELS[key]['zh-TW'];

        return (
          <TouchableOpacity
            key={key}
            onPress={() => onChange(key)}
            style={{
              flex: 1,
              alignItems: 'center',
              paddingVertical: 12,
              position: 'relative',
            }}
          >
            <View style={{ flexDirection: 'row', alignItems: 'center' }}>
              <Text
                style={{
                  fontSize: 16,
                  fontWeight: isActive ? '700' : '500',
                  color: isActive ? '#6366f1' : '#64748b',
                }}
              >
                {label}
              </Text>
              {hasNew && (
                <View
                  style={{
                    width: 8,
                    height: 8,
                    borderRadius: 4,
                    backgroundColor: '#ef4444',
                    marginLeft: 4,
                  }}
                />
              )}
            </View>
            {isActive && (
              <View
                style={{
                  position: 'absolute',
                  bottom: 0,
                  left: '25%',
                  right: '25%',
                  height: 3,
                  backgroundColor: '#6366f1',
                  borderRadius: 2,
                }}
              />
            )}
          </TouchableOpacity>
        );
      })}
    </View>
  );
}

=== File: src/components/RoleSwitcher.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Modal,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { UserRole } from '../types';

interface RoleSwitcherProps {
  compact?: boolean;
}

const ROLE_CONFIG: Record<UserRole, { label: { zh: string; en: string }; color: string; icon: string; route: string }> = {
  traveler: { label: { zh: 'æ—…å®¢', en: 'Traveler' }, color: '#6366f1', icon: 'airplane-outline', route: '/(tabs)' },
  merchant: { label: { zh: 'å•†å®¶ç«¯', en: 'Merchant' }, color: '#10b981', icon: 'storefront-outline', route: '/merchant-dashboard' },
  specialist: { label: { zh: 'å°ˆå“¡ç«¯', en: 'Specialist' }, color: '#a855f7', icon: 'shield-checkmark-outline', route: '/specialist-dashboard' },
  admin: { label: { zh: 'ç®¡ç†ç«¯', en: 'Admin' }, color: '#f59e0b', icon: 'settings-outline', route: '/admin-dashboard' },
};

export function RoleSwitcher({ compact = false }: RoleSwitcherProps) {
  const { state, switchRole } = useApp();
  const router = useRouter();
  const [showMenu, setShowMenu] = useState(false);
  const [switching, setSwitching] = useState(false);

  const user = state.user;
  if (!user?.isSuperAdmin || !user?.accessibleRoles || user.accessibleRoles.length <= 1) {
    return null;
  }

  const isZh = state.language === 'zh-TW';
  const currentRole = (user.activeRole || user.role || 'traveler') as UserRole;
  const currentConfig = ROLE_CONFIG[currentRole];

  const handleSwitchRole = async (role: UserRole) => {
    if (role === currentRole) {
      setShowMenu(false);
      return;
    }

    setSwitching(true);
    const success = await switchRole(role);
    setSwitching(false);
    setShowMenu(false);

    if (success) {
      const targetRoute = ROLE_CONFIG[role].route;
      router.replace(targetRoute as any);
    }
  };

  const accessibleRoles = user.accessibleRoles.filter(r => 
    ['traveler', 'merchant', 'specialist', 'admin'].includes(r)
  ) as UserRole[];

  if (compact) {
    return (
      <>
        <TouchableOpacity
          style={[styles.compactButton, { backgroundColor: currentConfig.color + '20' }]}
          onPress={() => setShowMenu(true)}
        >
          <Ionicons name={currentConfig.icon as any} size={18} color={currentConfig.color} />
          <Ionicons name="chevron-down" size={14} color={currentConfig.color} />
        </TouchableOpacity>

        <Modal
          visible={showMenu}
          transparent
          animationType="fade"
          onRequestClose={() => setShowMenu(false)}
        >
          <TouchableOpacity
            style={styles.modalOverlay}
            activeOpacity={1}
            onPress={() => setShowMenu(false)}
          >
            <View style={styles.menuContainer}>
              <Text style={styles.menuTitle}>
                {isZh ? 'åˆ‡æ›èº«ä»½' : 'Switch Role'}
              </Text>
              {switching ? (
                <ActivityIndicator size="small" color="#6366f1" style={styles.loader} />
              ) : (
                accessibleRoles.map((role) => {
                  const config = ROLE_CONFIG[role];
                  const isActive = role === currentRole;
                  return (
                    <TouchableOpacity
                      key={role}
                      style={[
                        styles.menuItem,
                        isActive && { backgroundColor: config.color + '15' },
                      ]}
                      onPress={() => handleSwitchRole(role)}
                    >
                      <Ionicons
                        name={config.icon as any}
                        size={20}
                        color={isActive ? config.color : '#64748b'}
                      />
                      <Text
                        style={[
                          styles.menuItemText,
                          isActive && { color: config.color, fontWeight: '700' },
                        ]}
                      >
                        {isZh ? config.label.zh : config.label.en}
                      </Text>
                      {isActive && (
                        <Ionicons name="checkmark" size={18} color={config.color} />
                      )}
                    </TouchableOpacity>
                  );
                })
              )}
            </View>
          </TouchableOpacity>
        </Modal>
      </>
    );
  }

  return (
    <View style={styles.container}>
      <TouchableOpacity
        style={[styles.button, { borderColor: currentConfig.color }]}
        onPress={() => setShowMenu(!showMenu)}
      >
        <Ionicons name={currentConfig.icon as any} size={20} color={currentConfig.color} />
        <Text style={[styles.buttonText, { color: currentConfig.color }]}>
          {isZh ? currentConfig.label.zh : currentConfig.label.en}
        </Text>
        <Ionicons
          name={showMenu ? 'chevron-up' : 'chevron-down'}
          size={16}
          color={currentConfig.color}
        />
      </TouchableOpacity>

      {showMenu && (
        <View style={styles.dropdown}>
          {switching ? (
            <ActivityIndicator size="small" color="#6366f1" style={styles.loader} />
          ) : (
            accessibleRoles.map((role) => {
              const config = ROLE_CONFIG[role];
              const isActive = role === currentRole;
              return (
                <TouchableOpacity
                  key={role}
                  style={[
                    styles.dropdownItem,
                    isActive && { backgroundColor: config.color + '15' },
                  ]}
                  onPress={() => handleSwitchRole(role)}
                >
                  <Ionicons
                    name={config.icon as any}
                    size={18}
                    color={isActive ? config.color : '#64748b'}
                  />
                  <Text
                    style={[
                      styles.dropdownText,
                      isActive && { color: config.color, fontWeight: '700' },
                    ]}
                  >
                    {isZh ? config.label.zh : config.label.en}
                  </Text>
                </TouchableOpacity>
              );
            })
          )}
        </View>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    position: 'relative',
    zIndex: 100,
  },
  button: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingVertical: 8,
    paddingHorizontal: 12,
    borderRadius: 20,
    borderWidth: 2,
    backgroundColor: '#ffffff',
  },
  buttonText: {
    fontSize: 14,
    fontWeight: '600',
  },
  dropdown: {
    position: 'absolute',
    top: 44,
    right: 0,
    backgroundColor: '#ffffff',
    borderRadius: 12,
    paddingVertical: 8,
    minWidth: 160,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.15,
    shadowRadius: 12,
    elevation: 8,
  },
  dropdownItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
    paddingVertical: 12,
    paddingHorizontal: 16,
  },
  dropdownText: {
    fontSize: 15,
    color: '#334155',
  },
  compactButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
    paddingVertical: 6,
    paddingHorizontal: 10,
    borderRadius: 16,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'center',
    alignItems: 'center',
  },
  menuContainer: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    paddingVertical: 16,
    paddingHorizontal: 8,
    minWidth: 200,
    maxWidth: 280,
  },
  menuTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    textAlign: 'center',
    marginBottom: 12,
    paddingHorizontal: 16,
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    paddingVertical: 14,
    paddingHorizontal: 16,
    borderRadius: 10,
    marginHorizontal: 4,
  },
  menuItemText: {
    flex: 1,
    fontSize: 16,
    color: '#334155',
  },
  loader: {
    paddingVertical: 20,
  },
});

=== File: src/components/TagInput.tsx ===

import React, { useState } from 'react';
import { View, Text, TextInput, TouchableOpacity, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface TagInputProps {
  value: string[];
  onChange: (tags: string[]) => void;
  placeholder?: string;
}

export function TagInput({ value, onChange, placeholder }: TagInputProps) {
  const [inputValue, setInputValue] = useState('');

  const addTag = () => {
    const trimmed = inputValue.trim();
    if (trimmed && !value.includes(trimmed)) {
      onChange([...value, trimmed]);
      setInputValue('');
    }
  };

  const removeTag = (index: number) => {
    onChange(value.filter((_, i) => i !== index));
  };

  return (
    <View style={styles.container}>
      <View style={styles.tagList}>
        {value.map((tag, idx) => (
          <View key={idx} style={styles.tag}>
            <Text style={styles.tagText}>{tag}</Text>
            <TouchableOpacity onPress={() => removeTag(idx)} style={styles.removeButton}>
              <Ionicons name="close-circle" size={16} color="#94a3b8" />
            </TouchableOpacity>
          </View>
        ))}
      </View>
      <View style={styles.inputRow}>
        <TextInput
          value={inputValue}
          onChangeText={setInputValue}
          placeholder={placeholder}
          placeholderTextColor="#94a3b8"
          onSubmitEditing={addTag}
          style={styles.input}
          returnKeyType="done"
        />
        <TouchableOpacity onPress={addTag} style={styles.addButton}>
          <Ionicons name="add" size={20} color="#ffffff" />
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  tagList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 8,
  },
  tag: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#f1f5f9',
    paddingVertical: 6,
    paddingHorizontal: 12,
    borderRadius: 16,
    gap: 4,
  },
  tagText: {
    fontSize: 14,
    color: '#334155',
  },
  removeButton: {
    marginLeft: 2,
  },
  inputRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  input: {
    flex: 1,
    fontSize: 14,
    color: '#1e293b',
    paddingVertical: 8,
    paddingHorizontal: 12,
    backgroundColor: '#f8fafc',
    borderRadius: 8,
  },
  addButton: {
    width: 36,
    height: 36,
    backgroundColor: '#6366f1',
    borderRadius: 18,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

=== File: src/components/TierBadge.tsx ===

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { MerchantCouponTier } from '../types';
import { getTierStyle } from '../constants/tierStyles';

interface TierBadgeProps {
  tier: MerchantCouponTier;
  isZh?: boolean;
  size?: 'small' | 'medium' | 'large';
  showProbability?: boolean;
}

export function TierBadge({ tier, isZh = true, size = 'medium', showProbability = false }: TierBadgeProps) {
  const style = getTierStyle(tier);
  
  const sizeStyles = {
    small: { paddingHorizontal: 6, paddingVertical: 2, fontSize: 10 },
    medium: { paddingHorizontal: 10, paddingVertical: 4, fontSize: 12 },
    large: { paddingHorizontal: 14, paddingVertical: 6, fontSize: 14 },
  };
  
  const currentSize = sizeStyles[size];

  return (
    <View style={[
      styles.badge,
      {
        backgroundColor: style.backgroundColor,
        borderColor: style.borderColor,
        paddingHorizontal: currentSize.paddingHorizontal,
        paddingVertical: currentSize.paddingVertical,
      }
    ]}>
      <Text style={[styles.tierText, { color: style.textColor, fontSize: currentSize.fontSize }]}>
        {tier}
      </Text>
      {showProbability && (
        <Text style={[styles.probText, { color: style.textColor, fontSize: currentSize.fontSize - 2 }]}>
          {style.probability}%
        </Text>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  badge: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
    borderRadius: 8,
    borderWidth: 1,
  },
  tierText: {
    fontWeight: '700',
  },
  probText: {
    fontWeight: '500',
    opacity: 0.8,
  },
});

=== File: src/components/ui/Button.tsx ===

import React from 'react';
import { TouchableOpacity, Text, StyleSheet, ActivityIndicator, ViewStyle, TextStyle } from 'react-native';
import { MibuBrand } from '../../../constants/Colors';

interface ButtonProps {
  title: string;
  onPress: () => void;
  disabled?: boolean;
  loading?: boolean;
  variant?: 'primary' | 'secondary' | 'outline';
  style?: ViewStyle;
  textStyle?: TextStyle;
}

export function Button({
  title,
  onPress,
  disabled = false,
  loading = false,
  variant = 'primary',
  style,
  textStyle,
}: ButtonProps) {
  const isDisabled = disabled || loading;

  const getButtonStyle = () => {
    switch (variant) {
      case 'secondary':
        return styles.secondary;
      case 'outline':
        return styles.outline;
      default:
        return styles.primary;
    }
  };

  const getTextStyle = () => {
    switch (variant) {
      case 'outline':
        return styles.outlineText;
      default:
        return styles.buttonText;
    }
  };

  return (
    <TouchableOpacity
      style={[
        styles.button,
        getButtonStyle(),
        isDisabled && styles.disabled,
        style,
      ]}
      onPress={onPress}
      disabled={isDisabled}
      activeOpacity={0.8}
    >
      {loading ? (
        <ActivityIndicator color={variant === 'outline' ? MibuBrand.brown : '#ffffff'} />
      ) : (
        <Text style={[getTextStyle(), textStyle]}>{title}</Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  button: {
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 16,
    alignItems: 'center',
    justifyContent: 'center',
  },
  primary: {
    backgroundColor: MibuBrand.brown,
  },
  secondary: {
    backgroundColor: MibuBrand.dark,
  },
  outline: {
    backgroundColor: 'transparent',
    borderWidth: 2,
    borderColor: MibuBrand.brown,
  },
  disabled: {
    opacity: 0.5,
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '700',
  },
  outlineText: {
    color: MibuBrand.brown,
    fontSize: 16,
    fontWeight: '700',
  },
});

=== File: src/components/ui/Card.tsx ===

import React, { ReactNode } from 'react';
import { View, StyleSheet, ViewStyle, TouchableOpacity } from 'react-native';

interface CardProps {
  children: ReactNode;
  style?: ViewStyle;
  onPress?: () => void;
  borderColor?: string;
  backgroundColor?: string;
}

export function Card({ children, style, onPress, borderColor, backgroundColor }: CardProps) {
  const cardStyle = [
    styles.card,
    borderColor && { borderColor, borderWidth: 2 },
    backgroundColor && { backgroundColor },
    style,
  ];

  if (onPress) {
    return (
      <TouchableOpacity style={cardStyle} onPress={onPress} activeOpacity={0.8}>
        {children}
      </TouchableOpacity>
    );
  }

  return <View style={cardStyle}>{children}</View>;
}

const styles = StyleSheet.create({
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.05,
    shadowRadius: 8,
    elevation: 2,
  },
});

=== File: src/components/ui/SegmentedControl.tsx ===

import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

interface Segment {
  key: string;
  label: string;
}

interface SegmentedControlProps {
  segments: Segment[];
  selectedKey: string;
  onSelect: (key: string) => void;
}

export function SegmentedControl({ segments, selectedKey, onSelect }: SegmentedControlProps) {
  return (
    <View style={styles.container}>
      {segments.map((segment) => {
        const isSelected = segment.key === selectedKey;
        return (
          <TouchableOpacity
            key={segment.key}
            style={[styles.segment, isSelected && styles.segmentSelected]}
            onPress={() => onSelect(segment.key)}
            activeOpacity={0.7}
          >
            <Text style={[styles.label, isSelected && styles.labelSelected]}>
              {segment.label}
            </Text>
          </TouchableOpacity>
        );
      })}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    backgroundColor: '#f1f5f9',
    borderRadius: 12,
    padding: 4,
    marginHorizontal: 16,
    marginVertical: 8,
  },
  segment: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 8,
    alignItems: 'center',
    justifyContent: 'center',
  },
  segmentSelected: {
    backgroundColor: '#ffffff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  label: {
    fontSize: 14,
    fontWeight: '500',
    color: '#64748b',
  },
  labelSelected: {
    color: '#6366f1',
    fontWeight: '600',
  },
});

=== File: src/components/ui/Select.tsx ===

import React, { useState } from 'react';
import { View, Text, TouchableOpacity, Modal, FlatList, StyleSheet } from 'react-native';
import { Ionicons } from '@expo/vector-icons';

interface Option {
  label: string;
  value: string | number;
}

interface SelectProps {
  options: Option[];
  value: string | number | null;
  onChange: (value: string | number) => void;
  placeholder: string;
  label?: string;
  loading?: boolean;
}

export function Select({ options, value, onChange, placeholder, label, loading }: SelectProps) {
  const [isOpen, setIsOpen] = useState(false);

  const selectedOption = options.find(opt => opt.value === value);

  const handleSelect = (optionValue: string | number) => {
    onChange(optionValue);
    setIsOpen(false);
  };

  return (
    <View style={styles.container}>
      {label && <Text style={styles.label}>{label}</Text>}
      
      <TouchableOpacity
        style={styles.selector}
        onPress={() => !loading && setIsOpen(true)}
        disabled={loading}
      >
        <Text style={[styles.selectorText, !selectedOption && styles.placeholder]}>
          {loading ? 'è¼‰å…¥ä¸­...' : (selectedOption?.label || placeholder)}
        </Text>
        <Ionicons name="chevron-down" size={20} color="#94a3b8" />
      </TouchableOpacity>

      <Modal visible={isOpen} transparent animationType="slide">
        <TouchableOpacity
          style={styles.modalOverlay}
          activeOpacity={1}
          onPress={() => setIsOpen(false)}
        >
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>{placeholder}</Text>
              <TouchableOpacity onPress={() => setIsOpen(false)}>
                <Ionicons name="close" size={24} color="#64748b" />
              </TouchableOpacity>
            </View>

            <FlatList
              data={options}
              keyExtractor={(item) => String(item.value)}
              renderItem={({ item }) => (
                <TouchableOpacity
                  style={[
                    styles.option,
                    item.value === value && styles.selectedOption,
                  ]}
                  onPress={() => handleSelect(item.value)}
                >
                  <Text
                    style={[
                      styles.optionText,
                      item.value === value && styles.selectedOptionText,
                    ]}
                  >
                    {item.label}
                  </Text>
                  {item.value === value && (
                    <Ionicons name="checkmark" size={20} color="#6366f1" />
                  )}
                </TouchableOpacity>
              )}
              style={styles.optionsList}
            />
          </View>
        </TouchableOpacity>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    marginBottom: 16,
  },
  label: {
    fontSize: 14,
    fontWeight: '700',
    color: '#334155',
    marginBottom: 8,
  },
  selector: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 16,
    paddingHorizontal: 16,
    paddingVertical: 16,
  },
  selectorText: {
    fontSize: 16,
    color: '#1e293b',
    fontWeight: '500',
  },
  placeholder: {
    color: '#94a3b8',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    maxHeight: '70%',
  },
  modalHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  optionsList: {
    paddingHorizontal: 8,
  },
  option: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingVertical: 16,
    paddingHorizontal: 16,
    marginVertical: 2,
    borderRadius: 12,
  },
  selectedOption: {
    backgroundColor: '#eef2ff',
  },
  optionText: {
    fontSize: 16,
    color: '#334155',
  },
  selectedOptionText: {
    color: '#6366f1',
    fontWeight: '600',
  },
});

=== File: src/constants/tierStyles.ts ===

import { MerchantCouponTier } from '../types';
import { MibuBrand } from '../../constants/Colors';

export interface TierStyle {
  backgroundColor: string;
  borderColor: string;
  textColor: string;
  gradientColors: [string, string];
  glowColor: string;
  label: string;
  labelEn: string;
  probability: number;
}

export const TIER_STYLES: Record<MerchantCouponTier, TierStyle> = {
  SP: {
    backgroundColor: '#FFF8E7',
    borderColor: '#D4A24C',
    textColor: '#8B6914',
    gradientColors: ['#F5D78E', '#D4A24C'],
    glowColor: 'rgba(212, 162, 76, 0.4)',
    label: 'å‚³èªª',
    labelEn: 'Legendary',
    probability: 2,
  },
  SSR: {
    backgroundColor: '#FFF0F5',
    borderColor: '#C97B8B',
    textColor: '#8B4D5C',
    gradientColors: ['#E8A8B8', '#C97B8B'],
    glowColor: 'rgba(201, 123, 139, 0.35)',
    label: 'è¶…ç¨€æœ‰',
    labelEn: 'Super Rare',
    probability: 8,
  },
  SR: {
    backgroundColor: '#F5F0FA',
    borderColor: '#9B7BB8',
    textColor: '#6B4B88',
    gradientColors: ['#B8A0D0', '#9B7BB8'],
    glowColor: 'rgba(155, 123, 184, 0.3)',
    label: 'ç¨€æœ‰',
    labelEn: 'Rare',
    probability: 15,
  },
  S: {
    backgroundColor: '#F0F5F8',
    borderColor: '#7BA0B8',
    textColor: '#4B6B88',
    gradientColors: ['#A0C0D0', '#7BA0B8'],
    glowColor: 'rgba(123, 160, 184, 0.25)',
    label: 'é«˜ç´š',
    labelEn: 'Superior',
    probability: 23,
  },
  R: {
    backgroundColor: MibuBrand.cream,
    borderColor: MibuBrand.tan,
    textColor: MibuBrand.brownDark,
    gradientColors: [MibuBrand.tanLight, MibuBrand.tan],
    glowColor: 'rgba(176, 136, 96, 0.2)',
    label: 'æ™®é€š',
    labelEn: 'Regular',
    probability: 32,
  },
};

export const TIER_ORDER: MerchantCouponTier[] = ['SP', 'SSR', 'SR', 'S', 'R'];

export const getTierStyle = (tier: MerchantCouponTier): TierStyle => {
  return TIER_STYLES[tier] || TIER_STYLES.R;
};

export const getTierBadgeStyle = (tier: MerchantCouponTier) => {
  const style = getTierStyle(tier);
  return {
    backgroundColor: style.backgroundColor,
    borderColor: style.borderColor,
    borderWidth: 1,
  };
};

=== File: src/constants/translations.ts ===

import { Language } from '../types';

export const MAX_LEVEL = 12;
export const DEFAULT_LEVEL = 5;
export const MAX_DAILY_GENERATIONS = 3;

export const API_BASE_URL = process.env.EXPO_PUBLIC_API_URL || 'https://gacha-travel--s8869420.replit.app';

export const CATEGORY_COLORS: Record<string, string> = {
  food: '#ea580c',
  stay: '#0891b2',
  education: '#7c3aed',
  entertainment: '#db2777',
  scenery: '#10b981',
  shopping: '#f59e0b',
  activity: '#84cc16',
  experience: '#f59e0b',
};

export const TRANSLATIONS: Record<Language, Record<string, string>> = {
  'zh-TW': {
    dailyLimitReached: 'ä»Šæ—¥é¡åº¦å·²é”ä¸Šé™',
    dailyLimitReachedDesc: 'æ¯æ—¥æœ€å¤šç”Ÿæˆ 3 æ¬¡è¡Œç¨‹ã€‚è«‹æ˜å¤©å†ä¾†ï¼',
    appTitle: 'è¡Œç¨‹æ‰­è›‹',
    appSubtitle: 'ä»Šå¤©å»å“ªç©?è€å¤©èªªäº†ç®—',
    destination: 'ç›®çš„åœ°',
    selectDestination: 'é¸æ“‡ç›®çš„åœ°',
    city: 'åŸå¸‚',
    selectCity: 'é¸æ“‡åŸå¸‚',
    startGacha: 'é–‹å§‹æ‰­è›‹',
    generating: 'ç”Ÿæˆä¸­...',
    findingGems: 'æ­£åœ¨å°‹æ‰¾éš±è—æ™¯é»',
    tripLevel: 'Lv.{level} ä¹‹æ—…',
    spotsCount: '{count} å€‹æ™¯é»',
    couponUnlocked: 'ç²å¾—å„ªæƒ åˆ¸',
    specialPromo: 'ç‰¹æƒ æ´»å‹•',
    noCollection: 'å°šæœªæœ‰æ”¶è—',
    startToCollect: 'é–‹å§‹æ‰­è›‹ä¾†æ”¶é›†æ™¯é»ï¼',
    noCoupons: 'å°šæœªæœ‰å„ªæƒ åˆ¸',
    navHome: 'é¦–é ',
    navGacha: 'æ‰­è›‹',
    navGachaModule: 'è¡Œç¨‹æ‰­è›‹',
    navPlanner: 'ç­–åŠƒå¸«',
    navPlannerModule: 'æ—…ç¨‹ç­–åŠƒ',
    navCollection: 'åœ–é‘‘',
    navMyBox: 'é“å…·ç®±',
    navItems: 'é“å…·ç®±',
    navSettings: 'è¨­å®š',
    navLocation: 'å®šä½',
    navItinerary: 'è¡Œç¨‹',
    navChat: 'èŠå¤©',
    navService: 'æœå‹™',
    back: 'è¿”å›',
    loading: 'è¼‰å…¥ä¸­...',
    login: 'ç™»å…¥',
    signInReplit: 'ä½¿ç”¨ Replit ç™»å…¥',
    guestLogin: 'è¨ªå®¢ç™»å…¥',
    welcomeBack: 'æ­¡è¿å›ä¾†',
    backToHome: 'è¿”å›é¦–é ',
    catFood: 'ç¾é£Ÿ',
    catStay: 'ä½å®¿',
    catScenery: 'æ™¯é»',
    catShopping: 'è³¼ç‰©',
    catEntertainment: 'å¨›æ¨‚',
    catEducation: 'æ–‡åŒ–',
    catActivity: 'æ´»å‹•',
    relaxed: 'æ‚ é–’',
    packed: 'å……å¯¦',
    selectCountry: 'è«‹é¸æ“‡åœ‹å®¶',
    selectRegion: 'è«‹é¸æ“‡åŸå¸‚/åœ°å€',
    itineraryPace: 'è¡Œç¨‹ç¯€å¥',
    stops: 'ç«™',
    viewOnMap: 'åœ¨ Google åœ°åœ–ä¸­æŸ¥çœ‹',
    rePull: 'é‡æ–°æ‰­è›‹',
    places: 'å€‹åœ°é»',
    myCollection: 'æˆ‘çš„åœ–é‘‘',
    spots: 'å€‹åœ°é»',
    announcements: 'å…¬å‘Š',
    flashEvents: 'å¿«é–ƒæ´»å‹•',
    explore: 'æ¢ç´¢',
    shareLocationToPlanner: 'åˆ†äº«ä½ç½®çµ¦ç­–åŠƒå¸«',
    yourLocation: 'ä½ çš„ä½ç½®',
    planner: 'ç­–åŠƒå¸«',
    safetyCenter: 'å®‰å…¨ä¸­å¿ƒ',
    safetyCenterDesc: 'è¨­å®šç·Šæ€¥æ±‚æ•‘åŠŸèƒ½ï¼Œç¢ºä¿æ—…é€”å®‰å…¨',
    safety: 'å®‰å…¨',
    setupEmergencySOS: 'è¨­å®šç·Šæ€¥æ±‚æ•‘åŠŸèƒ½',
    iosShortcutsIntegration: 'iOS æ·å¾‘æ•´åˆ',
    iosShortcutsDesc: 'å°‡ä»¥ä¸‹é€£çµåŠ å…¥ iOS æ·å¾‘ Appï¼Œå³å¯é€é Siri æˆ–è‡ªå‹•åŒ–å¿«é€Ÿè§¸ç™¼æ±‚æ•‘è¨Šè™Ÿ',
    webhookUrl: 'Webhook URL (POST)',
    notAvailable: 'å°šæœªå–å¾—é€£çµ',
    copyLink: 'è¤‡è£½é€£çµ',
    copied: 'å·²è¤‡è£½',
    setupSteps: 'è¨­å®šæ­¥é©Ÿï¼š',
    step1: '1. é–‹å•Ÿ iOS æ·å¾‘ App',
    step2: '2. å»ºç«‹æ–°æ·å¾‘ï¼ŒåŠ å…¥ã€Œå–å¾— URL å…§å®¹ã€å‹•ä½œ',
    step3: '3. è²¼ä¸Šä¸Šæ–¹ Webhook URL',
    step4: '4. å°‡æ–¹æ³•è¨­ç‚ºã€ŒPOSTã€',
    step5: '5. è¨­å®š Siri èªéŸ³æŒ‡ä»¤æˆ–è‡ªå‹•åŒ–è§¸ç™¼',
    emergencyNow: 'ç«‹å³æ±‚æ•‘',
    emergencyNowDesc: 'æŒ‰ä¸‹æŒ‰éˆ•ç«‹å³ç™¼é€æ±‚æ•‘è¨Šè™Ÿï¼Œé€šçŸ¥æ‚¨çš„ç·Šæ€¥è¯çµ¡äºº',
    sosButton: 'SOS æ±‚æ•‘',
    confirmSOS: 'ç¢ºèªç™¼é€ SOS',
    confirmSOSDesc: 'ç¢ºå®šè¦ç™¼é€ç·Šæ€¥æ±‚æ•‘è¨Šè™Ÿå—ï¼Ÿ',
    cancel: 'å–æ¶ˆ',
    confirmSend: 'ç¢ºå®šç™¼é€',
    sent: 'å·²ç™¼é€',
    sosSuccess: 'SOS æ±‚æ•‘è¨Šè™Ÿå·²æˆåŠŸç™¼é€',
    sendFailed: 'ç™¼é€å¤±æ•—',
    tryAgainLater: 'è«‹ç¨å¾Œå†è©¦',
    networkError: 'ç¶²è·¯é€£ç·šéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ç¶²è·¯',
    gettingLocation: 'æ­£åœ¨å–å¾—ä½ç½®...',
    locationPermissionRequired: 'éœ€è¦ä½ç½®æ¬Šé™æ‰èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½',
    unableToGetLocation: 'ç„¡æ³•å–å¾—ä½ç½®',
    retry: 'é‡è©¦',
    viewPool: 'æŸ¥çœ‹çæ± ',
    poolPreview: 'çæ± é è¦½',
    pullCount: 'æŠ½å–å¼µæ•¸',
    selectDistrict: 'é¸æ“‡è¡Œæ”¿å€',
    rareItems: 'ç¨€æœ‰é“å…·',
    noRareItems: 'æ­¤å€åŸŸå°šç„¡ç¨€æœ‰é“å…·',
    closeModal: 'é—œé–‰',
    pulls: 'å¼µ',
    loadingPool: 'è¼‰å…¥çæ± ä¸­...',
    merchant: 'ç‰¹ç´„å•†å®¶',
    generatingItinerary: 'æ­£åœ¨ç”Ÿæˆè¡Œç¨‹...',
    sponsorAd: 'è´ŠåŠ©å•†å»£å‘Š (æ¨¡æ“¬)',
    pleaseWait: 'è«‹ç¨å€™',
    almostReady: 'å³å°‡å®Œæˆ',
    gachaResults: 'æ‰­è›‹çµæœ',
    addToBackpack: 'åŠ å…¥èƒŒåŒ…',
    addedToBackpack: 'å·²åŠ å…¥èƒŒåŒ…',
    gotCoupon: 'ç²å¾—å„ªæƒ åˆ¸ï¼',
    partnerMerchant: 'ç‰¹ç´„å•†å®¶',
    rating: 'è©•åˆ†',
    noResults: 'å°šç„¡çµæœ',
    tryGachaFirst: 'å…ˆä¾†ä¸€ç™¼æ‰­è›‹å§ï¼',
    viewResults: 'æŸ¥çœ‹çµæœ',
    exploring: 'æ­£åœ¨æ¢ç´¢',
    reGacha: 'é‡æ–°æ‰­è›‹',
    emptyItemBox: 'é“å…·ç®±æ˜¯ç©ºçš„',
    collectItemsFirst: 'å…ˆå»æ‰­è›‹æ”¶é›†ä¸€äº›æ™¯é»å§ï¼',
    totalItems: 'å…±',
    itemsCount: 'å€‹é“å…·',
  },
  'en': {
    dailyLimitReached: 'Daily Limit Reached',
    dailyLimitReachedDesc: 'You can generate up to 3 itineraries per day. Come back tomorrow!',
    appTitle: 'MIBU TRIP',
    appSubtitle: 'AI Travel Gacha',
    destination: 'Destination',
    selectDestination: 'Select Destination',
    city: 'City',
    selectCity: 'Select City',
    startGacha: 'START GACHA',
    generating: 'Generating...',
    findingGems: 'Finding hidden gems',
    tripLevel: 'Level {level} Trip',
    spotsCount: '{count} Spots',
    couponUnlocked: 'Coupon Unlocked',
    specialPromo: 'Special Promo',
    noCollection: 'No collection yet.',
    startToCollect: 'Start gacha to collect spots!',
    noCoupons: 'No coupons yet.',
    navHome: 'Home',
    navGacha: 'Gacha',
    navGachaModule: 'Travel Gacha',
    navPlanner: 'Planner',
    navPlannerModule: 'Trip Planner',
    navCollection: 'Collection',
    navMyBox: 'My Box',
    navItems: 'Items',
    navSettings: 'Settings',
    navLocation: 'Location',
    navItinerary: 'Itinerary',
    navChat: 'Chat',
    navService: 'Service',
    back: 'Back',
    loading: 'Loading...',
    login: 'Login',
    signInReplit: 'Sign in with Replit',
    guestLogin: 'Guest Login',
    welcomeBack: 'Welcome Back',
    backToHome: 'Back to Home',
    catFood: 'Food',
    catStay: 'Stay',
    catScenery: 'Scenery',
    catShopping: 'Shopping',
    catEntertainment: 'Entertainment',
    catEducation: 'Culture',
    catActivity: 'Activity',
    relaxed: 'Relaxed',
    packed: 'Packed',
    selectCountry: 'Select Country',
    selectRegion: 'Select City/Region',
    itineraryPace: 'Itinerary Pace',
    stops: 'Stops',
    viewOnMap: 'View on Google Maps',
    rePull: 'Re-pull',
    places: 'places',
    myCollection: 'My Collection',
    spots: 'spots',
    announcements: 'Announcements',
    flashEvents: 'Flash Events',
    explore: 'Explore',
    shareLocationToPlanner: 'Share location with planner',
    yourLocation: 'Your location',
    planner: 'Planner',
    safetyCenter: 'Safety Center',
    safetyCenterDesc: 'Set up emergency SOS to stay safe during your trip',
    safety: 'Safety',
    setupEmergencySOS: 'Set up emergency SOS',
    iosShortcutsIntegration: 'iOS Shortcuts Integration',
    iosShortcutsDesc: 'Add the link below to iOS Shortcuts app to quickly trigger SOS via Siri or automation',
    webhookUrl: 'Webhook URL (POST)',
    notAvailable: 'Link not available',
    copyLink: 'Copy Link',
    copied: 'Copied',
    setupSteps: 'Setup Steps:',
    step1: '1. Open iOS Shortcuts app',
    step2: '2. Create new shortcut, add "Get Contents of URL" action',
    step3: '3. Paste the Webhook URL above',
    step4: '4. Set method to "POST"',
    step5: '5. Set up Siri voice command or automation trigger',
    emergencyNow: 'Emergency Now',
    emergencyNowDesc: 'Press the button to immediately send an SOS signal to your emergency contacts',
    sosButton: 'SOS Emergency',
    confirmSOS: 'Confirm SOS',
    confirmSOSDesc: 'Are you sure you want to send an emergency SOS signal?',
    cancel: 'Cancel',
    confirmSend: 'Confirm Send',
    sent: 'Sent',
    sosSuccess: 'SOS signal has been sent successfully',
    sendFailed: 'Send Failed',
    tryAgainLater: 'Please try again later',
    networkError: 'Network error, please check your connection',
    gettingLocation: 'Getting location...',
    locationPermissionRequired: 'Location permission is required to use this feature',
    unableToGetLocation: 'Unable to get location',
    retry: 'Retry',
    viewPool: 'View Pool',
    poolPreview: 'Pool Preview',
    pullCount: 'Pull Count',
    selectDistrict: 'Select District',
    rareItems: 'Rare Items',
    noRareItems: 'No rare items in this area',
    closeModal: 'Close',
    pulls: 'pulls',
    loadingPool: 'Loading pool...',
    merchant: 'Partner',
    generatingItinerary: 'Generating itinerary...',
    sponsorAd: 'Sponsored Ad (Demo)',
    pleaseWait: 'Please wait',
    almostReady: 'Almost ready',
    gachaResults: 'Gacha Results',
    addToBackpack: 'Add to Backpack',
    addedToBackpack: 'Added!',
    gotCoupon: 'Got Coupon!',
    partnerMerchant: 'Partner',
    rating: 'Rating',
    noResults: 'No Results Yet',
    tryGachaFirst: 'Try gacha first!',
    viewResults: 'View Results',
    exploring: 'Exploring',
    reGacha: 'Re-Gacha',
    emptyItemBox: 'Item Box is Empty',
    collectItemsFirst: 'Start pulling gacha to collect spots!',
    totalItems: 'Total',
    itemsCount: 'items',
  },
  'ja': {
    dailyLimitReached: 'æœ¬æ—¥ã®ä¸Šé™ã«é”ã—ã¾ã—ãŸ',
    dailyLimitReachedDesc: '1æ—¥3å›ã¾ã§ç”Ÿæˆå¯èƒ½ã§ã™ã€‚ã¾ãŸæ˜æ—¥ãŠè¶Šã—ãã ã•ã„ï¼',
    appTitle: 'MIBU æ—…ã‚¬ãƒãƒ£',
    appSubtitle: 'AI ãƒˆãƒ©ãƒ™ãƒ«ã‚¬ãƒãƒ£',
    destination: 'ç›®çš„åœ°',
    selectDestination: 'ç›®çš„åœ°ã‚’é¸æŠ',
    city: 'éƒ½å¸‚',
    selectCity: 'éƒ½å¸‚ã‚’é¸æŠ',
    startGacha: 'ã‚¬ãƒãƒ£ã‚’å›ã™',
    generating: 'ç”Ÿæˆä¸­...',
    findingGems: 'éš ã‚ŒãŸååº—ã‚’æ¢ã—ã¦ã„ã¾ã™',
    tripLevel: 'Lv.{level} ã®æ—…',
    spotsCount: '{count} ã‚¹ãƒãƒƒãƒˆ',
    couponUnlocked: 'ã‚¯ãƒ¼ãƒãƒ³ç²å¾—',
    specialPromo: 'é™å®šãƒ—ãƒ­ãƒ¢',
    noCollection: 'ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“',
    startToCollect: 'ã‚¬ãƒãƒ£ã‚’å›ã—ã¦ã‚¹ãƒãƒƒãƒˆã‚’é›†ã‚ã‚ˆã†ï¼',
    noCoupons: 'ã‚¯ãƒ¼ãƒãƒ³ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“',
    navHome: 'ãƒ›ãƒ¼ãƒ ',
    navGacha: 'ã‚¬ãƒãƒ£',
    navGachaModule: 'æ—…ç¨‹ã‚¬ãƒãƒ£',
    navPlanner: 'ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼',
    navPlannerModule: 'æ—…è¡Œãƒ—ãƒ©ãƒ³ãƒŠãƒ¼',
    navCollection: 'å›³é‘‘',
    navMyBox: 'é“å…·ç®±',
    navItems: 'é“å…·ç®±',
    navSettings: 'è¨­å®š',
    navLocation: 'ä½ç½®',
    navItinerary: 'æ—…ç¨‹',
    navChat: 'ãƒãƒ£ãƒƒãƒˆ',
    navService: 'ã‚µãƒ¼ãƒ“ã‚¹',
    back: 'æˆ»ã‚‹',
    loading: 'èª­ã¿è¾¼ã¿ä¸­...',
    login: 'ãƒ­ã‚°ã‚¤ãƒ³',
    signInReplit: 'Replitã§ãƒ­ã‚°ã‚¤ãƒ³',
    guestLogin: 'ã‚²ã‚¹ãƒˆãƒ­ã‚°ã‚¤ãƒ³',
    welcomeBack: 'ãŠã‹ãˆã‚Šãªã•ã„',
    backToHome: 'ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹',
    catFood: 'ã‚°ãƒ«ãƒ¡',
    catStay: 'å®¿æ³Š',
    catScenery: 'è¦³å…‰',
    catShopping: 'ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°',
    catEntertainment: 'ã‚¨ãƒ³ã‚¿ãƒ¡',
    catEducation: 'æ–‡åŒ–',
    catActivity: 'ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£',
    relaxed: 'ã‚†ã£ãŸã‚Š',
    packed: 'å……å®Ÿ',
    selectCountry: 'å›½ã‚’é¸æŠ',
    selectRegion: 'éƒ½å¸‚/åœ°åŸŸã‚’é¸æŠ',
    itineraryPace: 'è¡Œç¨‹ã®ãƒšãƒ¼ã‚¹',
    stops: 'ã‚¹ãƒãƒƒãƒˆ',
    viewOnMap: 'Google ãƒãƒƒãƒ—ã§è¦‹ã‚‹',
    rePull: 'å†ã‚¬ãƒãƒ£',
    places: 'ã‚¹ãƒãƒƒãƒˆ',
    myCollection: 'ãƒã‚¤å›³é‘‘',
    spots: 'ã‚¹ãƒãƒƒãƒˆ',
    announcements: 'ãŠçŸ¥ã‚‰ã›',
    flashEvents: 'ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ã‚¤ãƒ™ãƒ³ãƒˆ',
    explore: 'æ¢ç´¢',
    shareLocationToPlanner: 'ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼ã«ä½ç½®ã‚’å…±æœ‰',
    yourLocation: 'ã‚ãªãŸã®ä½ç½®',
    planner: 'ãƒ—ãƒ©ãƒ³ãƒŠãƒ¼',
    safetyCenter: 'å®‰å…¨ã‚»ãƒ³ã‚¿ãƒ¼',
    safetyCenterDesc: 'æ—…ã®å®‰å…¨ã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ç·Šæ€¥SOSã‚’è¨­å®š',
    safety: 'å®‰å…¨',
    setupEmergencySOS: 'ç·Šæ€¥SOSã‚’è¨­å®š',
    iosShortcutsIntegration: 'iOSã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆé€£æº',
    iosShortcutsDesc: 'ä»¥ä¸‹ã®ãƒªãƒ³ã‚¯ã‚’iOSã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã«è¿½åŠ ã—ã¦ã€Siriã‚„è‡ªå‹•åŒ–ã§SOSã‚’ç´ æ—©ãç™ºä¿¡',
    webhookUrl: 'Webhook URL (POST)',
    notAvailable: 'ãƒªãƒ³ã‚¯ãŒå–å¾—ã§ãã¾ã›ã‚“',
    copyLink: 'ãƒªãƒ³ã‚¯ã‚’ã‚³ãƒ”ãƒ¼',
    copied: 'ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸ',
    setupSteps: 'è¨­å®šæ‰‹é †ï¼š',
    step1: '1. iOSã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚¢ãƒ—ãƒªã‚’é–‹ã',
    step2: '2. æ–°ã—ã„ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’ä½œæˆã—ã€ŒURLã®å†…å®¹ã‚’å–å¾—ã€ã‚’è¿½åŠ ',
    step3: '3. ä¸Šè¨˜ã®Webhook URLã‚’è²¼ã‚Šä»˜ã‘',
    step4: '4. ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ã€ŒPOSTã€ã«è¨­å®š',
    step5: '5. SiriéŸ³å£°ã‚³ãƒãƒ³ãƒ‰ã¾ãŸã¯è‡ªå‹•åŒ–ãƒˆãƒªã‚¬ãƒ¼ã‚’è¨­å®š',
    emergencyNow: 'ä»Šã™ãç·Šæ€¥é€šå ±',
    emergencyNowDesc: 'ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã™ãã«ç·Šæ€¥é€£çµ¡å…ˆã«SOSã‚·ã‚°ãƒŠãƒ«ã‚’é€ä¿¡ã—ã¾ã™',
    sosButton: 'SOSç·Šæ€¥é€šå ±',
    confirmSOS: 'SOSç¢ºèª',
    confirmSOSDesc: 'ç·Šæ€¥SOSã‚·ã‚°ãƒŠãƒ«ã‚’é€ä¿¡ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ',
    cancel: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
    confirmSend: 'é€ä¿¡ç¢ºèª',
    sent: 'é€ä¿¡æ¸ˆã¿',
    sosSuccess: 'SOSã‚·ã‚°ãƒŠãƒ«ãŒæ­£å¸¸ã«é€ä¿¡ã•ã‚Œã¾ã—ãŸ',
    sendFailed: 'é€ä¿¡å¤±æ•—',
    tryAgainLater: 'å¾Œã§ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„',
    networkError: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã§ã™ã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„',
    gettingLocation: 'ä½ç½®ã‚’å–å¾—ä¸­...',
    locationPermissionRequired: 'ã“ã®æ©Ÿèƒ½ã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯ä½ç½®æƒ…å ±ã®è¨±å¯ãŒå¿…è¦ã§ã™',
    unableToGetLocation: 'ä½ç½®ã‚’å–å¾—ã§ãã¾ã›ã‚“',
    retry: 'å†è©¦è¡Œ',
    viewPool: 'ã‚¬ãƒãƒ£ç¢ºç‡ã‚’è¦‹ã‚‹',
    poolPreview: 'ã‚¬ãƒãƒ£ãƒ—ãƒ¼ãƒ«',
    pullCount: 'æŠ½é¸å›æ•°',
    selectDistrict: 'ã‚¨ãƒªã‚¢ã‚’é¸æŠ',
    rareItems: 'ãƒ¬ã‚¢ã‚¢ã‚¤ãƒ†ãƒ ',
    noRareItems: 'ã“ã®ã‚¨ãƒªã‚¢ã«ã¯ãƒ¬ã‚¢ã‚¢ã‚¤ãƒ†ãƒ ãŒã‚ã‚Šã¾ã›ã‚“',
    closeModal: 'é–‰ã˜ã‚‹',
    pulls: 'å›',
    loadingPool: 'ãƒ—ãƒ¼ãƒ«èª­ã¿è¾¼ã¿ä¸­...',
    merchant: 'ææºåº—èˆ—',
    generatingItinerary: 'æ—…ç¨‹ã‚’ç”Ÿæˆä¸­...',
    sponsorAd: 'ã‚¹ãƒãƒ³ã‚µãƒ¼åºƒå‘Š (ãƒ‡ãƒ¢)',
    pleaseWait: 'ãŠå¾…ã¡ãã ã•ã„',
    almostReady: 'ã‚‚ã†ã™ãå®Œäº†',
    gachaResults: 'ã‚¬ãƒãƒ£çµæœ',
    addToBackpack: 'ãƒªãƒ¥ãƒƒã‚¯ã«è¿½åŠ ',
    addedToBackpack: 'è¿½åŠ ã—ã¾ã—ãŸï¼',
    gotCoupon: 'ã‚¯ãƒ¼ãƒãƒ³ç²å¾—ï¼',
    partnerMerchant: 'ææºåº—èˆ—',
    rating: 'è©•ä¾¡',
    noResults: 'ã¾ã çµæœãŒã‚ã‚Šã¾ã›ã‚“',
    tryGachaFirst: 'ã¾ãšã‚¬ãƒãƒ£ã‚’å›ã—ã¦ã¿ã‚ˆã†ï¼',
    viewResults: 'çµæœã‚’è¦‹ã‚‹',
  },
  'ko': {
    dailyLimitReached: 'ì¼ì¼ í•œë„ ë„ë‹¬',
    dailyLimitReachedDesc: 'í•˜ë£¨ì— ìµœëŒ€ 3ê°œì˜ ì—¬í–‰ ì¼ì •ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‚´ì¼ ë‹¤ì‹œ ì™€ì£¼ì„¸ìš”!',
    appTitle: 'MIBU íŠ¸ë¦½',
    appSubtitle: 'AI ì—¬í–‰ ê°€ì± ',
    destination: 'ëª©ì ì§€',
    selectDestination: 'ëª©ì ì§€ ì„ íƒ',
    city: 'ë„ì‹œ',
    selectCity: 'ë„ì‹œ ì„ íƒ',
    startGacha: 'ê°€ì±  ì‹œì‘',
    generating: 'ìƒì„± ì¤‘...',
    findingGems: 'ìˆ¨ê²¨ì§„ ëª…ì†Œë¥¼ ì°¾ëŠ” ì¤‘',
    tripLevel: 'Lv.{level} ì—¬í–‰',
    spotsCount: '{count}ê°œ ì¥ì†Œ',
    couponUnlocked: 'ì¿ í° íšë“',
    specialPromo: 'íŠ¹ë³„ í”„ë¡œëª¨ì…˜',
    noCollection: 'ì•„ì§ ì»¬ë ‰ì…˜ì´ ì—†ìŠµë‹ˆë‹¤.',
    startToCollect: 'ê°€ì± ë¥¼ ëŒë ¤ ì¥ì†Œë¥¼ ìˆ˜ì§‘í•˜ì„¸ìš”!',
    noCoupons: 'ì•„ì§ ì¿ í°ì´ ì—†ìŠµë‹ˆë‹¤.',
    navHome: 'í™ˆ',
    navGacha: 'ê°€ì± ',
    navGachaModule: 'ì—¬í–‰ ê°€ì± ',
    navPlanner: 'í”Œë˜ë„ˆ',
    navPlannerModule: 'ì—¬í–‰ í”Œë˜ë„ˆ',
    navCollection: 'ë„ê°',
    navMyBox: 'ë³´ê´€í•¨',
    navItems: 'ë³´ê´€í•¨',
    navSettings: 'ì„¤ì •',
    navLocation: 'ìœ„ì¹˜',
    navItinerary: 'ì¼ì •',
    navChat: 'ì±„íŒ…',
    navService: 'ì„œë¹„ìŠ¤',
    back: 'ë’¤ë¡œ',
    loading: 'ë¡œë”© ì¤‘...',
    login: 'ë¡œê·¸ì¸',
    signInReplit: 'Replitìœ¼ë¡œ ë¡œê·¸ì¸',
    guestLogin: 'ê²ŒìŠ¤íŠ¸ ë¡œê·¸ì¸',
    welcomeBack: 'í™˜ì˜í•©ë‹ˆë‹¤',
    backToHome: 'í™ˆìœ¼ë¡œ ëŒì•„ê°€ê¸°',
    catFood: 'ë§›ì§‘',
    catStay: 'ìˆ™ë°•',
    catScenery: 'ê´€ê´‘',
    catShopping: 'ì‡¼í•‘',
    catEntertainment: 'ì—”í„°í…Œì¸ë¨¼íŠ¸',
    catEducation: 'ë¬¸í™”',
    catActivity: 'ì•¡í‹°ë¹„í‹°',
    relaxed: 'ì—¬ìœ ë¡œìš´',
    packed: 'ì•Œì°¬',
    selectCountry: 'êµ­ê°€ ì„ íƒ',
    selectRegion: 'ë„ì‹œ/ì§€ì—­ ì„ íƒ',
    itineraryPace: 'ì¼ì • í˜ì´ìŠ¤',
    stops: 'ìŠ¤í†±',
    viewOnMap: 'Google ì§€ë„ì—ì„œ ë³´ê¸°',
    rePull: 'ë‹¤ì‹œ ë½‘ê¸°',
    places: 'ì¥ì†Œ',
    myCollection: 'ë‚´ ë„ê°',
    spots: 'ì¥ì†Œ',
    announcements: 'ê³µì§€ì‚¬í•­',
    flashEvents: 'í”Œë˜ì‹œ ì´ë²¤íŠ¸',
    explore: 'íƒìƒ‰',
    shareLocationToPlanner: 'í”Œë˜ë„ˆì—ê²Œ ìœ„ì¹˜ ê³µìœ ',
    yourLocation: 'ë‚´ ìœ„ì¹˜',
    planner: 'í”Œë˜ë„ˆ',
    safetyCenter: 'ì•ˆì „ ì„¼í„°',
    safetyCenterDesc: 'ì—¬í–‰ ì¤‘ ì•ˆì „ì„ ìœ„í•´ ê¸´ê¸‰ SOS ì„¤ì •',
    safety: 'ì•ˆì „',
    setupEmergencySOS: 'ê¸´ê¸‰ SOS ì„¤ì •',
    iosShortcutsIntegration: 'iOS ë‹¨ì¶•ì–´ ì—°ë™',
    iosShortcutsDesc: 'ì•„ë˜ ë§í¬ë¥¼ iOS ë‹¨ì¶•ì–´ì— ì¶”ê°€í•˜ì—¬ Sirië‚˜ ìë™í™”ë¡œ ë¹ ë¥´ê²Œ SOS ë°œì‹ ',
    webhookUrl: 'Webhook URL (POST)',
    notAvailable: 'ë§í¬ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
    copyLink: 'ë§í¬ ë³µì‚¬',
    copied: 'ë³µì‚¬ë¨',
    setupSteps: 'ì„¤ì • ë‹¨ê³„:',
    step1: '1. iOS ë‹¨ì¶•ì–´ ì•± ì—´ê¸°',
    step2: '2. ìƒˆ ë‹¨ì¶•ì–´ ë§Œë“¤ê³  "URL ì½˜í…ì¸  ê°€ì ¸ì˜¤ê¸°" ì¶”ê°€',
    step3: '3. ìœ„ì˜ Webhook URL ë¶™ì—¬ë„£ê¸°',
    step4: '4. ë©”ì„œë“œë¥¼ "POST"ë¡œ ì„¤ì •',
    step5: '5. Siri ìŒì„± ëª…ë ¹ ë˜ëŠ” ìë™í™” íŠ¸ë¦¬ê±° ì„¤ì •',
    emergencyNow: 'ì§€ê¸ˆ ê¸´ê¸‰ ìš”ì²­',
    emergencyNowDesc: 'ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ê¸´ê¸‰ ì—°ë½ì²˜ì— SOS ì‹ í˜¸ë¥¼ ì¦‰ì‹œ ë³´ëƒ…ë‹ˆë‹¤',
    sosButton: 'SOS ê¸´ê¸‰',
    confirmSOS: 'SOS í™•ì¸',
    confirmSOSDesc: 'ê¸´ê¸‰ SOS ì‹ í˜¸ë¥¼ ë³´ë‚´ì‹œê² ìŠµë‹ˆê¹Œ?',
    cancel: 'ì·¨ì†Œ',
    confirmSend: 'ë³´ë‚´ê¸° í™•ì¸',
    sent: 'ì „ì†¡ë¨',
    sosSuccess: 'SOS ì‹ í˜¸ê°€ ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤',
    sendFailed: 'ì „ì†¡ ì‹¤íŒ¨',
    tryAgainLater: 'ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”',
    networkError: 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜, ì—°ê²°ì„ í™•ì¸í•˜ì„¸ìš”',
    gettingLocation: 'ìœ„ì¹˜ ê°€ì ¸ì˜¤ëŠ” ì¤‘...',
    locationPermissionRequired: 'ì´ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ë ¤ë©´ ìœ„ì¹˜ ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤',
    unableToGetLocation: 'ìœ„ì¹˜ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤',
    retry: 'ë‹¤ì‹œ ì‹œë„',
    viewPool: 'ê°€ì±  í™•ì¸',
    poolPreview: 'ê°€ì±  í’€',
    pullCount: 'ë½‘ê¸° íšŸìˆ˜',
    selectDistrict: 'ì§€ì—­ ì„ íƒ',
    rareItems: 'ë ˆì–´ ì•„ì´í…œ',
    noRareItems: 'ì´ ì§€ì—­ì—ëŠ” ë ˆì–´ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤',
    closeModal: 'ë‹«ê¸°',
    pulls: 'ì¥',
    loadingPool: 'í’€ ë¡œë”© ì¤‘...',
    merchant: 'íŒŒíŠ¸ë„ˆ',
    generatingItinerary: 'ì¼ì • ìƒì„± ì¤‘...',
    sponsorAd: 'ìŠ¤í°ì„œ ê´‘ê³  (ë°ëª¨)',
    pleaseWait: 'ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”',
    almostReady: 'ê±°ì˜ ì™„ë£Œ',
    gachaResults: 'ê°€ì±  ê²°ê³¼',
    addToBackpack: 'ë°°ë‚­ì— ì¶”ê°€',
    addedToBackpack: 'ì¶”ê°€ë¨!',
    gotCoupon: 'ì¿ í° íšë“!',
    partnerMerchant: 'íŒŒíŠ¸ë„ˆ',
    rating: 'í‰ì ',
    noResults: 'ì•„ì§ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤',
    tryGachaFirst: 'ë¨¼ì € ê°€ì± ë¥¼ ë½‘ì•„ë³´ì„¸ìš”!',
    viewResults: 'ê²°ê³¼ ë³´ê¸°',
  },
};

export const getCategoryLabel = (category: string, language: Language): string => {
  const labels: Record<string, Record<Language, string>> = {
    food: { 'zh-TW': 'ç¾é£Ÿ', en: 'Food', ja: 'ã‚°ãƒ«ãƒ¡', ko: 'ë§›ì§‘' },
    stay: { 'zh-TW': 'ä½å®¿', en: 'Stay', ja: 'å®¿æ³Š', ko: 'ìˆ™ë°•' },
    education: { 'zh-TW': 'ç”Ÿæ…‹æ–‡åŒ–', en: 'Culture', ja: 'æ–‡åŒ–', ko: 'ë¬¸í™”' },
    entertainment: { 'zh-TW': 'å¨›æ¨‚', en: 'Fun', ja: 'å¨¯æ¥½', ko: 'ë†€ì´' },
    scenery: { 'zh-TW': 'æ™¯é»', en: 'Scenery', ja: 'æ™¯è‰²', ko: 'ëª…ì†Œ' },
    shopping: { 'zh-TW': 'è³¼ç‰©', en: 'Shop', ja: 'è²·ç‰©', ko: 'ì‡¼í•‘' },
    activity: { 'zh-TW': 'é«”é©—', en: 'Activity', ja: 'ä½“é¨“', ko: 'ì²´í—˜' },
    experience: { 'zh-TW': 'é«”é©—', en: 'Experience', ja: 'ä½“é¨“', ko: 'ì²´í—˜' },
  };
  const categoryKey = category?.toLowerCase() || '';
  return labels[categoryKey]?.[language] || labels[categoryKey]?.['zh-TW'] || category || '';
};

export const getCategoryColor = (category: string): string => {
  return CATEGORY_COLORS[category?.toLowerCase()] || '#6366f1';
};

=== File: src/context/AppContext.tsx ===

import React, { createContext, useContext, useState, useEffect, useCallback, ReactNode } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { AppState, Language, User, GachaItem, GachaResponse, UserRole } from '../types';
import { TRANSLATIONS, DEFAULT_LEVEL } from '../constants/translations';
import { apiService } from '../services/api';

interface AppContextType {
  state: AppState;
  t: Record<string, string>;
  updateState: (updates: Partial<AppState>) => void;
  setLanguage: (lang: Language) => void;
  setUser: (user: User | null, token?: string | null) => void;
  getToken: () => Promise<string | null>;
  addToCollection: (items: GachaItem[]) => void;
  setResult: (result: GachaResponse | null) => void;
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
  switchRole: (role: UserRole) => Promise<boolean>;
  refreshUnreadCount: () => Promise<void>;
  setUnreadCount: (count: number) => void;
}

const defaultState: AppState = {
  language: 'zh-TW',
  user: null,
  country: '',
  city: '',
  countryId: null,
  regionId: null,
  level: DEFAULT_LEVEL,
  loading: false,
  error: null,
  result: null,
  collection: [],
  view: 'home',
  isAuthenticated: false,
  unreadItemCount: 0,
};

const AppContext = createContext<AppContextType | undefined>(undefined);

const STORAGE_KEYS = {
  LANGUAGE: '@mibu_language',
  COLLECTION: '@mibu_collection',
  USER: '@mibu_user',
  TOKEN: '@mibu_token',
};

export function AppProvider({ children }: { children: ReactNode }) {
  const [state, setState] = useState<AppState>(defaultState);

  useEffect(() => {
    loadStoredData();
  }, []);

  const loadStoredData = async () => {
    try {
      const [storedLanguage, storedCollection, storedUser] = await Promise.all([
        AsyncStorage.getItem(STORAGE_KEYS.LANGUAGE),
        AsyncStorage.getItem(STORAGE_KEYS.COLLECTION),
        AsyncStorage.getItem(STORAGE_KEYS.USER),
      ]);

      const updates: Partial<AppState> = {};

      if (storedLanguage) {
        updates.language = storedLanguage as Language;
      }

      if (storedCollection) {
        updates.collection = JSON.parse(storedCollection);
      }

      if (storedUser) {
        const user = JSON.parse(storedUser);
        updates.user = user;
        updates.isAuthenticated = true;
      }

      if (Object.keys(updates).length > 0) {
        setState(prev => ({ ...prev, ...updates }));
      }
    } catch (error) {
      console.error('Error loading stored data:', error);
    }
  };

  const updateState = useCallback((updates: Partial<AppState>) => {
    setState(prev => ({ ...prev, ...updates }));
  }, []);

  const setLanguage = useCallback(async (lang: Language) => {
    setState(prev => ({ ...prev, language: lang }));
    await AsyncStorage.setItem(STORAGE_KEYS.LANGUAGE, lang);
  }, []);

  const setUser = useCallback(async (user: User | null, token?: string | null) => {
    setState(prev => ({ 
      ...prev, 
      user, 
      isAuthenticated: !!user 
    }));
    if (user) {
      await AsyncStorage.setItem(STORAGE_KEYS.USER, JSON.stringify(user));
      if (token) {
        await AsyncStorage.setItem(STORAGE_KEYS.TOKEN, token);
      }
    } else {
      await AsyncStorage.removeItem(STORAGE_KEYS.USER);
      await AsyncStorage.removeItem(STORAGE_KEYS.TOKEN);
    }
  }, []);

  const getToken = useCallback(async (): Promise<string | null> => {
    try {
      return await AsyncStorage.getItem(STORAGE_KEYS.TOKEN);
    } catch {
      return null;
    }
  }, []);

  const addToCollection = useCallback(async (items: GachaItem[]) => {
    setState(prev => {
      const existingIds = new Set(prev.collection.map(i => i.id));
      const newItems = items.filter(i => !existingIds.has(i.id));
      if (newItems.length === 0) return prev;
      const updatedCollection = [...prev.collection, ...newItems];
      
      AsyncStorage.setItem(STORAGE_KEYS.COLLECTION, JSON.stringify(updatedCollection));
      
      return { ...prev, collection: updatedCollection };
    });
  }, []);

  const setResult = useCallback((result: GachaResponse | null) => {
    setState(prev => ({ ...prev, result }));
  }, []);

  const setLoading = useCallback((loading: boolean) => {
    setState(prev => ({ ...prev, loading }));
  }, []);

  const setError = useCallback((error: string | null) => {
    setState(prev => ({ ...prev, error }));
  }, []);

  const switchRole = useCallback(async (role: UserRole): Promise<boolean> => {
    try {
      const token = await AsyncStorage.getItem(STORAGE_KEYS.TOKEN);
      if (!token) return false;

      const response = await apiService.switchRole(token, role);
      
      // Validate response has activeRole
      if (!response.activeRole) {
        console.error('Switch role response missing activeRole');
        return false;
      }

      // Validate the activeRole matches what we requested
      if (response.activeRole !== role) {
        console.error('Switch role response activeRole mismatch:', response.activeRole, 'vs requested:', role);
        return false;
      }

      // Use the response.user if available, otherwise fetch fresh data
      let userData: User | null = response.user || null;
      
      if (!userData || !userData.id) {
        // Fallback to re-fetching if response.user is incomplete
        const freshUserData = await apiService.getUserWithToken(token);
        if (!freshUserData || !freshUserData.id) {
          console.error('Failed to fetch user data after role switch');
          return false;
        }
        userData = freshUserData;
      }

      // Create complete user object with the confirmed activeRole from the switch response
      const updatedUser: User = {
        id: userData.id,
        name: userData.name,
        email: userData.email,
        firstName: userData.firstName,
        lastName: userData.lastName,
        avatar: userData.avatar,
        profileImageUrl: userData.profileImageUrl,
        role: userData.role,
        activeRole: response.activeRole as UserRole, // Use confirmed activeRole from switch response
        isApproved: userData.isApproved,
        isSuperAdmin: userData.isSuperAdmin,
        accessibleRoles: userData.accessibleRoles,
        provider: userData.provider,
        providerId: userData.providerId,
      };

      // Persist first, then update state to ensure consistency
      await AsyncStorage.setItem(STORAGE_KEYS.USER, JSON.stringify(updatedUser));
      
      // Synchronously update state
      setState(prev => ({ ...prev, user: updatedUser, isAuthenticated: true }));
      
      // Verify state was updated correctly before returning success
      return true;
    } catch (error) {
      console.error('Failed to switch role:', error);
      return false;
    }
  }, []);

  const refreshUnreadCount = useCallback(async () => {
    try {
      const token = await AsyncStorage.getItem(STORAGE_KEYS.TOKEN);
      if (!token) return;
      
      const data = await apiService.getUnreadCounts(token);
      const unreadCount = data.unread?.itembox || 0;
      setState(prev => ({ ...prev, unreadItemCount: unreadCount }));
    } catch (error) {
      console.error('Failed to refresh unread count:', error);
    }
  }, []);

  const setUnreadCount = useCallback((count: number) => {
    setState(prev => ({ ...prev, unreadItemCount: count }));
  }, []);

  const t = TRANSLATIONS[state.language];

  return (
    <AppContext.Provider
      value={{
        state,
        t,
        updateState,
        setLanguage,
        setUser,
        getToken,
        addToCollection,
        setResult,
        setLoading,
        setError,
        switchRole,
        refreshUnreadCount,
        setUnreadCount,
      }}
    >
      {children}
    </AppContext.Provider>
  );
}

export function useApp() {
  const context = useContext(AppContext);
  if (context === undefined) {
    throw new Error('useApp must be used within an AppProvider');
  }
  return context;
}

=== File: src/lib/api.ts ===

import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

export const API_BASE_URL = process.env.EXPO_PUBLIC_API_URL || 'https://gacha-travel--s8869420.replit.app';

const TOKEN_KEY = 'auth_token';

async function getToken(): Promise<string | null> {
  try {
    if (Platform.OS === 'web') {
      return await AsyncStorage.getItem(TOKEN_KEY);
    }
    return await SecureStore.getItemAsync(TOKEN_KEY);
  } catch (error) {
    console.error('Failed to get token:', error);
    return null;
  }
}

export async function setToken(token: string): Promise<void> {
  try {
    if (Platform.OS === 'web') {
      await AsyncStorage.setItem(TOKEN_KEY, token);
    } else {
      await SecureStore.setItemAsync(TOKEN_KEY, token);
    }
  } catch (error) {
    console.error('Failed to save token:', error);
  }
}

export async function clearToken(): Promise<void> {
  try {
    if (Platform.OS === 'web') {
      await AsyncStorage.removeItem(TOKEN_KEY);
    } else {
      await SecureStore.deleteItemAsync(TOKEN_KEY);
    }
  } catch (error) {
    console.error('Failed to clear token:', error);
  }
}

interface ApiResponse<T> {
  data?: T;
  error?: string;
  status: number;
}

class ApiError extends Error {
  status: number;
  
  constructor(message: string, status: number) {
    super(message);
    this.name = 'ApiError';
    this.status = status;
  }
}

let onUnauthorized: (() => void) | null = null;

export function setOnUnauthorized(callback: () => void): void {
  onUnauthorized = callback;
}

async function request<T>(
  endpoint: string,
  options: RequestInit = {}
): Promise<T> {
  const url = `${API_BASE_URL}${endpoint}`;
  
  const token = await getToken();
  
  const headers: HeadersInit = {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    ...options.headers,
  };
  
  if (token) {
    (headers as Record<string, string>)['Authorization'] = `Bearer ${token}`;
  }
  
  try {
    const response = await fetch(url, {
      ...options,
      headers,
    });
    
    if (response.status === 401) {
      await clearToken();
      if (onUnauthorized) {
        onUnauthorized();
      }
      throw new ApiError('æœªæˆæ¬Šï¼Œè«‹é‡æ–°ç™»å…¥', 401);
    }
    
    if (!response.ok) {
      const errorText = await response.text();
      throw new ApiError(
        errorText || `API éŒ¯èª¤: ${response.status}`,
        response.status
      );
    }
    
    const contentType = response.headers.get('content-type');
    if (contentType && contentType.includes('application/json')) {
      return response.json();
    }
    
    return {} as T;
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    
    if (error instanceof TypeError && error.message.includes('fetch')) {
      throw new ApiError('ç¶²è·¯é€£ç·šéŒ¯èª¤ï¼Œè«‹æª¢æŸ¥ç¶²è·¯', 0);
    }
    
    throw new ApiError(
      error instanceof Error ? error.message : 'æœªçŸ¥éŒ¯èª¤',
      0
    );
  }
}

export const api = {
  get: <T>(endpoint: string, options?: RequestInit) => 
    request<T>(endpoint, { ...options, method: 'GET' }),
    
  post: <T>(endpoint: string, body?: unknown, options?: RequestInit) =>
    request<T>(endpoint, {
      ...options,
      method: 'POST',
      body: body ? JSON.stringify(body) : undefined,
    }),
    
  put: <T>(endpoint: string, body?: unknown, options?: RequestInit) =>
    request<T>(endpoint, {
      ...options,
      method: 'PUT',
      body: body ? JSON.stringify(body) : undefined,
    }),
    
  patch: <T>(endpoint: string, body?: unknown, options?: RequestInit) =>
    request<T>(endpoint, {
      ...options,
      method: 'PATCH',
      body: body ? JSON.stringify(body) : undefined,
    }),
    
  delete: <T>(endpoint: string, options?: RequestInit) =>
    request<T>(endpoint, { ...options, method: 'DELETE' }),
};

import type { ItineraryV3Payload, ItineraryV3Response, ItineraryPace } from '../types';

export async function generateItineraryV3(
  city: string,
  district: string,
  pace: ItineraryPace = 'moderate'
): Promise<ItineraryV3Response> {
  const payload: ItineraryV3Payload = { city, district, pace };
  return api.post<ItineraryV3Response>('/api/gacha/itinerary/v3', payload);
}

export { ApiError };

=== File: src/screens/AdminAnnouncementsScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  RefreshControl,
  TextInput,
  Modal,
  Switch,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { Announcement, AnnouncementType, CreateAnnouncementParams } from '../types';

export function AdminAnnouncementsScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [actionLoading, setActionLoading] = useState<number | null>(null);
  const [modalVisible, setModalVisible] = useState(false);
  const [editingAnnouncement, setEditingAnnouncement] = useState<Announcement | null>(null);
  const [formData, setFormData] = useState<CreateAnnouncementParams>({
    type: 'announcement',
    title: '',
    content: '',
    imageUrl: '',
    linkUrl: '',
    startDate: '',
    endDate: '',
    isActive: true,
    priority: 0,
  });

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å…¬å‘Šç®¡ç†' : 'Announcement Management',
    back: isZh ? 'è¿”å›' : 'Back',
    add: isZh ? 'æ–°å¢' : 'Add',
    edit: isZh ? 'ç·¨è¼¯' : 'Edit',
    delete: isZh ? 'åˆªé™¤' : 'Delete',
    save: isZh ? 'å„²å­˜' : 'Save',
    cancel: isZh ? 'å–æ¶ˆ' : 'Cancel',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    noData: isZh ? 'æ²’æœ‰å…¬å‘Š' : 'No announcements',
    announcement: isZh ? 'ä¸€èˆ¬å…¬å‘Š' : 'Announcement',
    flashEvent: isZh ? 'å¿«é–ƒæ´»å‹•' : 'Flash Event',
    holidayEvent: isZh ? 'ç¯€æ—¥é™å®š' : 'Holiday Event',
    typeLabel: isZh ? 'é¡å‹' : 'Type',
    titleLabel: isZh ? 'æ¨™é¡Œ' : 'Title',
    contentLabel: isZh ? 'å…§å®¹' : 'Content',
    imageUrlLabel: isZh ? 'åœ–ç‰‡ç¶²å€' : 'Image URL',
    linkUrlLabel: isZh ? 'é€£çµç¶²å€' : 'Link URL',
    startDateLabel: isZh ? 'é–‹å§‹æ—¥æœŸ' : 'Start Date',
    endDateLabel: isZh ? 'çµæŸæ—¥æœŸ' : 'End Date',
    priorityLabel: isZh ? 'å„ªå…ˆé †åº' : 'Priority',
    isActiveLabel: isZh ? 'å•Ÿç”¨' : 'Active',
    confirmDelete: isZh ? 'ç¢ºå®šè¦åˆªé™¤é€™å‰‡å…¬å‘Šå—ï¼Ÿ' : 'Delete this announcement?',
    addTitle: isZh ? 'æ–°å¢å…¬å‘Š' : 'Add Announcement',
    editTitle: isZh ? 'ç·¨è¼¯å…¬å‘Š' : 'Edit Announcement',
    active: isZh ? 'å•Ÿç”¨ä¸­' : 'Active',
    inactive: isZh ? 'å·²åœç”¨' : 'Inactive',
    datePlaceholder: isZh ? 'YYYY-MM-DD' : 'YYYY-MM-DD',
  };

  const typeLabels: Record<AnnouncementType, string> = {
    announcement: translations.announcement,
    flash_event: translations.flashEvent,
    holiday_event: translations.holidayEvent,
  };

  const typeColors: Record<AnnouncementType, string> = {
    announcement: '#3b82f6',
    flash_event: '#f59e0b',
    holiday_event: '#ef4444',
  };

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;

      const data = await apiService.getAdminAnnouncements(token);
      setAnnouncements(data.announcements || []);
    } catch (error) {
      console.error('Failed to load announcements:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadData();
  };

  const openAddModal = () => {
    setEditingAnnouncement(null);
    setFormData({
      type: 'announcement',
      title: '',
      content: '',
      imageUrl: '',
      linkUrl: '',
      startDate: '',
      endDate: '',
      isActive: true,
      priority: 0,
    });
    setModalVisible(true);
  };

  const openEditModal = (announcement: Announcement) => {
    setEditingAnnouncement(announcement);
    setFormData({
      type: announcement.type,
      title: announcement.title,
      content: announcement.content,
      imageUrl: announcement.imageUrl || '',
      linkUrl: announcement.linkUrl || '',
      startDate: announcement.startDate?.split('T')[0] || '',
      endDate: announcement.endDate?.split('T')[0] || '',
      isActive: announcement.isActive,
      priority: announcement.priority,
    });
    setModalVisible(true);
  };

  const handleSave = async () => {
    try {
      const token = await getToken();
      if (!token) return;

      if (!formData.title.trim() || !formData.content.trim()) {
        Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹å¡«å¯«æ¨™é¡Œå’Œå…§å®¹' : 'Please fill in title and content');
        return;
      }

      const params: CreateAnnouncementParams = {
        type: formData.type,
        title: formData.title.trim(),
        content: formData.content.trim(),
        isActive: formData.isActive,
        priority: formData.priority,
      };

      if (formData.imageUrl?.trim()) params.imageUrl = formData.imageUrl.trim();
      if (formData.linkUrl?.trim()) params.linkUrl = formData.linkUrl.trim();
      if (formData.startDate?.trim()) params.startDate = formData.startDate.trim();
      if (formData.endDate?.trim()) params.endDate = formData.endDate.trim();

      if (editingAnnouncement) {
        await apiService.updateAnnouncement(token, editingAnnouncement.id, params);
      } else {
        await apiService.createAnnouncement(token, params);
      }

      setModalVisible(false);
      loadData();
    } catch (error) {
      console.error('Failed to save announcement:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'å„²å­˜å¤±æ•—' : 'Failed to save');
    }
  };

  const handleDelete = (id: number) => {
    Alert.alert(
      isZh ? 'ç¢ºèªåˆªé™¤' : 'Confirm Delete',
      translations.confirmDelete,
      [
        { text: translations.cancel, style: 'cancel' },
        {
          text: translations.delete,
          style: 'destructive',
          onPress: async () => {
            try {
              setActionLoading(id);
              const token = await getToken();
              if (!token) return;

              await apiService.deleteAnnouncement(token, id);
              loadData();
            } catch (error) {
              console.error('Failed to delete:', error);
            } finally {
              setActionLoading(null);
            }
          },
        },
      ]
    );
  };

  const toggleActive = async (announcement: Announcement) => {
    try {
      setActionLoading(announcement.id);
      const token = await getToken();
      if (!token) return;

      await apiService.updateAnnouncement(token, announcement.id, {
        isActive: !announcement.isActive,
      });
      loadData();
    } catch (error) {
      console.error('Failed to toggle active:', error);
    } finally {
      setActionLoading(null);
    }
  };

  const renderAnnouncementCard = (item: Announcement) => (
    <View key={item.id} style={[styles.card, !item.isActive && styles.cardInactive]}>
      <View style={styles.cardHeader}>
        <View style={[styles.typeBadge, { backgroundColor: typeColors[item.type] }]}>
          <Text style={styles.typeBadgeText}>{typeLabels[item.type]}</Text>
        </View>
        <View style={[styles.statusBadge, item.isActive ? styles.statusActive : styles.statusInactive]}>
          <Text style={[styles.statusText, item.isActive ? styles.statusTextActive : styles.statusTextInactive]}>
            {item.isActive ? translations.active : translations.inactive}
          </Text>
        </View>
      </View>

      <Text style={styles.cardTitle}>{item.title}</Text>
      <Text style={styles.cardContent} numberOfLines={2}>{item.content}</Text>

      {(item.startDate || item.endDate) && (
        <View style={styles.dateRow}>
          <Ionicons name="calendar-outline" size={14} color="#64748b" />
          <Text style={styles.dateText}>
            {item.startDate?.split('T')[0] || 'â€”'} ~ {item.endDate?.split('T')[0] || 'â€”'}
          </Text>
        </View>
      )}

      <View style={styles.cardFooter}>
        <Text style={styles.priorityText}>P{item.priority}</Text>
        <View style={styles.cardActions}>
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => toggleActive(item)}
            disabled={actionLoading === item.id}
          >
            <Ionicons
              name={item.isActive ? 'eye-off-outline' : 'eye-outline'}
              size={18}
              color="#64748b"
            />
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => openEditModal(item)}
          >
            <Ionicons name="pencil-outline" size={18} color="#3b82f6" />
          </TouchableOpacity>
          <TouchableOpacity
            style={styles.actionButton}
            onPress={() => handleDelete(item.id)}
            disabled={actionLoading === item.id}
          >
            {actionLoading === item.id ? (
              <ActivityIndicator size="small" color="#ef4444" />
            ) : (
              <Ionicons name="trash-outline" size={18} color="#ef4444" />
            )}
          </TouchableOpacity>
        </View>
      </View>
    </View>
  );

  const renderModal = () => (
    <Modal
      visible={modalVisible}
      animationType="slide"
      transparent={true}
      onRequestClose={() => setModalVisible(false)}
    >
      <View style={styles.modalOverlay}>
        <View style={styles.modalContent}>
          <View style={styles.modalHeader}>
            <Text style={styles.modalTitle}>
              {editingAnnouncement ? translations.editTitle : translations.addTitle}
            </Text>
            <TouchableOpacity onPress={() => setModalVisible(false)}>
              <Ionicons name="close" size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.modalBody}>
            <Text style={styles.inputLabel}>{translations.typeLabel}</Text>
            <View style={styles.typeButtons}>
              {(['announcement', 'flash_event', 'holiday_event'] as AnnouncementType[]).map((type) => (
                <TouchableOpacity
                  key={type}
                  style={[
                    styles.typeButton,
                    formData.type === type && { backgroundColor: typeColors[type] },
                  ]}
                  onPress={() => setFormData({ ...formData, type })}
                >
                  <Text
                    style={[
                      styles.typeButtonText,
                      formData.type === type && styles.typeButtonTextActive,
                    ]}
                  >
                    {typeLabels[type]}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>

            <Text style={styles.inputLabel}>{translations.titleLabel} *</Text>
            <TextInput
              style={styles.input}
              value={formData.title}
              onChangeText={(text) => setFormData({ ...formData, title: text })}
              placeholder={translations.titleLabel}
            />

            <Text style={styles.inputLabel}>{translations.contentLabel} *</Text>
            <TextInput
              style={[styles.input, styles.textArea]}
              value={formData.content}
              onChangeText={(text) => setFormData({ ...formData, content: text })}
              placeholder={translations.contentLabel}
              multiline
              numberOfLines={4}
            />

            <Text style={styles.inputLabel}>{translations.imageUrlLabel}</Text>
            <TextInput
              style={styles.input}
              value={formData.imageUrl}
              onChangeText={(text) => setFormData({ ...formData, imageUrl: text })}
              placeholder="https://..."
            />

            <Text style={styles.inputLabel}>{translations.linkUrlLabel}</Text>
            <TextInput
              style={styles.input}
              value={formData.linkUrl}
              onChangeText={(text) => setFormData({ ...formData, linkUrl: text })}
              placeholder="https://..."
            />

            <View style={styles.dateRow}>
              <View style={styles.dateInput}>
                <Text style={styles.inputLabel}>{translations.startDateLabel}</Text>
                <TextInput
                  style={styles.input}
                  value={formData.startDate}
                  onChangeText={(text) => setFormData({ ...formData, startDate: text })}
                  placeholder={translations.datePlaceholder}
                />
              </View>
              <View style={styles.dateInput}>
                <Text style={styles.inputLabel}>{translations.endDateLabel}</Text>
                <TextInput
                  style={styles.input}
                  value={formData.endDate}
                  onChangeText={(text) => setFormData({ ...formData, endDate: text })}
                  placeholder={translations.datePlaceholder}
                />
              </View>
            </View>

            <Text style={styles.inputLabel}>{translations.priorityLabel}</Text>
            <TextInput
              style={styles.input}
              value={String(formData.priority || 0)}
              onChangeText={(text) => setFormData({ ...formData, priority: parseInt(text) || 0 })}
              keyboardType="numeric"
              placeholder="0"
            />

            <View style={styles.switchRow}>
              <Text style={styles.inputLabel}>{translations.isActiveLabel}</Text>
              <Switch
                value={formData.isActive}
                onValueChange={(value) => setFormData({ ...formData, isActive: value })}
                trackColor={{ false: '#e2e8f0', true: '#86efac' }}
                thumbColor={formData.isActive ? '#22c55e' : '#94a3b8'}
              />
            </View>
          </ScrollView>

          <View style={styles.modalFooter}>
            <TouchableOpacity style={styles.cancelButton} onPress={() => setModalVisible(false)}>
              <Text style={styles.cancelButtonText}>{translations.cancel}</Text>
            </TouchableOpacity>
            <TouchableOpacity style={styles.saveButton} onPress={handleSave}>
              <Text style={styles.saveButtonText}>{translations.save}</Text>
            </TouchableOpacity>
          </View>
        </View>
      </View>
    </Modal>
  );

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{translations.title}</Text>
        <TouchableOpacity style={styles.addButton} onPress={openAddModal}>
          <Ionicons name="add" size={24} color="#ffffff" />
        </TouchableOpacity>
      </View>

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#3b82f6" />
          <Text style={styles.loadingText}>{translations.loading}</Text>
        </View>
      ) : (
        <ScrollView
          style={styles.content}
          refreshControl={
            <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
          }
        >
          {announcements.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Ionicons name="megaphone-outline" size={48} color="#cbd5e1" />
              <Text style={styles.emptyText}>{translations.noData}</Text>
            </View>
          ) : (
            announcements.map(renderAnnouncementCard)
          )}
        </ScrollView>
      )}

      {renderModal()}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: 60,
    paddingHorizontal: 20,
    paddingBottom: 20,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#f1f5f9',
    alignItems: 'center',
    justifyContent: 'center',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  addButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#3b82f6',
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 14,
    color: '#64748b',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  emptyContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: 60,
  },
  emptyText: {
    marginTop: 12,
    fontSize: 14,
    color: '#94a3b8',
  },
  card: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  cardInactive: {
    opacity: 0.6,
  },
  cardHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  typeBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 8,
  },
  typeBadgeText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#ffffff',
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 8,
  },
  statusActive: {
    backgroundColor: '#dcfce7',
  },
  statusInactive: {
    backgroundColor: '#f1f5f9',
  },
  statusText: {
    fontSize: 12,
    fontWeight: '600',
  },
  statusTextActive: {
    color: '#16a34a',
  },
  statusTextInactive: {
    color: '#64748b',
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 8,
  },
  cardContent: {
    fontSize: 14,
    color: '#64748b',
    lineHeight: 20,
    marginBottom: 12,
  },
  dateRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    marginBottom: 12,
  },
  dateText: {
    fontSize: 12,
    color: '#64748b',
  },
  cardFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    borderTopWidth: 1,
    borderTopColor: '#f1f5f9',
    paddingTop: 12,
  },
  priorityText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#94a3b8',
  },
  cardActions: {
    flexDirection: 'row',
    gap: 12,
  },
  actionButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    backgroundColor: '#f8fafc',
    alignItems: 'center',
    justifyContent: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  modalBody: {
    padding: 20,
  },
  inputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#475569',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 12,
    padding: 14,
    fontSize: 15,
    color: '#1e293b',
    marginBottom: 16,
  },
  textArea: {
    minHeight: 100,
    textAlignVertical: 'top',
  },
  typeButtons: {
    flexDirection: 'row',
    gap: 8,
    marginBottom: 16,
  },
  typeButton: {
    flex: 1,
    paddingVertical: 10,
    borderRadius: 10,
    backgroundColor: '#f1f5f9',
    alignItems: 'center',
  },
  typeButtonText: {
    fontSize: 13,
    fontWeight: '600',
    color: '#64748b',
  },
  typeButtonTextActive: {
    color: '#ffffff',
  },
  dateInput: {
    flex: 1,
  },
  switchRow: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 16,
  },
  modalFooter: {
    flexDirection: 'row',
    gap: 12,
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e2e8f0',
  },
  cancelButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#f1f5f9',
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#64748b',
  },
  saveButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#3b82f6',
    alignItems: 'center',
  },
  saveButtonText: {
    fontSize: 15,
    fontWeight: '600',
    color: '#ffffff',
  },
});

=== File: src/screens/AdminDashboardScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  RefreshControl,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { AdminUser, PlaceDraft, GlobalExclusion } from '../types';

type Tab = 'pending' | 'users' | 'drafts' | 'exclusions' | 'announcements';

export function AdminDashboardScreen() {
  const { state, getToken, setUser } = useApp();
  const router = useRouter();
  const [activeTab, setActiveTab] = useState<Tab>('pending');
  const [pendingUsers, setPendingUsers] = useState<AdminUser[]>([]);
  const [allUsers, setAllUsers] = useState<AdminUser[]>([]);
  const [drafts, setDrafts] = useState<PlaceDraft[]>([]);
  const [exclusions, setExclusions] = useState<GlobalExclusion[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [actionLoading, setActionLoading] = useState<string | null>(null);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'ç®¡ç†å¾Œå°' : 'Admin Dashboard',
    pendingTab: isZh ? 'å¾…å¯©æ ¸' : 'Pending',
    usersTab: isZh ? 'ç”¨æˆ¶' : 'Users',
    draftsTab: isZh ? 'è‰ç¨¿' : 'Drafts',
    exclusionsTab: isZh ? 'æ’é™¤' : 'Exclusions',
    announcementsTab: isZh ? 'å…¬å‘Š' : 'Announcements',
    approve: isZh ? 'æ ¸å‡†' : 'Approve',
    reject: isZh ? 'æ‹’çµ•' : 'Reject',
    publish: isZh ? 'ç™¼å¸ƒ' : 'Publish',
    delete: isZh ? 'åˆªé™¤' : 'Delete',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    noData: isZh ? 'æ²’æœ‰è³‡æ–™' : 'No data',
    noPending: isZh ? 'æ²’æœ‰å¾…å¯©æ ¸ç”¨æˆ¶' : 'No pending users',
    merchant: isZh ? 'å•†å®¶' : 'Merchant',
    specialist: isZh ? 'å°ˆå“¡' : 'Specialist',
    traveler: isZh ? 'æ—…å®¢' : 'Traveler',
    admin: isZh ? 'ç®¡ç†å“¡' : 'Admin',
    approved: isZh ? 'å·²æ ¸å‡†' : 'Approved',
    pending: isZh ? 'å¾…å¯©æ ¸' : 'Pending',
    confirmApprove: isZh ? 'ç¢ºå®šè¦æ ¸å‡†é€™ä½ç”¨æˆ¶å—ï¼Ÿ' : 'Approve this user?',
    confirmReject: isZh ? 'ç¢ºå®šè¦æ‹’çµ•é€™ä½ç”¨æˆ¶å—ï¼Ÿ' : 'Reject this user?',
    confirmPublish: isZh ? 'ç¢ºå®šè¦ç™¼å¸ƒé€™å€‹è‰ç¨¿å—ï¼Ÿ' : 'Publish this draft?',
    confirmDelete: isZh ? 'ç¢ºå®šè¦åˆªé™¤å—ï¼Ÿ' : 'Delete this item?',
    logout: isZh ? 'ç™»å‡º' : 'Logout',
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem('@mibu_token');
    await AsyncStorage.removeItem('@mibu_user');
    setUser(null);
    router.replace('/login');
  };

  const roleLabels: Record<string, string> = {
    merchant: translations.merchant,
    specialist: translations.specialist,
    traveler: translations.traveler,
    admin: translations.admin,
  };

  const getRoleBadgeStyle = (role: string) => {
    switch (role) {
      case 'merchant': return styles.roleMerchant;
      case 'specialist': return styles.roleSpecialist;
      case 'admin': return styles.roleAdmin;
      default: return styles.roleTraveler;
    }
  };

  useEffect(() => {
    loadData();
  }, [activeTab]);

  const loadData = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;

      switch (activeTab) {
        case 'pending':
          const pendingData = await apiService.getAdminPendingUsers(token);
          setPendingUsers(pendingData.users || []);
          break;
        case 'users':
          const usersData = await apiService.getAdminUsers(token);
          setAllUsers(usersData.users || []);
          break;
        case 'drafts':
          const draftsData = await apiService.getPlaceDrafts(token);
          setDrafts(draftsData.drafts || []);
          break;
        case 'exclusions':
          const exclusionsData = await apiService.getGlobalExclusions(token);
          setExclusions(exclusionsData || []);
          break;
      }
    } catch (error) {
      console.error('Failed to load admin data:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadData();
  };

  const handleApproveUser = async (userId: string, approve: boolean) => {
    Alert.alert(
      approve ? translations.approve : translations.reject,
      approve ? translations.confirmApprove : translations.confirmReject,
      [
        { text: isZh ? 'å–æ¶ˆ' : 'Cancel', style: 'cancel' },
        {
          text: isZh ? 'ç¢ºå®š' : 'Confirm',
          style: approve ? 'default' : 'destructive',
          onPress: async () => {
            try {
              setActionLoading(userId);
              const token = await getToken();
              if (!token) return;
              await apiService.approveUser(token, userId, approve);
              loadData();
            } catch (error) {
              console.error('Failed to update user:', error);
            } finally {
              setActionLoading(null);
            }
          },
        },
      ]
    );
  };

  const handlePublishDraft = async (draftId: number) => {
    Alert.alert(translations.publish, translations.confirmPublish, [
      { text: isZh ? 'å–æ¶ˆ' : 'Cancel', style: 'cancel' },
      {
        text: isZh ? 'ç¢ºå®š' : 'Confirm',
        onPress: async () => {
          try {
            setActionLoading(`draft-${draftId}`);
            const token = await getToken();
            if (!token) return;
            await apiService.publishPlaceDraft(token, draftId);
            loadData();
          } catch (error) {
            console.error('Failed to publish draft:', error);
          } finally {
            setActionLoading(null);
          }
        },
      },
    ]);
  };

  const handleDeleteDraft = async (draftId: number) => {
    Alert.alert(translations.delete, translations.confirmDelete, [
      { text: isZh ? 'å–æ¶ˆ' : 'Cancel', style: 'cancel' },
      {
        text: isZh ? 'ç¢ºå®š' : 'Confirm',
        style: 'destructive',
        onPress: async () => {
          try {
            setActionLoading(`draft-${draftId}`);
            const token = await getToken();
            if (!token) return;
            await apiService.deletePlaceDraft(token, draftId);
            loadData();
          } catch (error) {
            console.error('Failed to delete draft:', error);
          } finally {
            setActionLoading(null);
          }
        },
      },
    ]);
  };

  const handleDeleteExclusion = async (exclusionId: number) => {
    Alert.alert(translations.delete, translations.confirmDelete, [
      { text: isZh ? 'å–æ¶ˆ' : 'Cancel', style: 'cancel' },
      {
        text: isZh ? 'ç¢ºå®š' : 'Confirm',
        style: 'destructive',
        onPress: async () => {
          try {
            setActionLoading(`exclusion-${exclusionId}`);
            const token = await getToken();
            if (!token) return;
            await apiService.removeGlobalExclusion(token, exclusionId);
            loadData();
          } catch (error) {
            console.error('Failed to delete exclusion:', error);
          } finally {
            setActionLoading(null);
          }
        },
      },
    ]);
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString(isZh ? 'zh-TW' : 'en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    });
  };

  const renderTabs = () => (
    <View style={styles.tabsContainer}>
      {(['pending', 'users', 'drafts', 'exclusions', 'announcements'] as Tab[]).map(tab => (
        <TouchableOpacity
          key={tab}
          style={[styles.tab, activeTab === tab && styles.activeTab]}
          onPress={() => setActiveTab(tab)}
        >
          <Text style={[styles.tabText, activeTab === tab && styles.activeTabText]}>
            {translations[`${tab}Tab` as keyof typeof translations]}
            {tab === 'pending' && pendingUsers.length > 0 && (
              <Text style={styles.badgeText}> ({pendingUsers.length})</Text>
            )}
          </Text>
        </TouchableOpacity>
      ))}
    </View>
  );

  const renderPendingUsers = () => (
    <View style={styles.listContainer}>
      {pendingUsers.length === 0 ? (
        <View style={styles.emptyCard}>
          <Ionicons name="checkmark-circle-outline" size={48} color="#22c55e" />
          <Text style={styles.emptyText}>{translations.noPending}</Text>
        </View>
      ) : (
        pendingUsers.map(user => (
          <View key={user.id} style={styles.userCard}>
            <View style={styles.userInfo}>
              <View style={styles.userAvatar}>
                <Ionicons name="person" size={20} color="#ffffff" />
              </View>
              <View style={styles.userDetails}>
                <Text style={styles.userName}>{user.name || user.email || user.id}</Text>
                <View style={styles.userMeta}>
                  <View style={[styles.roleBadge, getRoleBadgeStyle(user.role)]}>
                    <Text style={styles.roleBadgeText}>{roleLabels[user.role] || user.role}</Text>
                  </View>
                  <Text style={styles.userDate}>{formatDate(user.createdAt)}</Text>
                </View>
              </View>
            </View>
            <View style={styles.userActions}>
              <TouchableOpacity
                style={[styles.actionButton, styles.approveButton]}
                onPress={() => handleApproveUser(user.id, true)}
                disabled={actionLoading === user.id}
              >
                {actionLoading === user.id ? (
                  <ActivityIndicator size="small" color="#ffffff" />
                ) : (
                  <Ionicons name="checkmark" size={18} color="#ffffff" />
                )}
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.actionButton, styles.rejectButton]}
                onPress={() => handleApproveUser(user.id, false)}
                disabled={actionLoading === user.id}
              >
                <Ionicons name="close" size={18} color="#ffffff" />
              </TouchableOpacity>
            </View>
          </View>
        ))
      )}
    </View>
  );

  const renderAllUsers = () => (
    <View style={styles.listContainer}>
      {allUsers.length === 0 ? (
        <View style={styles.emptyCard}>
          <Ionicons name="people-outline" size={48} color="#94a3b8" />
          <Text style={styles.emptyText}>{translations.noData}</Text>
        </View>
      ) : (
        allUsers.map(user => (
          <View key={user.id} style={styles.userCard}>
            <View style={styles.userInfo}>
              <View style={styles.userAvatar}>
                <Ionicons name="person" size={20} color="#ffffff" />
              </View>
              <View style={styles.userDetails}>
                <Text style={styles.userName}>{user.name || user.email || user.id}</Text>
                <View style={styles.userMeta}>
                  <View style={[styles.roleBadge, getRoleBadgeStyle(user.role)]}>
                    <Text style={styles.roleBadgeText}>{roleLabels[user.role] || user.role}</Text>
                  </View>
                  <View style={[styles.statusBadge, user.isApproved ? styles.statusApproved : styles.statusPending]}>
                    <Text style={styles.statusBadgeText}>
                      {user.isApproved ? translations.approved : translations.pending}
                    </Text>
                  </View>
                </View>
              </View>
            </View>
          </View>
        ))
      )}
    </View>
  );

  const renderDrafts = () => (
    <View style={styles.listContainer}>
      {drafts.length === 0 ? (
        <View style={styles.emptyCard}>
          <Ionicons name="document-outline" size={48} color="#94a3b8" />
          <Text style={styles.emptyText}>{translations.noData}</Text>
        </View>
      ) : (
        drafts.map(draft => (
          <View key={draft.id} style={styles.draftCard}>
            <View style={styles.draftInfo}>
              <Text style={styles.draftName}>{draft.placeName}</Text>
              <Text style={styles.draftLocation}>
                {[draft.district, draft.city].filter(Boolean).join(', ')}
              </Text>
              {draft.category && (
                <View style={styles.categoryBadge}>
                  <Text style={styles.categoryBadgeText}>{draft.category}</Text>
                </View>
              )}
            </View>
            <View style={styles.draftActions}>
              <TouchableOpacity
                style={[styles.actionButton, styles.publishButton]}
                onPress={() => handlePublishDraft(draft.id)}
                disabled={actionLoading === `draft-${draft.id}`}
              >
                {actionLoading === `draft-${draft.id}` ? (
                  <ActivityIndicator size="small" color="#ffffff" />
                ) : (
                  <Ionicons name="cloud-upload" size={18} color="#ffffff" />
                )}
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.actionButton, styles.deleteButton]}
                onPress={() => handleDeleteDraft(draft.id)}
                disabled={actionLoading === `draft-${draft.id}`}
              >
                <Ionicons name="trash" size={18} color="#ffffff" />
              </TouchableOpacity>
            </View>
          </View>
        ))
      )}
    </View>
  );

  const renderExclusions = () => (
    <View style={styles.listContainer}>
      {exclusions.length === 0 ? (
        <View style={styles.emptyCard}>
          <Ionicons name="ban-outline" size={48} color="#94a3b8" />
          <Text style={styles.emptyText}>{translations.noData}</Text>
        </View>
      ) : (
        exclusions.map(exclusion => (
          <View key={exclusion.id} style={styles.exclusionCard}>
            <View style={styles.exclusionInfo}>
              <Text style={styles.exclusionName}>{exclusion.placeName}</Text>
              <Text style={styles.exclusionLocation}>
                {[exclusion.district, exclusion.city].filter(Boolean).join(', ')}
              </Text>
              <Text style={styles.exclusionScore}>
                {isZh ? 'æ‰£åˆ†' : 'Penalty'}: {exclusion.penaltyScore}
              </Text>
            </View>
            <TouchableOpacity
              style={[styles.actionButton, styles.deleteButton]}
              onPress={() => handleDeleteExclusion(exclusion.id)}
              disabled={actionLoading === `exclusion-${exclusion.id}`}
            >
              {actionLoading === `exclusion-${exclusion.id}` ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <Ionicons name="trash" size={18} color="#ffffff" />
              )}
            </TouchableOpacity>
          </View>
        ))
      )}
    </View>
  );

  const renderContent = () => {
    if (loading && !refreshing) {
      return (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#6366f1" />
          <Text style={styles.loadingText}>{translations.loading}</Text>
        </View>
      );
    }

    switch (activeTab) {
      case 'pending':
        return renderPendingUsers();
      case 'users':
        return renderAllUsers();
      case 'drafts':
        return renderDrafts();
      case 'exclusions':
        return renderExclusions();
      case 'announcements':
        return (
          <View style={styles.listContainer}>
            <TouchableOpacity
              style={{
                backgroundColor: '#7A5230',
                borderRadius: 16,
                padding: 16,
                flexDirection: 'row',
                alignItems: 'center',
                justifyContent: 'center',
                gap: 8,
              }}
              onPress={() => router.push('/announcement-manage' as any)}
            >
              <Ionicons name="megaphone-outline" size={20} color="#FFFEFA" />
              <Text style={{ fontSize: 16, fontWeight: '700', color: '#FFFEFA' }}>
                {isZh ? 'å‰å¾€å…¬å‘Šç®¡ç†' : 'Go to Announcement Manager'}
              </Text>
            </TouchableOpacity>
          </View>
        );
    }
  };

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>{translations.title}</Text>
        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <Ionicons name="log-out-outline" size={20} color="#ef4444" />
          <Text style={styles.logoutText}>{translations.logout}</Text>
        </TouchableOpacity>
      </View>
      {renderTabs()}
      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
        }
      >
        {renderContent()}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingTop: 60,
    paddingHorizontal: 20,
    paddingBottom: 16,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  title: {
    fontSize: 28,
    fontWeight: '900',
    color: '#1e293b',
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 14,
    backgroundColor: '#fef2f2',
    borderRadius: 12,
  },
  logoutText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#ef4444',
  },
  tabsContainer: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    paddingHorizontal: 12,
    paddingBottom: 12,
    gap: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  tab: {
    flex: 1,
    paddingVertical: 10,
    paddingHorizontal: 12,
    borderRadius: 10,
    backgroundColor: '#f1f5f9',
    alignItems: 'center',
  },
  activeTab: {
    backgroundColor: '#6366f1',
  },
  tabText: {
    fontSize: 13,
    fontWeight: '600',
    color: '#64748b',
  },
  activeTabText: {
    color: '#ffffff',
  },
  badgeText: {
    color: '#ef4444',
    fontWeight: '700',
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: 16,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingTop: 100,
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  listContainer: {
    gap: 12,
  },
  emptyCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 12,
  },
  userCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  userInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    flex: 1,
  },
  userAvatar: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#6366f1',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  userDetails: {
    flex: 1,
  },
  userName: {
    fontSize: 15,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 6,
  },
  userMeta: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  userDate: {
    fontSize: 12,
    color: '#94a3b8',
  },
  roleBadge: {
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 6,
  },
  roleTraveler: {
    backgroundColor: '#dbeafe',
  },
  roleMerchant: {
    backgroundColor: '#fef3c7',
  },
  roleSpecialist: {
    backgroundColor: '#d1fae5',
  },
  roleAdmin: {
    backgroundColor: '#fce7f3',
  },
  roleBadgeText: {
    fontSize: 11,
    fontWeight: '600',
    color: '#475569',
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 6,
  },
  statusApproved: {
    backgroundColor: '#dcfce7',
  },
  statusPending: {
    backgroundColor: '#fef3c7',
  },
  statusBadgeText: {
    fontSize: 11,
    fontWeight: '600',
    color: '#475569',
  },
  userActions: {
    flexDirection: 'row',
    gap: 8,
  },
  actionButton: {
    width: 36,
    height: 36,
    borderRadius: 18,
    alignItems: 'center',
    justifyContent: 'center',
  },
  approveButton: {
    backgroundColor: '#22c55e',
  },
  rejectButton: {
    backgroundColor: '#ef4444',
  },
  publishButton: {
    backgroundColor: '#6366f1',
  },
  deleteButton: {
    backgroundColor: '#ef4444',
  },
  draftCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  draftInfo: {
    flex: 1,
  },
  draftName: {
    fontSize: 15,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  draftLocation: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 8,
  },
  categoryBadge: {
    alignSelf: 'flex-start',
    paddingHorizontal: 8,
    paddingVertical: 3,
    borderRadius: 6,
    backgroundColor: '#f1f5f9',
  },
  categoryBadgeText: {
    fontSize: 11,
    fontWeight: '600',
    color: '#475569',
  },
  draftActions: {
    flexDirection: 'row',
    gap: 8,
  },
  exclusionCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    borderWidth: 2,
    borderColor: '#fecaca',
  },
  exclusionInfo: {
    flex: 1,
  },
  exclusionName: {
    fontSize: 15,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  exclusionLocation: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 4,
  },
  exclusionScore: {
    fontSize: 12,
    color: '#ef4444',
    fontWeight: '600',
  },
});

=== File: src/screens/AdminExclusionsScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Alert,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { GlobalExclusion } from '../types';
import { apiService } from '../services/api';

export function AdminExclusionsScreen() {
  const router = useRouter();
  const { state } = useApp();
  const [exclusions, setExclusions] = useState<GlobalExclusion[]>([]);
  const [loading, setLoading] = useState(true);
  const [adding, setAdding] = useState(false);
  const [showAddForm, setShowAddForm] = useState(false);
  const [placeName, setPlaceName] = useState('');
  const [district, setDistrict] = useState('');
  const [city, setCity] = useState('');

  const isAdmin = state.user?.role === 'admin';
  const token = state.user?.id || '';

  const translations = {
    'zh-TW': {
      title: 'å…¨åŸŸæ’é™¤ç®¡ç†',
      subtitle: 'é€™äº›åœ°é»æ‰€æœ‰ä½¿ç”¨è€…éƒ½ä¸æœƒæŠ½åˆ°',
      addNew: 'æ–°å¢æ’é™¤',
      placeName: 'åœ°é»åç¨±',
      district: 'å€åŸŸ',
      city: 'åŸå¸‚',
      add: 'æ–°å¢',
      cancel: 'å–æ¶ˆ',
      remove: 'ç§»é™¤',
      empty: 'å°šç„¡å…¨åŸŸæ’é™¤åœ°é»',
      loading: 'è¼‰å…¥ä¸­...',
      confirmRemove: 'ç¢ºèªç§»é™¤',
      confirmRemoveMsg: 'ç¢ºå®šè¦ç§»é™¤é€™å€‹å…¨åŸŸæ’é™¤å—ï¼Ÿ',
      noPermission: 'æ‚¨æ²’æœ‰ç®¡ç†æ¬Šé™',
      back: 'è¿”å›',
    },
    'en': {
      title: 'Global Exclusions',
      subtitle: 'These places are excluded for all users',
      addNew: 'Add Exclusion',
      placeName: 'Place Name',
      district: 'District',
      city: 'City',
      add: 'Add',
      cancel: 'Cancel',
      remove: 'Remove',
      empty: 'No global exclusions yet',
      loading: 'Loading...',
      confirmRemove: 'Confirm Remove',
      confirmRemoveMsg: 'Are you sure you want to remove this exclusion?',
      noPermission: 'You do not have admin permission',
      back: 'Back',
    },
    'ja': {
      title: 'ã‚°ãƒ­ãƒ¼ãƒãƒ«é™¤å¤–ç®¡ç†',
      subtitle: 'ã“ã‚Œã‚‰ã®å ´æ‰€ã¯ã™ã¹ã¦ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é™¤å¤–ã•ã‚Œã¾ã™',
      addNew: 'é™¤å¤–ã‚’è¿½åŠ ',
      placeName: 'å ´æ‰€å',
      district: 'åœ°åŒº',
      city: 'éƒ½å¸‚',
      add: 'è¿½åŠ ',
      cancel: 'ã‚­ãƒ£ãƒ³ã‚»ãƒ«',
      remove: 'å‰Šé™¤',
      empty: 'ã‚°ãƒ­ãƒ¼ãƒãƒ«é™¤å¤–ã¯ã¾ã ã‚ã‚Šã¾ã›ã‚“',
      loading: 'èª­ã¿è¾¼ã¿ä¸­...',
      confirmRemove: 'å‰Šé™¤ç¢ºèª',
      confirmRemoveMsg: 'ã“ã®é™¤å¤–ã‚’å‰Šé™¤ã—ã¦ã‚‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ',
      noPermission: 'ç®¡ç†è€…æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“',
      back: 'æˆ»ã‚‹',
    },
    'ko': {
      title: 'ì „ì—­ ì œì™¸ ê´€ë¦¬',
      subtitle: 'ì´ ì¥ì†Œë“¤ì€ ëª¨ë“  ì‚¬ìš©ìì—ê²Œ ì œì™¸ë©ë‹ˆë‹¤',
      addNew: 'ì œì™¸ ì¶”ê°€',
      placeName: 'ì¥ì†Œëª…',
      district: 'ì§€ì—­',
      city: 'ë„ì‹œ',
      add: 'ì¶”ê°€',
      cancel: 'ì·¨ì†Œ',
      remove: 'ì‚­ì œ',
      empty: 'ì „ì—­ ì œì™¸ê°€ ì—†ìŠµë‹ˆë‹¤',
      loading: 'ë¡œë”© ì¤‘...',
      confirmRemove: 'ì‚­ì œ í™•ì¸',
      confirmRemoveMsg: 'ì´ ì œì™¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
      noPermission: 'ê´€ë¦¬ì ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤',
      back: 'ë’¤ë¡œ',
    },
  };

  const t = translations[state.language] || translations['zh-TW'];

  useEffect(() => {
    loadExclusions();
  }, []);

  const loadExclusions = async () => {
    try {
      setLoading(true);
      const data = await apiService.getGlobalExclusions(token);
      setExclusions(data);
    } catch (error) {
      console.error('Failed to load exclusions:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleAdd = async () => {
    if (!placeName.trim() || !city.trim()) {
      Alert.alert('Error', 'Place name and city are required');
      return;
    }

    try {
      setAdding(true);
      const newExclusion = await apiService.addGlobalExclusion(token, {
        placeName: placeName.trim(),
        district: district.trim(),
        city: city.trim(),
      });
      setExclusions([newExclusion, ...exclusions]);
      setPlaceName('');
      setDistrict('');
      setCity('');
      setShowAddForm(false);
    } catch (error) {
      console.error('Failed to add exclusion:', error);
      Alert.alert('Error', 'Failed to add exclusion');
    } finally {
      setAdding(false);
    }
  };

  const handleRemove = (exclusion: GlobalExclusion) => {
    Alert.alert(t.confirmRemove, t.confirmRemoveMsg, [
      { text: t.cancel, style: 'cancel' },
      {
        text: t.remove,
        style: 'destructive',
        onPress: async () => {
          try {
            await apiService.removeGlobalExclusion(token, exclusion.id);
            setExclusions(exclusions.filter(e => e.id !== exclusion.id));
          } catch (error) {
            console.error('Failed to remove exclusion:', error);
            Alert.alert('Error', 'Failed to remove exclusion');
          }
        },
      },
    ]);
  };

  if (!isAdmin) {
    return (
      <View style={styles.container}>
        <View style={styles.header}>
          <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
            <Ionicons name="arrow-back" size={24} color="#1e293b" />
          </TouchableOpacity>
          <Text style={styles.title}>{t.title}</Text>
        </View>
        <View style={styles.emptyContainer}>
          <Ionicons name="lock-closed-outline" size={64} color="#94a3b8" />
          <Text style={styles.emptyText}>{t.noPermission}</Text>
        </View>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <View style={styles.headerText}>
          <Text style={styles.title}>{t.title}</Text>
          <Text style={styles.subtitle}>{t.subtitle}</Text>
        </View>
      </View>

      {showAddForm ? (
        <View style={styles.addForm}>
          <TextInput
            style={styles.input}
            placeholder={t.placeName}
            value={placeName}
            onChangeText={setPlaceName}
            placeholderTextColor="#94a3b8"
          />
          <TextInput
            style={styles.input}
            placeholder={t.district}
            value={district}
            onChangeText={setDistrict}
            placeholderTextColor="#94a3b8"
          />
          <TextInput
            style={styles.input}
            placeholder={t.city}
            value={city}
            onChangeText={setCity}
            placeholderTextColor="#94a3b8"
          />
          <View style={styles.formButtons}>
            <TouchableOpacity
              style={styles.cancelButton}
              onPress={() => setShowAddForm(false)}
            >
              <Text style={styles.cancelButtonText}>{t.cancel}</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.addButton, adding && styles.addButtonDisabled]}
              onPress={handleAdd}
              disabled={adding}
            >
              {adding ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <Text style={styles.addButtonText}>{t.add}</Text>
              )}
            </TouchableOpacity>
          </View>
        </View>
      ) : (
        <TouchableOpacity
          style={styles.addNewButton}
          onPress={() => setShowAddForm(true)}
        >
          <Ionicons name="add-circle-outline" size={20} color="#6366f1" />
          <Text style={styles.addNewButtonText}>{t.addNew}</Text>
        </TouchableOpacity>
      )}

      {loading ? (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="large" color="#6366f1" />
          <Text style={styles.loadingText}>{t.loading}</Text>
        </View>
      ) : exclusions.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Ionicons name="ban-outline" size={64} color="#94a3b8" />
          <Text style={styles.emptyText}>{t.empty}</Text>
        </View>
      ) : (
        <ScrollView style={styles.list} contentContainerStyle={styles.listContent}>
          {exclusions.map(exclusion => (
            <View key={exclusion.id} style={styles.exclusionCard}>
              <View style={styles.exclusionInfo}>
                <Text style={styles.exclusionName}>{exclusion.placeName}</Text>
                <Text style={styles.exclusionLocation}>
                  {exclusion.district && `${exclusion.district}, `}{exclusion.city}
                </Text>
                <Text style={styles.exclusionDate}>
                  {new Date(exclusion.createdAt).toLocaleDateString()}
                </Text>
              </View>
              <TouchableOpacity
                style={styles.removeButton}
                onPress={() => handleRemove(exclusion)}
              >
                <Ionicons name="trash-outline" size={20} color="#ef4444" />
              </TouchableOpacity>
            </View>
          ))}
        </ScrollView>
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingTop: 60,
    paddingHorizontal: 20,
    paddingBottom: 20,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
  },
  backButton: {
    marginRight: 16,
    padding: 4,
  },
  headerText: {
    flex: 1,
  },
  title: {
    fontSize: 24,
    fontWeight: '800',
    color: '#1e293b',
  },
  subtitle: {
    fontSize: 14,
    color: '#64748b',
    marginTop: 4,
  },
  addNewButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#eef2ff',
    marginHorizontal: 20,
    marginTop: 20,
    padding: 16,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#c7d2fe',
    borderStyle: 'dashed',
  },
  addNewButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#6366f1',
    marginLeft: 8,
  },
  addForm: {
    backgroundColor: '#ffffff',
    marginHorizontal: 20,
    marginTop: 20,
    padding: 20,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  input: {
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 12,
    padding: 16,
    fontSize: 16,
    color: '#1e293b',
    marginBottom: 12,
  },
  formButtons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 8,
  },
  cancelButton: {
    flex: 1,
    backgroundColor: '#f1f5f9',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#64748b',
  },
  addButton: {
    flex: 1,
    backgroundColor: '#6366f1',
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  addButtonDisabled: {
    opacity: 0.6,
  },
  addButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 12,
  },
  emptyContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 16,
  },
  list: {
    flex: 1,
  },
  listContent: {
    padding: 20,
    paddingBottom: 100,
  },
  exclusionCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#fecaca',
  },
  exclusionInfo: {
    flex: 1,
  },
  exclusionName: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  exclusionLocation: {
    fontSize: 14,
    color: '#64748b',
    marginBottom: 4,
  },
  exclusionDate: {
    fontSize: 12,
    color: '#94a3b8',
  },
  removeButton: {
    width: 44,
    height: 44,
    backgroundColor: '#fef2f2',
    borderRadius: 22,
    alignItems: 'center',
    justifyContent: 'center',
  },
});

=== File: src/screens/AnnouncementManageScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Modal,
  TextInput,
  Switch,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { Announcement, AnnouncementType } from '../types';
import { MibuBrand } from '../../constants/Colors';

type EditMode = 'create' | 'edit' | null;

const TYPE_OPTIONS: { value: AnnouncementType; label: { zh: string; en: string } }[] = [
  { value: 'announcement', label: { zh: 'å…¬å‘Š', en: 'Announcement' } },
  { value: 'flash_event', label: { zh: 'å¿«é–ƒæ´»å‹•', en: 'Flash Event' } },
  { value: 'holiday_event', label: { zh: 'ç¯€æ…¶æ´»å‹•', en: 'Holiday Event' } },
];

export function AnnouncementManageScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [announcements, setAnnouncements] = useState<Announcement[]>([]);
  const [loading, setLoading] = useState(true);
  const [actionLoading, setActionLoading] = useState(false);
  const [editMode, setEditMode] = useState<EditMode>(null);
  const [editingItem, setEditingItem] = useState<Announcement | null>(null);

  const [formData, setFormData] = useState({
    type: 'announcement' as AnnouncementType,
    title: '',
    content: '',
    imageUrl: '',
    linkUrl: '',
    isActive: true,
    priority: 0,
  });

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å…¬å‘Šç®¡ç†' : 'Announcement Management',
    back: isZh ? 'è¿”å›' : 'Back',
    add: isZh ? 'æ–°å¢' : 'Add',
    edit: isZh ? 'ç·¨è¼¯' : 'Edit',
    delete: isZh ? 'åˆªé™¤' : 'Delete',
    save: isZh ? 'å„²å­˜' : 'Save',
    cancel: isZh ? 'å–æ¶ˆ' : 'Cancel',
    type: isZh ? 'é¡å‹' : 'Type',
    titleLabel: isZh ? 'æ¨™é¡Œ' : 'Title',
    contentLabel: isZh ? 'å…§å®¹' : 'Content',
    imageUrl: isZh ? 'åœ–ç‰‡ç¶²å€' : 'Image URL',
    linkUrl: isZh ? 'é€£çµç¶²å€' : 'Link URL',
    active: isZh ? 'å•Ÿç”¨' : 'Active',
    priority: isZh ? 'å„ªå…ˆé †åº' : 'Priority',
    noData: isZh ? 'å°šç„¡å…¬å‘Š' : 'No announcements',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    confirmDelete: isZh ? 'ç¢ºå®šè¦åˆªé™¤é€™å‰‡å…¬å‘Šå—ï¼Ÿ' : 'Delete this announcement?',
    createTitle: isZh ? 'æ–°å¢å…¬å‘Š' : 'Create Announcement',
    editTitle: isZh ? 'ç·¨è¼¯å…¬å‘Š' : 'Edit Announcement',
  };

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;
      const data = await apiService.getAdminAnnouncements(token);
      setAnnouncements(data.announcements || []);
    } catch (error) {
      console.error('Failed to load announcements:', error);
    } finally {
      setLoading(false);
    }
  };

  const resetForm = () => {
    setFormData({
      type: 'announcement',
      title: '',
      content: '',
      imageUrl: '',
      linkUrl: '',
      isActive: true,
      priority: 0,
    });
  };

  const handleCreate = () => {
    resetForm();
    setEditingItem(null);
    setEditMode('create');
  };

  const handleEdit = (item: Announcement) => {
    setFormData({
      type: item.type,
      title: item.title,
      content: item.content,
      imageUrl: item.imageUrl || '',
      linkUrl: item.linkUrl || '',
      isActive: item.isActive,
      priority: item.priority,
    });
    setEditingItem(item);
    setEditMode('edit');
  };

  const handleDelete = (item: Announcement) => {
    Alert.alert(translations.delete, translations.confirmDelete, [
      { text: translations.cancel, style: 'cancel' },
      {
        text: translations.delete,
        style: 'destructive',
        onPress: async () => {
          try {
            setActionLoading(true);
            const token = await getToken();
            if (!token) return;
            await apiService.deleteAnnouncement(token, item.id);
            loadData();
          } catch (error) {
            console.error('Failed to delete announcement:', error);
          } finally {
            setActionLoading(false);
          }
        },
      },
    ]);
  };

  const handleSave = async () => {
    if (!formData.title.trim() || !formData.content.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹å¡«å¯«æ¨™é¡Œå’Œå…§å®¹' : 'Please fill in title and content');
      return;
    }

    try {
      setActionLoading(true);
      const token = await getToken();
      if (!token) return;

      const payload = {
        type: formData.type,
        title: formData.title.trim(),
        content: formData.content.trim(),
        imageUrl: formData.imageUrl.trim() || undefined,
        linkUrl: formData.linkUrl.trim() || undefined,
        isActive: formData.isActive,
        priority: formData.priority,
      };

      if (editMode === 'create') {
        await apiService.createAnnouncement(token, payload);
      } else if (editMode === 'edit' && editingItem) {
        await apiService.updateAnnouncement(token, editingItem.id, payload);
      }

      setEditMode(null);
      loadData();
    } catch (error) {
      console.error('Failed to save announcement:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'å„²å­˜å¤±æ•—' : 'Save failed');
    } finally {
      setActionLoading(false);
    }
  };

  const getTypeLabel = (type: AnnouncementType) => {
    const option = TYPE_OPTIONS.find(o => o.value === type);
    return option ? option.label[isZh ? 'zh' : 'en'] : type;
  };

  const getTypeColor = (type: AnnouncementType) => {
    switch (type) {
      case 'announcement': return MibuBrand.brown;
      case 'flash_event': return '#f59e0b';
      case 'holiday_event': return '#ec4899';
      default: return '#64748b';
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={MibuBrand.brown} />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="chevron-back" size={24} color={MibuBrand.brown} />
          <Text style={styles.backText}>{translations.back}</Text>
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
        <TouchableOpacity style={styles.addButton} onPress={handleCreate}>
          <Ionicons name="add" size={24} color="#ffffff" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.scrollView} contentContainerStyle={styles.content}>
        {announcements.length === 0 ? (
          <View style={styles.emptyCard}>
            <Ionicons name="megaphone-outline" size={48} color={MibuBrand.tan} />
            <Text style={styles.emptyText}>{translations.noData}</Text>
          </View>
        ) : (
          announcements.map(item => (
            <View key={item.id} style={styles.card}>
              <View style={styles.cardHeader}>
                <View style={[styles.typeBadge, { backgroundColor: getTypeColor(item.type) + '20' }]}>
                  <Text style={[styles.typeBadgeText, { color: getTypeColor(item.type) }]}>
                    {getTypeLabel(item.type)}
                  </Text>
                </View>
                <View style={[styles.statusBadge, item.isActive ? styles.activeStatus : styles.inactiveStatus]}>
                  <Text style={styles.statusText}>{item.isActive ? (isZh ? 'å•Ÿç”¨' : 'Active') : (isZh ? 'åœç”¨' : 'Inactive')}</Text>
                </View>
              </View>
              <Text style={styles.cardTitle}>{item.title}</Text>
              <Text style={styles.cardContent} numberOfLines={2}>{item.content}</Text>
              <View style={styles.cardActions}>
                <TouchableOpacity style={styles.editButton} onPress={() => handleEdit(item)}>
                  <Ionicons name="pencil" size={16} color={MibuBrand.brown} />
                  <Text style={styles.editButtonText}>{translations.edit}</Text>
                </TouchableOpacity>
                <TouchableOpacity style={styles.deleteButton} onPress={() => handleDelete(item)}>
                  <Ionicons name="trash-outline" size={16} color="#ef4444" />
                  <Text style={styles.deleteButtonText}>{translations.delete}</Text>
                </TouchableOpacity>
              </View>
            </View>
          ))
        )}
      </ScrollView>

      <Modal visible={editMode !== null} animationType="slide" transparent>
        <View style={styles.modalOverlay}>
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>
                {editMode === 'create' ? translations.createTitle : translations.editTitle}
              </Text>
              <TouchableOpacity onPress={() => setEditMode(null)}>
                <Ionicons name="close" size={24} color="#64748b" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.formScroll}>
              <Text style={styles.label}>{translations.type}</Text>
              <View style={styles.typeSelector}>
                {TYPE_OPTIONS.map(option => (
                  <TouchableOpacity
                    key={option.value}
                    style={[styles.typeOption, formData.type === option.value && styles.typeOptionActive]}
                    onPress={() => setFormData(prev => ({ ...prev, type: option.value }))}
                  >
                    <Text style={[styles.typeOptionText, formData.type === option.value && styles.typeOptionTextActive]}>
                      {option.label[isZh ? 'zh' : 'en']}
                    </Text>
                  </TouchableOpacity>
                ))}
              </View>

              <Text style={styles.label}>{translations.titleLabel}</Text>
              <TextInput
                style={styles.input}
                value={formData.title}
                onChangeText={text => setFormData(prev => ({ ...prev, title: text }))}
                placeholder={isZh ? 'è¼¸å…¥æ¨™é¡Œ' : 'Enter title'}
              />

              <Text style={styles.label}>{translations.contentLabel}</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={formData.content}
                onChangeText={text => setFormData(prev => ({ ...prev, content: text }))}
                placeholder={isZh ? 'è¼¸å…¥å…§å®¹' : 'Enter content'}
                multiline
                numberOfLines={4}
              />

              <Text style={styles.label}>{translations.imageUrl}</Text>
              <TextInput
                style={styles.input}
                value={formData.imageUrl}
                onChangeText={text => setFormData(prev => ({ ...prev, imageUrl: text }))}
                placeholder="https://..."
              />

              <Text style={styles.label}>{translations.linkUrl}</Text>
              <TextInput
                style={styles.input}
                value={formData.linkUrl}
                onChangeText={text => setFormData(prev => ({ ...prev, linkUrl: text }))}
                placeholder="https://..."
              />

              <View style={styles.switchRow}>
                <Text style={styles.switchLabel}>{translations.active}</Text>
                <Switch
                  value={formData.isActive}
                  onValueChange={value => setFormData(prev => ({ ...prev, isActive: value }))}
                  trackColor={{ false: '#e2e8f0', true: MibuBrand.copper }}
                  thumbColor={formData.isActive ? MibuBrand.brown : '#f4f3f4'}
                />
              </View>
            </ScrollView>

            <View style={styles.modalActions}>
              <TouchableOpacity style={styles.cancelButton} onPress={() => setEditMode(null)}>
                <Text style={styles.cancelButtonText}>{translations.cancel}</Text>
              </TouchableOpacity>
              <TouchableOpacity style={styles.saveButton} onPress={handleSave} disabled={actionLoading}>
                {actionLoading ? (
                  <ActivityIndicator size="small" color="#ffffff" />
                ) : (
                  <Text style={styles.saveButtonText}>{translations.save}</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: MibuBrand.creamLight },
  loadingContainer: { flex: 1, alignItems: 'center', justifyContent: 'center', backgroundColor: MibuBrand.creamLight },
  loadingText: { marginTop: 12, color: MibuBrand.copper, fontSize: 16 },
  header: { flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', paddingTop: 60, paddingHorizontal: 20, paddingBottom: 16, backgroundColor: MibuBrand.warmWhite, borderBottomWidth: 1, borderBottomColor: MibuBrand.tanLight },
  backButton: { flexDirection: 'row', alignItems: 'center' },
  backText: { fontSize: 16, color: MibuBrand.brown, marginLeft: 4 },
  title: { fontSize: 20, fontWeight: '800', color: MibuBrand.brownDark },
  addButton: { width: 40, height: 40, borderRadius: 20, backgroundColor: MibuBrand.brown, alignItems: 'center', justifyContent: 'center' },
  scrollView: { flex: 1 },
  content: { padding: 16, paddingBottom: 100 },
  emptyCard: { backgroundColor: MibuBrand.warmWhite, borderRadius: 16, padding: 40, alignItems: 'center', borderWidth: 2, borderColor: MibuBrand.tanLight },
  emptyText: { fontSize: 16, color: MibuBrand.copper, marginTop: 12 },
  card: { backgroundColor: MibuBrand.warmWhite, borderRadius: 16, padding: 16, marginBottom: 12, borderWidth: 1, borderColor: MibuBrand.tanLight },
  cardHeader: { flexDirection: 'row', justifyContent: 'space-between', marginBottom: 12 },
  typeBadge: { paddingHorizontal: 10, paddingVertical: 4, borderRadius: 8 },
  typeBadgeText: { fontSize: 12, fontWeight: '600' },
  statusBadge: { paddingHorizontal: 8, paddingVertical: 4, borderRadius: 6 },
  activeStatus: { backgroundColor: '#dcfce7' },
  inactiveStatus: { backgroundColor: '#fee2e2' },
  statusText: { fontSize: 11, fontWeight: '600', color: '#16a34a' },
  cardTitle: { fontSize: 16, fontWeight: '700', color: MibuBrand.brownDark, marginBottom: 6 },
  cardContent: { fontSize: 14, color: MibuBrand.copper, lineHeight: 20, marginBottom: 12 },
  cardActions: { flexDirection: 'row', gap: 12 },
  editButton: { flexDirection: 'row', alignItems: 'center', gap: 4, paddingVertical: 8, paddingHorizontal: 12, backgroundColor: MibuBrand.highlight, borderRadius: 8 },
  editButtonText: { fontSize: 13, fontWeight: '600', color: MibuBrand.brown },
  deleteButton: { flexDirection: 'row', alignItems: 'center', gap: 4, paddingVertical: 8, paddingHorizontal: 12, backgroundColor: '#fef2f2', borderRadius: 8 },
  deleteButtonText: { fontSize: 13, fontWeight: '600', color: '#ef4444' },
  modalOverlay: { flex: 1, backgroundColor: 'rgba(0,0,0,0.4)', justifyContent: 'flex-end' },
  modalContent: { backgroundColor: MibuBrand.warmWhite, borderTopLeftRadius: 24, borderTopRightRadius: 24, maxHeight: '90%' },
  modalHeader: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', padding: 20, borderBottomWidth: 1, borderBottomColor: MibuBrand.tanLight },
  modalTitle: { fontSize: 18, fontWeight: '800', color: MibuBrand.brownDark },
  formScroll: { paddingHorizontal: 20, paddingTop: 16, maxHeight: 400 },
  label: { fontSize: 14, fontWeight: '600', color: MibuBrand.brownDark, marginBottom: 8, marginTop: 16 },
  typeSelector: { flexDirection: 'row', gap: 8 },
  typeOption: { flex: 1, paddingVertical: 10, paddingHorizontal: 12, borderRadius: 10, backgroundColor: MibuBrand.creamLight, alignItems: 'center' },
  typeOptionActive: { backgroundColor: MibuBrand.brown },
  typeOptionText: { fontSize: 13, fontWeight: '600', color: MibuBrand.copper },
  typeOptionTextActive: { color: '#ffffff' },
  input: { backgroundColor: MibuBrand.creamLight, borderRadius: 12, paddingHorizontal: 14, paddingVertical: 12, fontSize: 15, color: MibuBrand.brownDark, borderWidth: 1, borderColor: MibuBrand.tanLight },
  textArea: { height: 100, textAlignVertical: 'top' },
  switchRow: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginTop: 20, paddingVertical: 12 },
  switchLabel: { fontSize: 15, fontWeight: '600', color: MibuBrand.brownDark },
  modalActions: { flexDirection: 'row', gap: 12, padding: 20, borderTopWidth: 1, borderTopColor: MibuBrand.tanLight },
  cancelButton: { flex: 1, paddingVertical: 14, borderRadius: 12, backgroundColor: MibuBrand.creamLight, alignItems: 'center' },
  cancelButtonText: { fontSize: 16, fontWeight: '600', color: MibuBrand.copper },
  saveButton: { flex: 1, paddingVertical: 14, borderRadius: 12, backgroundColor: MibuBrand.brown, alignItems: 'center' },
  saveButtonText: { fontSize: 16, fontWeight: '700', color: '#ffffff' },
});

=== File: src/screens/AuthScreen.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Modal,
  TouchableOpacity,
  ActivityIndicator,
  TextInput,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { UserRole } from '../types';

interface AuthScreenProps {
  visible: boolean;
  onClose: () => void;
}

type AuthMode = 'login' | 'register';

const ROLE_OPTIONS: { value: UserRole; labelZh: string; labelEn: string; icon: string }[] = [
  { value: 'traveler', labelZh: 'æ—…å®¢', labelEn: 'Traveler', icon: 'airplane-outline' },
  { value: 'merchant', labelZh: 'å•†å®¶', labelEn: 'Merchant', icon: 'storefront-outline' },
  { value: 'specialist', labelZh: 'å°ˆå“¡', labelEn: 'Specialist', icon: 'shield-checkmark-outline' },
];

export function AuthScreen({ visible, onClose }: AuthScreenProps) {
  const { setUser, state } = useApp();
  const [mode, setMode] = useState<AuthMode>('login');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [selectedRole, setSelectedRole] = useState<UserRole>('traveler');

  const isZh = state.language === 'zh-TW';

  const translations = {
    login: isZh ? 'ç™»å…¥' : 'Sign In',
    register: isZh ? 'è¨»å†Š' : 'Sign Up',
    username: isZh ? 'å¸³è™Ÿï¼ˆEmailï¼‰' : 'Username (Email)',
    password: isZh ? 'å¯†ç¢¼' : 'Password',
    name: isZh ? 'å§“å' : 'Name',
    selectRole: isZh ? 'é¸æ“‡èº«ä»½' : 'Select Role',
    noAccount: isZh ? 'é‚„æ²’æœ‰å¸³è™Ÿï¼Ÿ' : "Don't have an account?",
    hasAccount: isZh ? 'å·²æœ‰å¸³è™Ÿï¼Ÿ' : 'Already have an account?',
    guestLogin: isZh ? 'ä»¥è¨ªå®¢èº«ä»½ç¹¼çºŒ' : 'Continue as Guest',
    guestNote: isZh ? 'è¨ªå®¢æ¨¡å¼ä¸‹ï¼Œè³‡æ–™åƒ…ä¿å­˜åœ¨æœ¬æ©Ÿè£ç½®' : 'In guest mode, data is only saved locally',
    pendingApproval: isZh ? 'å•†å®¶å’Œå°ˆå“¡å¸³è™Ÿéœ€ç®¡ç†å“¡å¯©æ ¸å¾Œæ‰èƒ½ä½¿ç”¨' : 'Merchant and Specialist accounts require admin approval',
    loginFailed: isZh ? 'ç™»å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥å¸³è™Ÿå¯†ç¢¼' : 'Login failed, please check your credentials',
    registerFailed: isZh ? 'è¨»å†Šå¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Registration failed, please try again',
  };

  const resetForm = () => {
    setUsername('');
    setPassword('');
    setName('');
    setSelectedRole('traveler');
    setError(null);
  };

  const handleLogin = async () => {
    if (!username.trim() || !password.trim()) {
      setError(isZh ? 'è«‹å¡«å¯«å¸³è™Ÿå’Œå¯†ç¢¼' : 'Please enter username and password');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await apiService.login(username.trim(), password);
      setUser(response.user, response.token);
      resetForm();
      onClose();
    } catch (err) {
      console.error('Login error:', err);
      setError(translations.loginFailed);
    } finally {
      setLoading(false);
    }
  };

  const handleRegister = async () => {
    if (!username.trim() || !password.trim() || !name.trim()) {
      setError(isZh ? 'è«‹å¡«å¯«æ‰€æœ‰æ¬„ä½' : 'Please fill in all fields');
      return;
    }

    setLoading(true);
    setError(null);

    try {
      const response = await apiService.register({
        username: username.trim(),
        password,
        name: name.trim(),
        role: selectedRole,
      });
      setUser(response.user, response.token);
      resetForm();
      onClose();
    } catch (err) {
      console.error('Register error:', err);
      setError(translations.registerFailed);
    } finally {
      setLoading(false);
    }
  };

  const handleGuestLogin = () => {
    setUser({
      id: 'guest',
      name: 'Guest User',
      email: null,
      avatar: null,
      firstName: 'Guest',
      role: 'traveler',
      provider: 'guest',
      providerId: 'guest',
    });
    resetForm();
    onClose();
  };

  const handleClose = () => {
    resetForm();
    onClose();
  };

  return (
    <Modal visible={visible} animationType="slide" transparent>
      <KeyboardAvoidingView 
        style={styles.overlay} 
        behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      >
        <View style={styles.container}>
          <View style={styles.header}>
            <Text style={styles.headerTitle}>
              {mode === 'login' ? translations.login : translations.register}
            </Text>
            <TouchableOpacity style={styles.closeButton} onPress={handleClose}>
              <Ionicons name="close" size={24} color="#64748b" />
            </TouchableOpacity>
          </View>

          <ScrollView style={styles.scrollContent} showsVerticalScrollIndicator={false}>
            <View style={styles.content}>
              <View style={styles.iconContainer}>
                <Ionicons name="person-circle" size={64} color="#6366f1" />
              </View>

              {error && (
                <View style={styles.errorContainer}>
                  <Ionicons name="alert-circle" size={20} color="#ef4444" />
                  <Text style={styles.errorText}>{error}</Text>
                </View>
              )}

              {mode === 'register' && (
                <TextInput
                  style={styles.input}
                  placeholder={translations.name}
                  value={name}
                  onChangeText={setName}
                  placeholderTextColor="#94a3b8"
                  autoCapitalize="words"
                />
              )}

              <TextInput
                style={styles.input}
                placeholder={translations.username}
                value={username}
                onChangeText={setUsername}
                placeholderTextColor="#94a3b8"
                autoCapitalize="none"
                keyboardType="email-address"
              />

              <TextInput
                style={styles.input}
                placeholder={translations.password}
                value={password}
                onChangeText={setPassword}
                placeholderTextColor="#94a3b8"
                secureTextEntry
              />

              {mode === 'register' && (
                <>
                  <Text style={styles.roleLabel}>{translations.selectRole}</Text>
                  <View style={styles.roleGrid}>
                    {ROLE_OPTIONS.map(role => (
                      <TouchableOpacity
                        key={role.value}
                        style={[
                          styles.roleCard,
                          selectedRole === role.value && styles.roleCardActive,
                        ]}
                        onPress={() => setSelectedRole(role.value)}
                      >
                        <Ionicons 
                          name={role.icon as any} 
                          size={24} 
                          color={selectedRole === role.value ? '#6366f1' : '#64748b'} 
                        />
                        <Text style={[
                          styles.roleText,
                          selectedRole === role.value && styles.roleTextActive,
                        ]}>
                          {isZh ? role.labelZh : role.labelEn}
                        </Text>
                      </TouchableOpacity>
                    ))}
                  </View>
                  {selectedRole !== 'traveler' && (
                    <Text style={styles.approvalNote}>{translations.pendingApproval}</Text>
                  )}
                </>
              )}

              <TouchableOpacity 
                style={[styles.submitButton, loading && styles.submitButtonDisabled]} 
                onPress={mode === 'login' ? handleLogin : handleRegister}
                disabled={loading}
              >
                {loading ? (
                  <ActivityIndicator color="#ffffff" />
                ) : (
                  <Text style={styles.submitButtonText}>
                    {mode === 'login' ? translations.login : translations.register}
                  </Text>
                )}
              </TouchableOpacity>

              <TouchableOpacity 
                style={styles.switchButton}
                onPress={() => {
                  setMode(mode === 'login' ? 'register' : 'login');
                  setError(null);
                }}
              >
                <Text style={styles.switchText}>
                  {mode === 'login' ? translations.noAccount : translations.hasAccount}
                  <Text style={styles.switchTextBold}>
                    {' '}{mode === 'login' ? translations.register : translations.login}
                  </Text>
                </Text>
              </TouchableOpacity>

              <View style={styles.divider}>
                <View style={styles.dividerLine} />
                <Text style={styles.dividerText}>OR</Text>
                <View style={styles.dividerLine} />
              </View>

              <TouchableOpacity style={styles.guestButton} onPress={handleGuestLogin}>
                <Ionicons name="person-outline" size={20} color="#6366f1" />
                <Text style={styles.guestButtonText}>{translations.guestLogin}</Text>
              </TouchableOpacity>

              <Text style={styles.note}>{translations.guestNote}</Text>
            </View>
          </ScrollView>
        </View>
      </KeyboardAvoidingView>
    </Modal>
  );
}

const styles = StyleSheet.create({
  overlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  container: {
    backgroundColor: '#ffffff',
    borderRadius: 24,
    width: '100%',
    maxWidth: 400,
    maxHeight: '90%',
    overflow: 'hidden',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 20,
    paddingVertical: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  closeButton: {
    padding: 4,
  },
  scrollContent: {
    maxHeight: 600,
  },
  content: {
    padding: 24,
  },
  iconContainer: {
    alignItems: 'center',
    marginBottom: 16,
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#fef2f2',
    padding: 12,
    borderRadius: 12,
    marginBottom: 16,
    gap: 8,
  },
  errorText: {
    color: '#ef4444',
    fontSize: 14,
    flex: 1,
  },
  input: {
    backgroundColor: '#f8fafc',
    borderWidth: 1,
    borderColor: '#e2e8f0',
    borderRadius: 12,
    padding: 16,
    fontSize: 16,
    color: '#1e293b',
    marginBottom: 12,
  },
  roleLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 12,
    marginTop: 8,
  },
  roleGrid: {
    flexDirection: 'row',
    gap: 8,
    marginBottom: 12,
  },
  roleCard: {
    flex: 1,
    alignItems: 'center',
    padding: 16,
    backgroundColor: '#f8fafc',
    borderRadius: 12,
    borderWidth: 2,
    borderColor: '#e2e8f0',
    gap: 8,
  },
  roleCardActive: {
    borderColor: '#6366f1',
    backgroundColor: '#eef2ff',
  },
  roleText: {
    fontSize: 13,
    fontWeight: '600',
    color: '#64748b',
  },
  roleTextActive: {
    color: '#6366f1',
  },
  approvalNote: {
    fontSize: 12,
    color: '#f59e0b',
    textAlign: 'center',
    marginBottom: 16,
  },
  submitButton: {
    backgroundColor: '#6366f1',
    paddingVertical: 16,
    borderRadius: 16,
    alignItems: 'center',
    marginTop: 8,
  },
  submitButtonDisabled: {
    opacity: 0.6,
  },
  submitButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
  switchButton: {
    paddingVertical: 16,
    alignItems: 'center',
  },
  switchText: {
    fontSize: 14,
    color: '#64748b',
  },
  switchTextBold: {
    fontWeight: '700',
    color: '#6366f1',
  },
  divider: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 8,
  },
  dividerLine: {
    flex: 1,
    height: 1,
    backgroundColor: '#e2e8f0',
  },
  dividerText: {
    paddingHorizontal: 16,
    fontSize: 12,
    color: '#94a3b8',
  },
  guestButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: '#eef2ff',
    paddingVertical: 14,
    borderRadius: 12,
    marginTop: 8,
  },
  guestButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#6366f1',
  },
  note: {
    fontSize: 12,
    color: '#94a3b8',
    textAlign: 'center',
    marginTop: 16,
  },
});

=== File: src/screens/ChatScreen.tsx ===

import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  TextInput,
  TouchableOpacity,
  KeyboardAvoidingView,
  Platform,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../context/AppContext';

interface Message {
  id: string;
  text: string;
  sender: 'user' | 'assistant';
  timestamp: Date;
}

const translations = {
  'zh-TW': {
    title: 'èŠå¤©',
    placeholder: 'è¼¸å…¥è¨Šæ¯...',
    send: 'ç™¼é€',
    typing: 'æ­£åœ¨è¼¸å…¥...',
    quickRepliesLabel: 'å¿«é€Ÿå›è¦†',
    online: 'åœ¨ç·š',
    assistantName: 'Mibu æ—…ç¨‹åŠ©æ‰‹',
    welcome: 'æ‚¨å¥½ï¼æˆ‘æ˜¯ Mibu æ—…ç¨‹åŠ©æ‰‹ã€‚è«‹å•æœ‰ä»€éº¼å¯ä»¥å¹«åŠ©æ‚¨è¦åŠƒæ—…ç¨‹å—ï¼Ÿ',
    quickReplies: [
      { id: '1', text: 'æ¨è–¦å°åŒ—æ™¯é»' },
      { id: '2', text: 'ä»Šå¤©é©åˆå»å“ª' },
      { id: '3', text: 'é™„è¿‘æœ‰ä»€éº¼å¥½ç©' },
      { id: '4', text: 'ç¾é£Ÿæ¨è–¦' },
    ],
    responses: {
      'æ¨è–¦å°åŒ—æ™¯é»': 'å°åŒ—æœ‰å¾ˆå¤šç²¾å½©æ™¯é»ï¼æˆ‘ç‰¹åˆ¥æ¨è–¦ï¼š\n\nğŸ›ï¸ **å°åŒ—101** - åœ°æ¨™æ€§å»ºç¯‰ï¼Œè§€æ™¯å°è¶…ç¾\nğŸŒ¿ **è±¡å±±æ­¥é“** - ä¿¯ç°å°åŒ—å¸‚å€çš„æœ€ä½³ä½ç½®\nğŸ­ **ä¸­æ­£ç´€å¿µå ‚** - æ­·å²æ–‡åŒ–ä¹‹ç¾\nğŸ›ï¸ **è¥¿é–€ç”º** - å¹´è¼•äººè³¼ç‰©å¤©å ‚\n\néœ€è¦æˆ‘å¹«ä½ è¦åŠƒè¡Œç¨‹å—ï¼Ÿ',
      'ä»Šå¤©é©åˆå»å“ª': 'æ ¹æ“šä»Šå¤©çš„å¤©æ°£ç‹€æ³ï¼Œæˆ‘æ¨è–¦ï¼š\n\nâ˜€ï¸ å¦‚æœå¤©æ°£æ™´æœ— â†’ è±¡å±±æ­¥é“ã€é™½æ˜å±±\nğŸŒ§ï¸ å¦‚æœä¸‹é›¨ â†’ æ•…å®®åšç‰©é™¢ã€èª å“æ›¸åº—\nğŸŒ™ å‚æ™šæ™‚åˆ† â†’ é¥’æ²³å¤œå¸‚ã€å£«æ—å¤œå¸‚\n\nä½ æ¯”è¼ƒæƒ³è¦æˆ¶å¤–é‚„æ˜¯å®¤å…§æ´»å‹•å‘¢ï¼Ÿ',
      'é™„è¿‘æœ‰ä»€éº¼å¥½ç©': 'æˆ‘å¯ä»¥æ ¹æ“šæ‚¨çš„ä½ç½®æ¨è–¦é™„è¿‘æ™¯é»ï¼\n\nè«‹åˆ°ã€Œå®šä½ã€é é¢é–‹å•Ÿä½ç½®æ¬Šé™ï¼Œæˆ‘å°±èƒ½å¹«æ‚¨æ‰¾åˆ°é™„è¿‘æœ€ç†±é–€çš„æ™¯é»ã€ç¾é£Ÿå’Œæ´»å‹•ã€‚\n\næ‚¨ä¹Ÿå¯ä»¥å‘Šè¨´æˆ‘æ‚¨ç›®å‰åœ¨å“ªå€‹å€åŸŸï¼Ÿ',
      'ç¾é£Ÿæ¨è–¦': 'å°ç£ç¾é£ŸçœŸçš„å¤ªå¤šäº†ï¼é€™äº›æ˜¯å¿…åƒæ¸…å–®ï¼š\n\nğŸœ **é¼æ³°è±å°ç± åŒ…** - ä¸–ç•ŒçŸ¥å\nğŸ§‹ **çç å¥¶èŒ¶** - å°ç£åœ‹é£²\nğŸ¥Ÿ **èšµä»”ç…** - å¤œå¸‚ç¶“å…¸\nğŸ– **æ»·è‚‰é£¯** - éŠ…æ¿ç¾é£Ÿ\nğŸ§ **èŠ‹åœ“** - ç”œå“é¦–é¸\n\næƒ³çŸ¥é“å“ªè£¡åƒå¾—åˆ°é€™äº›å—ï¼Ÿ',
      'default': 'æ”¶åˆ°æ‚¨çš„è¨Šæ¯ï¼ä½œç‚ºæ‚¨çš„æ—…ç¨‹åŠ©æ‰‹ï¼Œæˆ‘å¯ä»¥å¹«æ‚¨ï¼š\n\nâ€¢ æ¨è–¦ç†±é–€æ™¯é»\nâ€¢ è¦åŠƒä¸€æ—¥éŠè¡Œç¨‹\nâ€¢ å°‹æ‰¾é™„è¿‘ç¾é£Ÿ\nâ€¢ æä¾›æ—…éŠå°è²¼å£«\n\nè«‹å‘Šè¨´æˆ‘æ‚¨æƒ³å»å“ªè£¡ç©ï¼Ÿ',
    },
  },
  'en': {
    title: 'Chat',
    placeholder: 'Type a message...',
    send: 'Send',
    typing: 'Typing...',
    quickRepliesLabel: 'Quick replies',
    online: 'Online',
    assistantName: 'Mibu Trip Assistant',
    welcome: 'Hello! I\'m your Mibu Trip Assistant. How can I help you plan your trip today?',
    quickReplies: [
      { id: '1', text: 'Recommend Taipei spots' },
      { id: '2', text: 'Where to go today' },
      { id: '3', text: 'What\'s fun nearby' },
      { id: '4', text: 'Food recommendations' },
    ],
    responses: {
      'Recommend Taipei spots': 'Taipei has many amazing spots! I recommend:\n\nğŸ›ï¸ **Taipei 101** - Iconic landmark with stunning views\nğŸŒ¿ **Elephant Mountain** - Best view of the city skyline\nğŸ­ **CKS Memorial Hall** - Historical and cultural beauty\nğŸ›ï¸ **Ximending** - Shopping paradise for young people\n\nWould you like me to plan an itinerary?',
      'Where to go today': 'Based on today\'s weather:\n\nâ˜€ï¸ If sunny â†’ Elephant Mountain, Yangmingshan\nğŸŒ§ï¸ If rainy â†’ National Palace Museum, Eslite Bookstore\nğŸŒ™ Evening â†’ Raohe Night Market, Shilin Night Market\n\nDo you prefer outdoor or indoor activities?',
      'What\'s fun nearby': 'I can recommend places based on your location!\n\nPlease enable location in the "Location" tab, and I\'ll find the most popular spots, food, and activities near you.\n\nOr tell me which area you\'re in?',
      'Food recommendations': 'Taiwan has so much amazing food! Must-try list:\n\nğŸœ **Din Tai Fung Xiaolongbao** - World famous\nğŸ§‹ **Bubble Tea** - Taiwan\'s national drink\nğŸ¥Ÿ **Oyster Omelette** - Night market classic\nğŸ– **Braised Pork Rice** - Affordable delicacy\nğŸ§ **Taro Balls** - Sweet treat\n\nWant to know where to find these?',
      'default': 'Message received! As your trip assistant, I can help you:\n\nâ€¢ Recommend popular attractions\nâ€¢ Plan day trips\nâ€¢ Find nearby food\nâ€¢ Provide travel tips\n\nWhere would you like to go?',
    },
  },
  'ja': {
    title: 'ãƒãƒ£ãƒƒãƒˆ',
    placeholder: 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å…¥åŠ›...',
    send: 'é€ä¿¡',
    typing: 'å…¥åŠ›ä¸­...',
    quickRepliesLabel: 'ã‚¯ã‚¤ãƒƒã‚¯è¿”ä¿¡',
    online: 'ã‚ªãƒ³ãƒ©ã‚¤ãƒ³',
    assistantName: 'Mibu æ—…è¡Œã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ',
    welcome: 'ã“ã‚“ã«ã¡ã¯ï¼Mibuæ—…è¡Œã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã§ã™ã€‚æ—…è¡Œã®è¨ˆç”»ã‚’ãŠæ‰‹ä¼ã„ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿ',
    quickReplies: [
      { id: '1', text: 'å°åŒ—ã®ãŠã™ã™ã‚' },
      { id: '2', text: 'ä»Šæ—¥ã¯ã©ã“ã¸' },
      { id: '3', text: 'è¿‘ãã®è¦³å…‰åœ°' },
      { id: '4', text: 'ã‚°ãƒ«ãƒ¡æƒ…å ±' },
    ],
    responses: {
      'å°åŒ—ã®ãŠã™ã™ã‚': 'å°åŒ—ã«ã¯ç´ æ™´ã‚‰ã—ã„ã‚¹ãƒãƒƒãƒˆãŒãŸãã•ã‚“ï¼ãŠã™ã™ã‚ï¼š\n\nğŸ›ï¸ **å°åŒ—101** - ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã€çµ¶æ™¯ã®å±•æœ›å°\nğŸŒ¿ **è±¡å±±** - å¸‚è¡—åœ°ã‚’ä¸€æœ›ã§ãã‚‹æœ€é«˜ã®å ´æ‰€\nğŸ­ **ä¸­æ­£ç´€å¿µå ‚** - æ­´å²ã¨æ–‡åŒ–ã®ç¾ã—ã•\nğŸ›ï¸ **è¥¿é–€ç”º** - è‹¥è€…ã®ã‚·ãƒ§ãƒƒãƒ”ãƒ³ã‚°å¤©å›½\n\næ—…ç¨‹ã‚’è¨ˆç”»ã—ã¾ã—ã‚‡ã†ã‹ï¼Ÿ',
      'ä»Šæ—¥ã¯ã©ã“ã¸': 'ä»Šæ—¥ã®å¤©æ°—ã«åˆã‚ã›ã¦ï¼š\n\nâ˜€ï¸ æ™´ã‚Œãªã‚‰ â†’ è±¡å±±ã€é™½æ˜å±±\nğŸŒ§ï¸ é›¨ãªã‚‰ â†’ æ•…å®®åšç‰©é™¢ã€èª å“æ›¸åº—\nğŸŒ™ å¤•æ–¹ãªã‚‰ â†’ é¥’æ²³å¤œå¸‚ã€å£«æ—å¤œå¸‚\n\nã‚¢ã‚¦ãƒˆãƒ‰ã‚¢ã¨ã‚¤ãƒ³ãƒ‰ã‚¢ã€ã©ã¡ã‚‰ãŒã„ã„ã§ã™ã‹ï¼Ÿ',
      'è¿‘ãã®è¦³å…‰åœ°': 'ä½ç½®æƒ…å ±ã«åŸºã¥ã„ã¦ãŠã™ã™ã‚ã§ãã¾ã™ï¼\n\nã€Œä½ç½®æƒ…å ±ã€ã‚¿ãƒ–ã§ä½ç½®æƒ…å ±ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„ã€‚è¿‘ãã®äººæ°—ã‚¹ãƒãƒƒãƒˆã€ã‚°ãƒ«ãƒ¡ã€ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£ã‚’è¦‹ã¤ã‘ã¾ã™ã€‚\n\nã¾ãŸã¯ã€ä»Šã„ã‚‹ã‚¨ãƒªã‚¢ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚',
      'ã‚°ãƒ«ãƒ¡æƒ…å ±': 'å°æ¹¾ã‚°ãƒ«ãƒ¡ã¯æœ¬å½“ã«è±Šå¯Œï¼å¿…é£Ÿãƒªã‚¹ãƒˆï¼š\n\nğŸœ **é¼æ³°è±Šã®å°ç± åŒ…** - ä¸–ç•Œçš„ã«æœ‰å\nğŸ§‹ **ã‚¿ãƒ”ã‚ªã‚«ãƒŸãƒ«ã‚¯ãƒ†ã‚£ãƒ¼** - å°æ¹¾ã®å›½æ°‘çš„é£²ã¿ç‰©\nğŸ¥Ÿ **ç‰¡è £ã‚ªãƒ ãƒ¬ãƒ„** - å¤œå¸‚ã®å®šç•ª\nğŸ– **é­¯è‚‰é£¯** - ãŠæ‰‹é ƒã‚°ãƒ«ãƒ¡\nğŸ§ **èŠ‹åœ“** - äººæ°—ãƒ‡ã‚¶ãƒ¼ãƒˆ\n\nã©ã“ã§é£Ÿã¹ã‚‰ã‚Œã‚‹ã‹çŸ¥ã‚ŠãŸã„ã§ã™ã‹ï¼Ÿ',
      'default': 'ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã‚Šã¾ã—ãŸï¼æ—…è¡Œã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã¨ã—ã¦ï¼š\n\nâ€¢ äººæ°—è¦³å…‰åœ°ã®ãŠã™ã™ã‚\nâ€¢ æ—¥å¸°ã‚Šæ—…è¡Œã®è¨ˆç”»\nâ€¢ è¿‘ãã®ã‚°ãƒ«ãƒ¡æ¤œç´¢\nâ€¢ æ—…è¡Œã®ãƒ’ãƒ³ãƒˆ\n\nã©ã“ã¸è¡ŒããŸã„ã§ã™ã‹ï¼Ÿ',
    },
  },
  'ko': {
    title: 'ì±„íŒ…',
    placeholder: 'ë©”ì‹œì§€ ì…ë ¥...',
    send: 'ë³´ë‚´ê¸°',
    typing: 'ì…ë ¥ ì¤‘...',
    quickRepliesLabel: 'ë¹ ë¥¸ ë‹µì¥',
    online: 'ì˜¨ë¼ì¸',
    assistantName: 'Mibu ì—¬í–‰ ë„ìš°ë¯¸',
    welcome: 'ì•ˆë…•í•˜ì„¸ìš”! Mibu ì—¬í–‰ ë„ìš°ë¯¸ì…ë‹ˆë‹¤. ì—¬í–‰ ê³„íšì„ ë„ì™€ë“œë¦´ê¹Œìš”?',
    quickReplies: [
      { id: '1', text: 'íƒ€ì´ë² ì´ ëª…ì†Œ ì¶”ì²œ' },
      { id: '2', text: 'ì˜¤ëŠ˜ ì–´ë”” ê°ˆê¹Œ' },
      { id: '3', text: 'ê·¼ì²˜ ë³¼ê±°ë¦¬' },
      { id: '4', text: 'ë§›ì§‘ ì¶”ì²œ' },
    ],
    responses: {
      'íƒ€ì´ë² ì´ ëª…ì†Œ ì¶”ì²œ': 'íƒ€ì´ë² ì´ì—ëŠ” ë©‹ì§„ ëª…ì†Œê°€ ë§ì•„ìš”! ì¶”ì²œ:\n\nğŸ›ï¸ **íƒ€ì´ë² ì´ 101** - ëœë“œë§ˆí¬, ë©‹ì§„ ì „ë§ëŒ€\nğŸŒ¿ **ìƒ¹ì‚°** - ë„ì‹œ ì „ê²½ì„ ë³¼ ìˆ˜ ìˆëŠ” ìµœê³ ì˜ ì¥ì†Œ\nğŸ­ **ì¤‘ì •ê¸°ë…ë‹¹** - ì—­ì‚¬ì™€ ë¬¸í™”ì˜ ì•„ë¦„ë‹¤ì›€\nğŸ›ï¸ **ì‹œë¨¼ë”©** - ì Šì€ì´ë“¤ì˜ ì‡¼í•‘ ì²œêµ­\n\nì¼ì •ì„ ê³„íší•´ ë“œë¦´ê¹Œìš”?',
      'ì˜¤ëŠ˜ ì–´ë”” ê°ˆê¹Œ': 'ì˜¤ëŠ˜ ë‚ ì”¨ì— ë”°ë¼:\n\nâ˜€ï¸ ë§‘ìœ¼ë©´ â†’ ìƒ¹ì‚°, ì–‘ë°ì‚°\nğŸŒ§ï¸ ë¹„ì˜¤ë©´ â†’ ê³ ê¶ë°•ë¬¼ê´€, ì—ìŠ¬ë¼ì´íŠ¸ ì„œì \nğŸŒ™ ì €ë…ì— â†’ ë¼ì˜¤í—ˆ ì•¼ì‹œì¥, ìŠ¤ë¦° ì•¼ì‹œì¥\n\nì•¼ì™¸ì™€ ì‹¤ë‚´ ì¤‘ ì–´ë–¤ ê±¸ ì„ í˜¸í•˜ì„¸ìš”?',
      'ê·¼ì²˜ ë³¼ê±°ë¦¬': 'ìœ„ì¹˜ ê¸°ë°˜ìœ¼ë¡œ ì¶”ì²œí•´ ë“œë¦´ ìˆ˜ ìˆì–´ìš”!\n\n"ìœ„ì¹˜" íƒ­ì—ì„œ ìœ„ì¹˜ ê¶Œí•œì„ í™œì„±í™”í•˜ë©´, ê·¼ì²˜ì˜ ì¸ê¸° ëª…ì†Œ, ë§›ì§‘, í™œë™ì„ ì°¾ì•„ë“œë¦½ë‹ˆë‹¤.\n\nì•„ë‹ˆë©´ ì§€ê¸ˆ ì–´ëŠ ì§€ì—­ì— ê³„ì‹ ì§€ ì•Œë ¤ì£¼ì„¸ìš”.',
      'ë§›ì§‘ ì¶”ì²œ': 'ëŒ€ë§Œ ìŒì‹ì€ ì •ë§ ë§›ìˆì–´ìš”! ê¼­ ë¨¹ì–´ì•¼ í•  ë¦¬ìŠ¤íŠ¸:\n\nğŸœ **ë”˜íƒ€ì´í‘ ìƒ¤ì˜¤ë¡±ë°”ì˜¤** - ì„¸ê³„ì ìœ¼ë¡œ ìœ ëª…\nğŸ§‹ **ë²„ë¸”í‹°** - ëŒ€ë§Œì˜ êµ­ë¯¼ ìŒë£Œ\nğŸ¥Ÿ **êµ´ì „** - ì•¼ì‹œì¥ ëŒ€í‘œ\nğŸ– **ë£¨ë¡œìš°íŒ** - ì €ë ´í•œ ë³„ë¯¸\nğŸ§ **íƒ€ë¡œë³¼** - ì¸ê¸° ë””ì €íŠ¸\n\nì–´ë””ì„œ ë¨¹ì„ ìˆ˜ ìˆëŠ”ì§€ ì•Œë ¤ë“œë¦´ê¹Œìš”?',
      'default': 'ë©”ì‹œì§€ë¥¼ ë°›ì•˜ìŠµë‹ˆë‹¤! ì—¬í–‰ ë„ìš°ë¯¸ë¡œì„œ:\n\nâ€¢ ì¸ê¸° ê´€ê´‘ì§€ ì¶”ì²œ\nâ€¢ ë‹¹ì¼ì¹˜ê¸° ì—¬í–‰ ê³„íš\nâ€¢ ê·¼ì²˜ ë§›ì§‘ ì°¾ê¸°\nâ€¢ ì—¬í–‰ íŒ ì œê³µ\n\nì–´ë””ë¡œ ê°€ê³  ì‹¶ìœ¼ì„¸ìš”?',
    },
  },
};

export function ChatScreen() {
  const { state } = useApp();
  const scrollViewRef = useRef<ScrollView>(null);
  const [messages, setMessages] = useState<Message[]>([]);
  const [inputText, setInputText] = useState('');
  const [isTyping, setIsTyping] = useState(false);

  const texts = translations[state.language] || translations['zh-TW'];

  useEffect(() => {
    setMessages([{
      id: '1',
      text: texts.welcome,
      sender: 'assistant',
      timestamp: new Date(),
    }]);
  }, [state.language]);

  const getResponse = (userMessage: string): string => {
    const responses = texts.responses;
    return responses[userMessage as keyof typeof responses] || responses['default'];
  };

  const simulateAIResponse = (userMessage: string) => {
    setIsTyping(true);
    
    setTimeout(() => {
      const response = getResponse(userMessage);
      
      const newMessage: Message = {
        id: Date.now().toString(),
        text: response,
        sender: 'assistant',
        timestamp: new Date(),
      };
      
      setMessages(prev => [...prev, newMessage]);
      setIsTyping(false);
    }, 1000 + Math.random() * 1000);
  };

  const handleSend = () => {
    if (!inputText.trim()) return;

    const userMessage: Message = {
      id: Date.now().toString(),
      text: inputText.trim(),
      sender: 'user',
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    setInputText('');
    
    simulateAIResponse(inputText.trim());
  };

  const handleQuickReply = (text: string) => {
    const userMessage: Message = {
      id: Date.now().toString(),
      text: text,
      sender: 'user',
      timestamp: new Date(),
    };

    setMessages(prev => [...prev, userMessage]);
    simulateAIResponse(text);
  };

  const formatTime = (date: Date) => {
    return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  };

  return (
    <KeyboardAvoidingView 
      style={styles.container} 
      behavior={Platform.OS === 'ios' ? 'padding' : undefined}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
    >
      <View style={styles.header}>
        <View style={styles.headerIcon}>
          <Ionicons name="chatbubbles" size={24} color="#ffffff" />
        </View>
        <View style={styles.headerInfo}>
          <Text style={styles.headerTitle}>{texts.assistantName}</Text>
          <Text style={styles.headerStatus}>
            {isTyping ? texts.typing : texts.online}
          </Text>
        </View>
      </View>

      <ScrollView 
        ref={scrollViewRef}
        style={styles.messagesContainer}
        contentContainerStyle={styles.messagesContent}
        onContentSizeChange={() => scrollViewRef.current?.scrollToEnd({ animated: true })}
      >
        {messages.map(message => (
          <View 
            key={message.id} 
            style={[
              styles.messageBubble,
              message.sender === 'user' ? styles.userBubble : styles.assistantBubble
            ]}
          >
            {message.sender === 'assistant' && (
              <View style={styles.avatarContainer}>
                <View style={styles.avatar}>
                  <Ionicons name="sparkles" size={16} color="#6366f1" />
                </View>
              </View>
            )}
            <View style={[
              styles.messageContent,
              message.sender === 'user' ? styles.userContent : styles.assistantContent
            ]}>
              <Text style={[
                styles.messageText,
                message.sender === 'user' ? styles.userText : styles.assistantText
              ]}>
                {message.text}
              </Text>
              <Text style={[
                styles.messageTime,
                message.sender === 'user' ? styles.userTime : styles.assistantTime
              ]}>
                {formatTime(message.timestamp)}
              </Text>
            </View>
          </View>
        ))}

        {isTyping && (
          <View style={[styles.messageBubble, styles.assistantBubble]}>
            <View style={styles.avatarContainer}>
              <View style={styles.avatar}>
                <Ionicons name="sparkles" size={16} color="#6366f1" />
              </View>
            </View>
            <View style={[styles.messageContent, styles.assistantContent, styles.typingIndicator]}>
              <ActivityIndicator size="small" color="#6366f1" />
              <Text style={styles.typingText}>{texts.typing}</Text>
            </View>
          </View>
        )}
      </ScrollView>

      {messages.length <= 2 && (
        <View style={styles.quickRepliesContainer}>
          <Text style={styles.quickRepliesLabel}>{texts.quickRepliesLabel}</Text>
          <ScrollView 
            horizontal 
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.quickRepliesScroll}
          >
            {texts.quickReplies.map(reply => (
              <TouchableOpacity
                key={reply.id}
                style={styles.quickReplyButton}
                onPress={() => handleQuickReply(reply.text)}
              >
                <Text style={styles.quickReplyText}>{reply.text}</Text>
              </TouchableOpacity>
            ))}
          </ScrollView>
        </View>
      )}

      <View style={styles.inputContainer}>
        <TextInput
          style={styles.input}
          placeholder={texts.placeholder}
          placeholderTextColor="#94a3b8"
          value={inputText}
          onChangeText={setInputText}
          multiline
          maxLength={500}
        />
        <TouchableOpacity 
          style={[styles.sendButton, !inputText.trim() && styles.sendButtonDisabled]}
          onPress={handleSend}
          disabled={!inputText.trim()}
        >
          <Ionicons name="send" size={20} color={inputText.trim() ? '#ffffff' : '#94a3b8'} />
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    paddingTop: Platform.OS === 'ios' ? 60 : 20,
    paddingBottom: 16,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
    gap: 12,
  },
  headerIcon: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: '#6366f1',
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerInfo: {
    flex: 1,
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  headerStatus: {
    fontSize: 13,
    color: '#22c55e',
  },
  messagesContainer: {
    flex: 1,
  },
  messagesContent: {
    padding: 16,
    paddingBottom: 24,
  },
  messageBubble: {
    flexDirection: 'row',
    marginBottom: 16,
    maxWidth: '85%',
  },
  userBubble: {
    alignSelf: 'flex-end',
  },
  assistantBubble: {
    alignSelf: 'flex-start',
  },
  avatarContainer: {
    marginRight: 8,
  },
  avatar: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: '#eef2ff',
    justifyContent: 'center',
    alignItems: 'center',
  },
  messageContent: {
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 12,
  },
  userContent: {
    backgroundColor: '#6366f1',
    borderBottomRightRadius: 4,
  },
  assistantContent: {
    backgroundColor: '#ffffff',
    borderBottomLeftRadius: 4,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  messageText: {
    fontSize: 15,
    lineHeight: 22,
  },
  userText: {
    color: '#ffffff',
  },
  assistantText: {
    color: '#1e293b',
  },
  messageTime: {
    fontSize: 11,
    marginTop: 6,
  },
  userTime: {
    color: 'rgba(255,255,255,0.7)',
    textAlign: 'right',
  },
  assistantTime: {
    color: '#94a3b8',
  },
  typingIndicator: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingVertical: 16,
  },
  typingText: {
    fontSize: 14,
    color: '#64748b',
  },
  quickRepliesContainer: {
    backgroundColor: '#ffffff',
    paddingTop: 12,
    paddingBottom: 8,
    borderTopWidth: 1,
    borderTopColor: '#f1f5f9',
  },
  quickRepliesLabel: {
    fontSize: 12,
    color: '#64748b',
    paddingHorizontal: 16,
    marginBottom: 8,
  },
  quickRepliesScroll: {
    paddingHorizontal: 12,
    gap: 8,
  },
  quickReplyButton: {
    backgroundColor: '#eef2ff',
    paddingHorizontal: 16,
    paddingVertical: 10,
    borderRadius: 20,
    borderWidth: 1,
    borderColor: '#c7d2fe',
    marginRight: 8,
  },
  quickReplyText: {
    fontSize: 14,
    color: '#6366f1',
    fontWeight: '500',
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'flex-end',
    backgroundColor: '#ffffff',
    paddingHorizontal: 16,
    paddingTop: 12,
    paddingBottom: Platform.OS === 'ios' ? 34 : 16,
    gap: 12,
    borderTopWidth: 1,
    borderTopColor: '#f1f5f9',
  },
  input: {
    flex: 1,
    backgroundColor: '#f1f5f9',
    borderRadius: 24,
    paddingHorizontal: 20,
    paddingVertical: 12,
    fontSize: 16,
    maxHeight: 100,
    color: '#1e293b',
  },
  sendButton: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: '#6366f1',
    justifyContent: 'center',
    alignItems: 'center',
  },
  sendButtonDisabled: {
    backgroundColor: '#e2e8f0',
  },
});

=== File: src/screens/CollectionScreen.tsx ===

import React, { useState, useMemo } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  Linking,
  Modal,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../context/AppContext';
import { GachaItem, Language } from '../types';
import { getCategoryLabel } from '../constants/translations';
import { MibuBrand, getCategoryToken, deriveMerchantScheme } from '../../constants/Colors';

const getPlaceName = (item: GachaItem): string => {
  const name = item.place_name;
  if (typeof name === 'string') return name;
  if (typeof name === 'object') {
    return (name as any)['en'] || (name as any)['zh-TW'] || '';
  }
  return '';
};

const getDescription = (item: GachaItem): string => {
  const desc = item.ai_description || item.description;
  if (typeof desc === 'string') return desc;
  if (typeof desc === 'object') {
    return (desc as any)['en'] || (desc as any)['zh-TW'] || '';
  }
  return '';
};

const formatDate = (dateStr: string | undefined): string => {
  if (!dateStr) return '';
  try {
    const date = new Date(dateStr);
    return `${date.getFullYear()}/${String(date.getMonth() + 1).padStart(2, '0')}/${String(date.getDate()).padStart(2, '0')}`;
  } catch {
    return '';
  }
};

interface PlaceDetailModalProps {
  item: GachaItem;
  language: Language;
  onClose: () => void;
}

function PlaceDetailModal({ item, language, onClose }: PlaceDetailModalProps) {
  const placeName = getPlaceName(item);
  const description = getDescription(item);
  const category = typeof item.category === 'string' ? item.category.toLowerCase() : '';
  const categoryToken = getCategoryToken(category);
  const date = formatDate(item.collectedAt);
  const cityDisplay = item.cityDisplay || item.city || '';
  const districtDisplay = item.districtDisplay || item.district || '';

  const handleNavigate = () => {
    let url: string;
    if (item.location) {
      url = `https://www.google.com/maps/dir/?api=1&destination=${item.location.lat},${item.location.lng}`;
    } else {
      const query = [placeName, districtDisplay, cityDisplay].filter(Boolean).join(' ');
      url = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(query)}`;
    }
    Linking.openURL(url);
  };

  const locationText = [districtDisplay, cityDisplay].filter(Boolean).join(' â€¢ ') || cityDisplay;

  return (
    <Modal visible transparent animationType="slide">
      <TouchableOpacity
        style={{ flex: 1, backgroundColor: 'rgba(0, 0, 0, 0.4)', justifyContent: 'flex-end' }}
        activeOpacity={1}
        onPress={onClose}
      >
        <View 
          style={{ backgroundColor: MibuBrand.warmWhite, borderTopLeftRadius: 24, borderTopRightRadius: 24, maxHeight: '85%' }} 
          onStartShouldSetResponder={() => true}
        >
          <View style={{ height: 120, position: 'relative', backgroundColor: categoryToken.badge, borderTopLeftRadius: 24, borderTopRightRadius: 24 }}>
            <TouchableOpacity 
              style={{ position: 'absolute', top: 16, right: 16, width: 40, height: 40, backgroundColor: 'rgba(255,255,255,0.9)', borderRadius: 20, alignItems: 'center', justifyContent: 'center' }} 
              onPress={onClose}
            >
              <Ionicons name="close" size={24} color={MibuBrand.dark} />
            </TouchableOpacity>
            <View style={{ position: 'absolute', bottom: 16, left: 20, backgroundColor: 'rgba(255,255,255,0.3)', paddingHorizontal: 12, paddingVertical: 6, borderRadius: 20 }}>
              <Text style={{ fontSize: 12, fontWeight: '700', color: categoryToken.badgeText }}>
                {getCategoryLabel(category, language)}
              </Text>
            </View>
          </View>

          <ScrollView style={{ padding: 20 }}>
            <Text style={{ fontSize: 24, fontWeight: '900', color: MibuBrand.dark, marginBottom: 8 }}>{placeName}</Text>
            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 20 }}>
              <Text style={{ fontSize: 14, color: MibuBrand.brownLight }}>{date}</Text>
              {locationText && (
                <>
                  <Text style={{ marginHorizontal: 8, color: MibuBrand.tanLight }}>â€¢</Text>
                  <Text style={{ fontSize: 14, color: MibuBrand.brownLight }}>{locationText}</Text>
                </>
              )}
            </View>

            {description && (
              <Text style={{ fontSize: 16, color: MibuBrand.brownLight, lineHeight: 24, marginBottom: 20 }}>{description}</Text>
            )}

            <TouchableOpacity 
              style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'center', gap: 8, backgroundColor: MibuBrand.brown, paddingVertical: 16, borderRadius: 16 }} 
              onPress={handleNavigate}
            >
              <Ionicons name="navigate" size={20} color="#ffffff" />
              <Text style={{ fontSize: 16, fontWeight: '700', color: '#ffffff' }}>åœ¨ Google åœ°åœ–ä¸­æŸ¥çœ‹</Text>
            </TouchableOpacity>
          </ScrollView>
        </View>
      </TouchableOpacity>
    </Modal>
  );
}

export function CollectionScreen() {
  const { state, t } = useApp();
  const { collection, language } = state;
  const [openRegions, setOpenRegions] = useState<Set<string>>(new Set());
  const [openCategories, setOpenCategories] = useState<Set<string>>(new Set());
  const [selectedItem, setSelectedItem] = useState<GachaItem | null>(null);

  const toggleRegion = (region: string) => {
    setOpenRegions(prev => {
      const newSet = new Set(prev);
      if (newSet.has(region)) newSet.delete(region);
      else newSet.add(region);
      return newSet;
    });
  };

  const toggleCategory = (key: string) => {
    setOpenCategories(prev => {
      const newSet = new Set(prev);
      if (newSet.has(key)) {
        newSet.delete(key);
      } else {
        const regionPrefix = key.split('-')[0];
        prev.forEach(existingKey => {
          if (existingKey.startsWith(regionPrefix + '-')) {
            newSet.delete(existingKey);
          }
        });
        newSet.add(key);
      }
      return newSet;
    });
  };

  const groupedData = useMemo(() => {
    const cityMap: Record<string, { displayName: string; items: GachaItem[]; byCategory: Record<string, GachaItem[]> }> = {};

    collection.forEach(item => {
      const city = item.city || 'Unknown';
      const cityDisplay = item.cityDisplay || city;
      const category = (typeof item.category === 'string' ? item.category : '').toLowerCase() || 'other';

      if (!cityMap[city]) {
        cityMap[city] = { displayName: cityDisplay, items: [], byCategory: {} };
      }
      cityMap[city].items.push(item);

      if (!cityMap[city].byCategory[category]) {
        cityMap[city].byCategory[category] = [];
      }
      cityMap[city].byCategory[category].push(item);
    });

    return cityMap;
  }, [collection]);

  if (collection.length === 0) {
    return (
      <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 40, backgroundColor: MibuBrand.creamLight }}>
        <Ionicons name="location-outline" size={64} color={MibuBrand.tanLight} />
        <Text style={{ fontSize: 18, fontWeight: '700', color: MibuBrand.brownLight, marginTop: 16 }}>{t.noCollection}</Text>
        <Text style={{ fontSize: 14, color: MibuBrand.tan, marginTop: 8 }}>{t.startToCollect}</Text>
      </View>
    );
  }

  return (
    <ScrollView 
      style={{ flex: 1, backgroundColor: MibuBrand.creamLight }} 
      contentContainerStyle={{ padding: 16, paddingTop: 60, paddingBottom: 100 }}
    >
      <Text style={{ fontSize: 28, fontWeight: '900', color: MibuBrand.dark, marginBottom: 16 }}>{t.myCollection}</Text>

      {Object.entries(groupedData)
        .sort((a, b) => b[1].items.length - a[1].items.length)
        .map(([regionKey, data]) => {
          const isRegionOpen = openRegions.has(regionKey);

          return (
            <View 
              key={regionKey} 
              style={{
                backgroundColor: MibuBrand.warmWhite,
                borderRadius: 16,
                borderWidth: 2,
                borderColor: MibuBrand.tanLight,
                marginBottom: 12,
                overflow: 'hidden',
              }}
            >
              <TouchableOpacity
                style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', padding: 16 }}
                onPress={() => toggleRegion(regionKey)}
              >
                <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>
                  <View style={{ width: 40, height: 40, backgroundColor: MibuBrand.brown, borderRadius: 12, alignItems: 'center', justifyContent: 'center' }}>
                    <Text style={{ color: '#ffffff', fontSize: 16, fontWeight: '900' }}>
                      {data.displayName.charAt(0)}
                    </Text>
                  </View>
                  <View>
                    <Text style={{ fontSize: 16, fontWeight: '700', color: MibuBrand.dark }}>{data.displayName}</Text>
                    <Text style={{ fontSize: 12, color: MibuBrand.brownLight }}>
                      {data.items.length} {t.spots}
                    </Text>
                  </View>
                </View>
                <Ionicons
                  name={isRegionOpen ? 'chevron-up' : 'chevron-down'}
                  size={20}
                  color={MibuBrand.brownLight}
                />
              </TouchableOpacity>

              {isRegionOpen && (
                <View style={{ paddingHorizontal: 16, paddingBottom: 16, gap: 8 }}>
                  {Object.entries(data.byCategory)
                    .sort((a, b) => b[1].length - a[1].length)
                    .map(([category, categoryItems]) => {
                      const catToken = getCategoryToken(category);
                      const categoryKey = `${regionKey}-${category}`;
                      const isCategoryOpen = openCategories.has(categoryKey);

                      return (
                        <View key={categoryKey}>
                          <TouchableOpacity
                            style={{
                              flexDirection: 'row',
                              alignItems: 'center',
                              justifyContent: 'space-between',
                              padding: 12,
                              borderRadius: 12,
                              backgroundColor: catToken.badge + '20',
                            }}
                            onPress={() => toggleCategory(categoryKey)}
                          >
                            <View style={{ flexDirection: 'row', alignItems: 'center', gap: 12 }}>
                              <View
                                style={{
                                  width: 6,
                                  height: 24,
                                  borderRadius: 3,
                                  backgroundColor: catToken.stripe,
                                }}
                              />
                              <Text style={{ fontSize: 14, fontWeight: '700', color: MibuBrand.dark }}>
                                {getCategoryLabel(category, language)}
                              </Text>
                              <View
                                style={{
                                  backgroundColor: catToken.badge,
                                  paddingHorizontal: 8,
                                  paddingVertical: 2,
                                  borderRadius: 10,
                                }}
                              >
                                <Text style={{ fontSize: 12, fontWeight: '700', color: catToken.badgeText }}>
                                  {categoryItems.length}
                                </Text>
                              </View>
                            </View>
                            <Ionicons
                              name={isCategoryOpen ? 'chevron-up' : 'chevron-down'}
                              size={16}
                              color={MibuBrand.brownLight}
                            />
                          </TouchableOpacity>

                          {isCategoryOpen && (
                            <View style={{ marginTop: 8, paddingLeft: 8, gap: 8 }}>
                              {categoryItems.map((item, idx) => {
                                const placeName = getPlaceName(item);
                                const description = getDescription(item);
                                const date = formatDate(item.collectedAt);

                                const hasPromo = item.is_promo_active || item.merchant;
                                const hasCoupon = item.is_coupon && item.coupon_data;
                                
                                const isMerchantPro = item.merchant?.isPro && item.merchant?.brandColor;
                                const merchantScheme = isMerchantPro 
                                  ? deriveMerchantScheme(item.merchant!.brandColor!) 
                                  : null;
                                const stripeColor = merchantScheme ? merchantScheme.accent : catToken.stripe;

                                return (
                                  <TouchableOpacity
                                    key={`${item.id}-${idx}`}
                                    style={{
                                      backgroundColor: MibuBrand.warmWhite,
                                      borderRadius: 16,
                                      overflow: 'hidden',
                                      flexDirection: 'row',
                                      shadowColor: MibuBrand.brown,
                                      shadowOffset: { width: 0, height: 2 },
                                      shadowOpacity: 0.06,
                                      shadowRadius: 8,
                                      elevation: 2,
                                    }}
                                    onPress={() => setSelectedItem(item)}
                                  >
                                    <View style={{ width: 4, backgroundColor: stripeColor }} />
                                    <View style={{ flex: 1, padding: 16 }}>
                                      <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8 }}>
                                        <Text style={{ fontSize: 12, color: MibuBrand.brownLight }}>{date}</Text>
                                        <View style={{ flexDirection: 'row', gap: 6 }}>
                                          {hasPromo && (
                                            <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: MibuBrand.copper, paddingHorizontal: 6, paddingVertical: 3, borderRadius: 6, gap: 3 }}>
                                              <Ionicons name="storefront" size={10} color="#ffffff" />
                                              <Text style={{ fontSize: 10, fontWeight: '700', color: '#ffffff' }}>
                                                {language === 'zh-TW' ? 'åˆä½œ' : 'Partner'}
                                              </Text>
                                            </View>
                                          )}
                                          {hasCoupon && (
                                            <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: MibuBrand.tierSP, paddingHorizontal: 6, paddingVertical: 3, borderRadius: 6, gap: 3 }}>
                                              <Ionicons name="ticket" size={10} color="#ffffff" />
                                              <Text style={{ fontSize: 10, fontWeight: '700', color: '#ffffff' }}>
                                                {language === 'zh-TW' ? 'å„ªæƒ ' : 'Coupon'}
                                              </Text>
                                            </View>
                                          )}
                                          <View
                                            style={{
                                              backgroundColor: catToken.badge,
                                              paddingHorizontal: 8,
                                              paddingVertical: 4,
                                              borderRadius: 8,
                                            }}
                                          >
                                            <Text style={{ fontSize: 10, fontWeight: '700', color: catToken.badgeText }}>
                                              {getCategoryLabel(category, language)}
                                            </Text>
                                          </View>
                                        </View>
                                      </View>
                                      <Text style={{ fontSize: 16, fontWeight: '900', color: merchantScheme ? merchantScheme.accent : MibuBrand.dark, marginBottom: 4 }}>{placeName}</Text>
                                      {description && (
                                        <Text
                                          style={{ fontSize: 14, color: MibuBrand.brownLight, lineHeight: 20 }}
                                          numberOfLines={2}
                                        >
                                          {description}
                                        </Text>
                                      )}
                                      {item.merchant && (
                                        <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 8, gap: 4 }}>
                                          <Ionicons name="business-outline" size={12} color={MibuBrand.copper} />
                                          <Text style={{ fontSize: 12, color: MibuBrand.copper, fontWeight: '600' }}>{item.merchant.name}</Text>
                                        </View>
                                      )}
                                    </View>
                                  </TouchableOpacity>
                                );
                              })}
                            </View>
                          )}
                        </View>
                      );
                    })}
                </View>
              )}
            </View>
          );
        })}

      {selectedItem && (
        <PlaceDetailModal
          item={selectedItem}
          language={language}
          onClose={() => setSelectedItem(null)}
        />
      )}
    </ScrollView>
  );
}

=== File: src/screens/GachaModuleScreen.tsx ===

import React, { useState } from 'react';
import { View, SafeAreaView } from 'react-native';
import { useApp } from '../context/AppContext';
import { GachaTopNav, GachaSubView } from '../components/ModuleNav';
import { GachaScreen } from './GachaScreen';
import { CollectionScreen } from './CollectionScreen';
import { ItemBoxScreen } from './ItemBoxScreen';

export function GachaModuleScreen() {
  const { state } = useApp();
  const [currentTab, setCurrentTab] = useState<GachaSubView>('gacha');
  const [hasNewCollection, setHasNewCollection] = useState(false);
  const [hasNewItems, setHasNewItems] = useState(false);

  const renderContent = () => {
    switch (currentTab) {
      case 'collection':
        return <CollectionScreen />;
      case 'itembox':
        return <ItemBoxScreen />;
      case 'gacha':
      default:
        return <GachaScreen />;
    }
  };

  return (
    <SafeAreaView style={{ flex: 1, backgroundColor: '#ffffff' }}>
      <GachaTopNav
        currentTab={currentTab}
        onChange={setCurrentTab}
        language={state.language}
        hasNewCollection={hasNewCollection}
        hasNewItems={hasNewItems}
      />
      <View style={{ flex: 1, backgroundColor: currentTab === 'gacha' ? '#f8fafc' : '#ffffff' }}>
        {renderContent()}
      </View>
    </SafeAreaView>
  );
}

=== File: src/screens/GachaScreen.tsx ===

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  View,
  Text,
  ScrollView,
  Alert,
  Modal,
  TouchableOpacity,
  Image,
  Dimensions,
  FlatList,
  ActivityIndicator,
} from 'react-native';
import Slider from '@react-native-community/slider';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { Button } from '../components/ui/Button';
import { Select } from '../components/ui/Select';
import { LoadingAdScreen } from '../components/LoadingAdScreen';
import { apiService } from '../services/api';
import { Country, Region, GachaItem, GachaPoolItem, GachaPoolResponse, RegionPoolCoupon, PrizePoolCoupon, PrizePoolResponse } from '../types';
import { MAX_DAILY_GENERATIONS, getCategoryColor } from '../constants/translations';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { MibuBrand } from '../../constants/Colors';
import { ErrorCode, ApiError } from '../shared/errors';

const UNLIMITED_EMAILS = ['s8869420@gmail.com'];

const DAILY_LIMIT_KEY = '@mibu_daily_limit';
const { width: SCREEN_WIDTH } = Dimensions.get('window');

const RARITY_COLORS: Record<string, string> = {
  SP: MibuBrand.tierSP,
  SSR: MibuBrand.tierSSR,
  SR: MibuBrand.tierSR,
  S: MibuBrand.tierS,
  R: MibuBrand.tierR,
  N: MibuBrand.tan,
};

const RARITY_BG_COLORS: Record<string, string> = {
  SP: MibuBrand.tierSPBg,
  SSR: MibuBrand.tierSSRBg,
  SR: MibuBrand.tierSRBg,
  S: MibuBrand.tierSBg,
  R: MibuBrand.tierRBg,
  N: MibuBrand.creamLight,
};

export function GachaScreen() {
  const router = useRouter();
  const { state, t, addToCollection, setResult } = useApp();
  const [countries, setCountries] = useState<Country[]>([]);
  const [regions, setRegions] = useState<Region[]>([]);
  const [selectedCountryId, setSelectedCountryId] = useState<number | null>(null);
  const [selectedRegionId, setSelectedRegionId] = useState<number | null>(null);
  const [pullCount, setPullCount] = useState(5);
  const [loadingCountries, setLoadingCountries] = useState(true);
  const [loadingRegions, setLoadingRegions] = useState(false);
  
  const [poolModalVisible, setPoolModalVisible] = useState(false);
  const [poolData, setPoolData] = useState<GachaPoolResponse | null>(null);
  const [loadingPool, setLoadingPool] = useState(false);
  const [couponPoolData, setCouponPoolData] = useState<RegionPoolCoupon[]>([]);
  const [prizePoolData, setPrizePoolData] = useState<PrizePoolResponse | null>(null);
  
  const [showLoadingAd, setShowLoadingAd] = useState(false);
  const [isApiComplete, setIsApiComplete] = useState(false);
  const pendingResultRef = useRef<any>(null);

  useEffect(() => {
    loadCountries();
  }, []);

  useEffect(() => {
    if (selectedCountryId) {
      loadRegions(selectedCountryId);
    }
  }, [selectedCountryId]);

  const loadCountries = async () => {
    try {
      const data = await apiService.getCountries();
      setCountries(data);
    } catch (error) {
      console.error('Failed to load countries:', error);
    } finally {
      setLoadingCountries(false);
    }
  };

  const loadRegions = async (countryId: number) => {
    setLoadingRegions(true);
    try {
      const data = await apiService.getRegions(countryId);
      setRegions(data);
    } catch (error) {
      console.error('Failed to load regions:', error);
    } finally {
      setLoadingRegions(false);
    }
  };

  const getLocalizedName = (item: Country | Region | { nameZh?: string; nameEn?: string; nameJa?: string; nameKo?: string; name?: string }): string => {
    switch (state.language) {
      case 'ja': return (item as any).nameJa || (item as any).nameZh || (item as any).nameEn || (item as any).name || '';
      case 'ko': return (item as any).nameKo || (item as any).nameZh || (item as any).nameEn || (item as any).name || '';
      case 'en': return (item as any).nameEn || (item as any).name || '';
      default: return (item as any).nameZh || (item as any).nameEn || (item as any).name || '';
    }
  };

  const getLocalizedPoolItemName = (name: any): string => {
    if (typeof name === 'string') return name;
    if (typeof name === 'object' && name !== null) {
      return name[state.language] || name['zh-TW'] || name['en'] || '';
    }
    return '';
  };

  const checkDailyLimit = async (): Promise<boolean> => {
    if (state.user?.email && UNLIMITED_EMAILS.includes(state.user.email)) {
      return true;
    }
    
    try {
      const today = new Date().toISOString().split('T')[0];
      const stored = await AsyncStorage.getItem(DAILY_LIMIT_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed.date === today && parsed.count >= MAX_DAILY_GENERATIONS) {
          return false;
        }
      }
      return true;
    } catch {
      return true;
    }
  };

  const incrementDailyCount = async () => {
    try {
      const today = new Date().toISOString().split('T')[0];
      const stored = await AsyncStorage.getItem(DAILY_LIMIT_KEY);
      let count = 1;
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed.date === today) {
          count = parsed.count + 1;
        }
      }
      await AsyncStorage.setItem(DAILY_LIMIT_KEY, JSON.stringify({ date: today, count }));
    } catch (error) {
      console.error('Failed to increment daily count:', error);
    }
  };

  const handleViewPool = async () => {
    if (!selectedRegionId) return;
    
    const selectedRegion = regions.find(r => r.id === selectedRegionId);
    if (!selectedRegion) return;
    
    setLoadingPool(true);
    setPoolModalVisible(true);
    setPoolData(null);
    setCouponPoolData([]);
    setPrizePoolData(null);
    
    try {
      const city = selectedRegion.nameZh || selectedRegion.nameEn || '';
      const token = await AsyncStorage.getItem('@mibu_token');
      
      const [poolResult, couponResult, prizePoolResult] = await Promise.allSettled([
        apiService.getGachaPool(city),
        token ? apiService.getRegionCouponPool(token, selectedRegionId) : Promise.resolve([]),
        apiService.getPrizePool(selectedRegionId)
      ]);
      
      if (poolResult.status === 'fulfilled') {
        setPoolData(poolResult.value);
      }
      if (couponResult.status === 'fulfilled') {
        const couponData = couponResult.value as any;
        setCouponPoolData(Array.isArray(couponData) ? couponData : (couponData?.coupons || []));
      }
      if (prizePoolResult.status === 'fulfilled') {
        setPrizePoolData(prizePoolResult.value);
      }
    } catch (error) {
      console.error('Failed to load pool:', error);
      setPoolData(null);
    } finally {
      setLoadingPool(false);
    }
  };

  const handleGacha = async () => {
    if (!selectedCountryId || !selectedRegionId) return;

    const canPull = await checkDailyLimit();
    if (!canPull) {
      Alert.alert(t.dailyLimitReached, t.dailyLimitReachedDesc);
      return;
    }

    setShowLoadingAd(true);
    setIsApiComplete(false);
    pendingResultRef.current = null;

    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      const selectedRegion = regions.find(r => r.id === selectedRegionId);
      console.log('[Gacha] API Request:', {
        endpoint: '/api/gacha/itinerary/v3',
        regionId: selectedRegionId,
        regionName: selectedRegion?.name || selectedRegion?.nameZh,
        itemCount: pullCount,
        hasToken: !!token
      });
      const response = await apiService.generateItinerary({
        regionId: selectedRegionId,
        itemCount: pullCount,
      }, token || undefined);

      console.log('[Gacha] API Response:', {
        success: response.success,
        hasItinerary: !!(response.itinerary),
        itineraryLength: response.itinerary?.length || 0,
        errorCode: response.errorCode,
        error: response.error,
        targetDistrict: response.targetDistrict,
        city: response.city
      });

      if (!response.success && (response.errorCode || response.error || (response as any).code)) {
        setShowLoadingAd(false);
        const errorCode = response.errorCode || (response as any).code;
        
        if (errorCode === ErrorCode.AUTH_REQUIRED || errorCode === ErrorCode.AUTH_TOKEN_EXPIRED) {
          await AsyncStorage.removeItem('@mibu_token');
          Alert.alert(
            state.language === 'zh-TW' ? 'ç™»å…¥å·²éæœŸ' : 'Session Expired',
            state.language === 'zh-TW' ? 'è«‹é‡æ–°ç™»å…¥' : 'Please login again'
          );
          router.push('/login');
          return;
        }
        
        if (errorCode === ErrorCode.GACHA_NO_CREDITS) {
          Alert.alert(
            state.language === 'zh-TW' ? 'æ¬¡æ•¸ä¸è¶³' : 'No Credits',
            state.language === 'zh-TW' ? 'è«‹è³¼è²·æ›´å¤šæ‰­è›‹æ¬¡æ•¸' : 'Please purchase more gacha credits'
          );
          return;
        }

        if (errorCode === 'DAILY_LIMIT_EXCEEDED') {
          Alert.alert(
            state.language === 'zh-TW' ? 'ä»Šæ—¥é¡åº¦å·²ç”¨å®Œ' : 'Daily Limit Reached',
            state.language === 'zh-TW' ? 'è«‹æ˜å¤©å†ä¾†æŠ½å¡ï¼' : 'Please come back tomorrow!'
          );
          return;
        }

        if (errorCode === 'EXCEEDS_REMAINING_QUOTA') {
          const remaining = (response as any).remainingQuota || 0;
          Alert.alert(
            state.language === 'zh-TW' ? 'é¡åº¦ä¸è¶³' : 'Quota Exceeded',
            state.language === 'zh-TW' ? `ä»Šæ—¥å‰©é¤˜ ${remaining} å¼µ` : `Today's remaining quota: ${remaining}`
          );
          return;
        }
        
        const errorMessage = response.message || response.error || (state.language === 'zh-TW' ? 'è©²å€åŸŸæš«ç„¡æ™¯é»' : 'No places available in this area');
        Alert.alert(
          state.language === 'zh-TW' ? 'æç¤º' : 'Notice',
          errorMessage
        );
        return;
      }

      const itineraryItems = response.itinerary || [];
      if (!itineraryItems || itineraryItems.length === 0) {
        setShowLoadingAd(false);
        Alert.alert(
          state.language === 'zh-TW' ? 'æç¤º' : 'Notice',
          state.language === 'zh-TW' ? 'è©²å€åŸŸæš«ç„¡æ™¯é»ï¼Œè«‹å˜—è©¦å…¶ä»–åœ°å€' : 'No places available in this area. Please try another region.'
        );
        return;
      }

      const couponsWon = response.couponsWon || response.coupons_won || [];

      const items: GachaItem[] = itineraryItems.map((item: any, index: number) => {
        const hasMerchantCoupon = item.isCoupon || item.is_coupon || (item.merchantPromo?.isPromoActive && item.couponData);
        
        return {
          id: Date.now() + index,
          place_name: item.placeName || item.place_name || item.verifiedName || `${item.district || response.anchorDistrict || ''} ${item.subCategory || ''}`,
          description: item.description || `${item.city || ''} ${item.district || ''}`,
          ai_description: item.description || '',
          category: item.category || '',
          suggested_time: item.suggestedTime || item.timeSlot || '',
          duration: item.duration || '1h',
          search_query: '',
          color_hex: item.colorHex || '#6366f1',
          country: item.country || response.country || '',
          city: item.city || response.meta?.city || response.city || '',
          cityDisplay: item.city || response.meta?.city || response.city || '',
          district: item.district || response.meta?.district || response.anchorDistrict || response.targetDistrict || '',
          districtDisplay: item.district || response.meta?.district || response.anchorDistrict || response.targetDistrict || '',
          collectedAt: new Date().toISOString(),
          is_coupon: hasMerchantCoupon,
          coupon_data: item.couponData || item.coupon_data || null,
          place_id: item.placeId || null,
          verified_name: item.verifiedName || item.placeName || null,
          verified_address: item.verifiedAddress || null,
          google_rating: item.googleRating || null,
          google_types: [],
          primary_type: null,
          location: item.location || null,
          is_location_verified: item.isLocationVerified || false,
          merchant: item.merchantPromo ? {
            id: item.merchantPromo?.merchantId || '',
            name: item.merchantPromo?.promoTitle || '',
            description: item.merchantPromo?.promoDescription,
            badge: item.merchantPromo?.badge,
            discount: item.merchantPromo?.discount,
          } : undefined,
          coupon: item.couponData || null,
          rarity: item.rarity || 'N',
        };
      });

      await incrementDailyCount();

      pendingResultRef.current = {
        items,
        meta: {
          date: new Date().toISOString().split('T')[0],
          country: response.country || '',
          city: response.meta?.city || response.city || '',
          locked_district: response.meta?.district || response.anchorDistrict || response.targetDistrict || '',
          user_level: pullCount,
          coupons_won: couponsWon.length,
          themeIntro: response.themeIntro,
          sortingMethod: response.meta?.sortingMethod || response.sortingMethod,
        },
        couponsWon,
      };

      setIsApiComplete(true);
    } catch (error) {
      console.error('Gacha failed:', error);
      setShowLoadingAd(false);
      Alert.alert(
        state.language === 'zh-TW' ? 'éŒ¯èª¤' : 'Error',
        state.language === 'zh-TW' ? 'ç”Ÿæˆè¡Œç¨‹å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Failed to generate itinerary. Please try again.'
      );
    }
  };

  const handleLoadingComplete = useCallback(() => {
    if (pendingResultRef.current) {
      const { items, meta } = pendingResultRef.current;
      
      addToCollection(items);

      setResult({
        status: 'success',
        meta,
        inventory: items,
      });

      setShowLoadingAd(false);
      
      router.push('/(tabs)/gacha/items');
    }
  }, [addToCollection, setResult, router]);

  const countryOptions = countries.map(c => ({
    label: getLocalizedName(c),
    value: c.id,
  }));

  const regionOptions = regions.map(r => ({
    label: getLocalizedName(r),
    value: r.id,
  }));

  const canSubmit = selectedCountryId && selectedRegionId;

  const renderPoolItem = ({ item }: { item: GachaPoolItem }) => {
    const rarity = item.rarity || 'N';
    const rarityColor = RARITY_COLORS[rarity] || RARITY_COLORS.N;
    const rarityBg = RARITY_BG_COLORS[rarity] || RARITY_BG_COLORS.N;
    
    return (
      <View
        style={{
          width: (SCREEN_WIDTH - 60) / 2,
          backgroundColor: '#ffffff',
          borderRadius: 16,
          marginBottom: 12,
          marginHorizontal: 6,
          overflow: 'hidden',
          borderWidth: 2,
          borderColor: rarityBg,
        }}
      >
        {item.imageUrl ? (
          <Image
            source={{ uri: item.imageUrl }}
            style={{ width: '100%', height: 100 }}
            resizeMode="cover"
          />
        ) : (
          <View
            style={{
              width: '100%',
              height: 100,
              backgroundColor: getCategoryColor(item.category),
              alignItems: 'center',
              justifyContent: 'center',
            }}
          >
            <Ionicons name="location" size={32} color="#ffffff" />
          </View>
        )}
        
        <View style={{ padding: 12 }}>
          <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 4 }}>
            <View
              style={{
                backgroundColor: rarityBg,
                paddingHorizontal: 8,
                paddingVertical: 2,
                borderRadius: 8,
                marginRight: 6,
              }}
            >
              <Text style={{ fontSize: 10, fontWeight: '800', color: rarityColor }}>
                {rarity}
              </Text>
            </View>
            <Text
              style={{ fontSize: 10, color: getCategoryColor(item.category), fontWeight: '600' }}
              numberOfLines={1}
            >
              {item.category}
            </Text>
          </View>
          
          <Text
            style={{ fontSize: 13, fontWeight: '700', color: '#1e293b' }}
            numberOfLines={2}
          >
            {getLocalizedPoolItemName(item.name)}
          </Text>
          
          {item.merchant && (
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                marginTop: 6,
                backgroundColor: '#fef3c7',
                paddingHorizontal: 6,
                paddingVertical: 3,
                borderRadius: 6,
              }}
            >
              <Ionicons name="star" size={10} color="#f59e0b" />
              <Text style={{ fontSize: 10, color: '#b45309', marginLeft: 4, fontWeight: '600' }}>
                {t.merchant || 'ç‰¹ç´„å•†å®¶'}
              </Text>
            </View>
          )}
        </View>
      </View>
    );
  };

  const getJackpotItems = () => {
    if (!poolData?.pool?.jackpots) return [];
    return poolData.pool.jackpots;
  };

  return (
    <ScrollView
      style={{ flex: 1, backgroundColor: '#f8fafc' }}
      contentContainerStyle={{ padding: 20, paddingTop: 20 }}
    >
      <View style={{ alignItems: 'center', marginBottom: 32 }}>
        <Text style={{ fontSize: 32, fontWeight: '900', color: '#1e293b', letterSpacing: -0.5 }}>
          {t.appTitle}
        </Text>
        {state.user?.firstName && (
          <Text style={{ fontSize: 14, color: '#94a3b8', marginTop: 8 }}>
            {state.language === 'zh-TW' ? `æ­¡è¿å›ä¾†, ${state.user.firstName}` : `Welcome back, ${state.user.firstName}`}
          </Text>
        )}
      </View>

      <View style={{ gap: 16 }}>
        <Select
          label={state.language === 'zh-TW' ? 'é¸æ“‡æ¢ç´¢åœ‹å®¶' : t.destination}
          options={countryOptions}
          value={selectedCountryId}
          onChange={(value) => {
            setSelectedCountryId(value as number);
            setSelectedRegionId(null);
            setRegions([]);
          }}
          placeholder={t.selectCountry}
          loading={loadingCountries}
        />

        {selectedCountryId && (
          <Select
            label={state.language === 'zh-TW' ? 'é¸æ“‡åŸå¸‚/åœ°å€' : t.selectRegion}
            options={regionOptions}
            value={selectedRegionId}
            onChange={(value) => {
              setSelectedRegionId(value as number);
            }}
            placeholder={t.selectRegion}
            loading={loadingRegions}
          />
        )}

        {selectedRegionId && (
          <View style={{ backgroundColor: '#ffffff', borderRadius: 16, padding: 16 }}>
            <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 12 }}>
              <Text style={{ fontSize: 14, fontWeight: '600', color: '#64748b' }}>
                {state.language === 'zh-TW' ? 'æŠ½å–å¼µæ•¸' : (t.pullCount || 'Pull Count')}
              </Text>
              <TouchableOpacity
                onPress={() => {
                  Alert.alert(
                    state.language === 'zh-TW' ? 'æŠ½å–å¼µæ•¸èªªæ˜' : 'Pull Count Info',
                    state.language === 'zh-TW' 
                      ? 'æ¯æ¬¡æ‰­è›‹å¯æŠ½å– 5-12 å¼µæ™¯é»å¡ç‰‡ã€‚å¼µæ•¸è¶Šå¤šï¼Œè¡Œç¨‹è¶Šè±å¯Œï¼æ¯æ—¥ä¸Šé™ 36 å¼µã€‚'
                      : 'You can draw 5-12 place cards per gacha. More cards mean a richer itinerary! Daily limit is 36 cards.'
                  );
                }}
                style={{ 
                  width: 24, 
                  height: 24, 
                  borderRadius: 12, 
                  backgroundColor: '#e2e8f0', 
                  alignItems: 'center', 
                  justifyContent: 'center' 
                }}
              >
                <Ionicons name="information-circle-outline" size={18} color="#6366f1" />
              </TouchableOpacity>
            </View>
            <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', marginBottom: 8 }}>
              <Text style={{ fontSize: 12, color: '#94a3b8' }}>5</Text>
              <Text style={{ fontSize: 24, fontWeight: '800', color: '#6366f1' }}>
                {pullCount} {t.pulls || 'å¼µ'}
              </Text>
              <Text style={{ fontSize: 12, color: '#94a3b8' }}>12</Text>
            </View>
            <Slider
              style={{ width: '100%', height: 40 }}
              minimumValue={5}
              maximumValue={12}
              step={1}
              value={pullCount}
              onValueChange={(value) => setPullCount(Math.round(value))}
              minimumTrackTintColor="#6366f1"
              maximumTrackTintColor="#e2e8f0"
              thumbTintColor="#6366f1"
            />
          </View>
        )}

        <Button
          title={t.startGacha}
          onPress={handleGacha}
          disabled={!canSubmit || showLoadingAd}
          style={{ marginTop: 8 }}
        />
      </View>

      <Modal
        visible={poolModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => setPoolModalVisible(false)}
      >
        <View
          style={{
            flex: 1,
            backgroundColor: 'rgba(0, 0, 0, 0.5)',
            justifyContent: 'flex-end',
          }}
        >
          <View
            style={{
              backgroundColor: '#ffffff',
              borderTopLeftRadius: 24,
              borderTopRightRadius: 24,
              maxHeight: '85%',
              minHeight: '60%',
            }}
          >
            <View
              style={{
                flexDirection: 'row',
                alignItems: 'center',
                justifyContent: 'space-between',
                padding: 20,
                borderBottomWidth: 1,
                borderBottomColor: '#f1f5f9',
              }}
            >
              <Text style={{ fontSize: 18, fontWeight: '800', color: '#1e293b' }}>
                {t.poolPreview || 'çæ± é è¦½'}
              </Text>
              <TouchableOpacity
                onPress={() => setPoolModalVisible(false)}
                style={{
                  width: 32,
                  height: 32,
                  borderRadius: 16,
                  backgroundColor: '#f1f5f9',
                  alignItems: 'center',
                  justifyContent: 'center',
                }}
              >
                <Ionicons name="close" size={20} color="#64748b" />
              </TouchableOpacity>
            </View>

            {loadingPool ? (
              <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', padding: 40 }}>
                <ActivityIndicator size="large" color="#6366f1" />
                <Text style={{ marginTop: 16, color: '#64748b', fontSize: 14 }}>
                  {t.loadingPool || 'è¼‰å…¥çæ± ä¸­...'}
                </Text>
              </View>
            ) : (
              <ScrollView style={{ flex: 1 }} showsVerticalScrollIndicator={false}>
                {((prizePoolData?.coupons?.length || 0) > 0 || (Array.isArray(couponPoolData) ? couponPoolData.length : 0) > 0) ? (
                  <View style={{ paddingHorizontal: 16, paddingTop: 16, paddingBottom: 40 }}>
                    {(prizePoolData?.region?.name || poolData?.pool?.city) && (
                      <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 16 }}>
                        <Ionicons name="location" size={16} color="#6366f1" />
                        <Text style={{ fontSize: 13, color: '#6366f1', marginLeft: 6, fontWeight: '600' }}>
                          {prizePoolData?.region?.name || poolData?.pool?.city}
                        </Text>
                      </View>
                    )}
                    
                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 12 }}>
                      <Ionicons name="ticket" size={18} color="#d97706" />
                      <Text style={{ fontSize: 14, fontWeight: '700', color: '#d97706', marginLeft: 6 }}>
                        {state.language === 'zh-TW' ? 'SP/SSR ç¨€æœ‰å„ªæƒ åˆ¸' : 'SP/SSR Rare Coupons'} ({(prizePoolData?.coupons?.length || 0) + (Array.isArray(couponPoolData) ? couponPoolData.length : 0)})
                      </Text>
                    </View>
                    
                    {prizePoolData?.coupons?.map((coupon) => (
                      <View
                        key={`prize-${coupon.id}`}
                        style={{
                          backgroundColor: coupon.rarity === 'SP' ? '#fef3c7' : '#ddd6fe',
                          borderRadius: 12,
                          padding: 14,
                          marginBottom: 10,
                          borderWidth: 2,
                          borderColor: coupon.rarity === 'SP' ? '#f59e0b' : '#8b5cf6',
                        }}
                      >
                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6 }}>
                          <View
                            style={{
                              backgroundColor: coupon.rarity === 'SP' ? '#f59e0b' : '#8b5cf6',
                              paddingHorizontal: 8,
                              paddingVertical: 3,
                              borderRadius: 6,
                              marginRight: 8,
                            }}
                          >
                            <Text style={{ fontSize: 11, fontWeight: '800', color: '#ffffff' }}>
                              {coupon.rarity}
                            </Text>
                          </View>
                        </View>
                        
                        <Text style={{ fontSize: 14, fontWeight: '700', color: '#1e293b', marginBottom: 4 }}>
                          {coupon.title}
                        </Text>
                        
                        <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                          <Ionicons name="location-outline" size={12} color="#94a3b8" />
                          <Text style={{ fontSize: 11, color: '#94a3b8', marginLeft: 4 }}>
                            {coupon.placeName}
                          </Text>
                        </View>
                      </View>
                    ))}
                    
                    {(Array.isArray(couponPoolData) ? couponPoolData : []).map((coupon) => (
                      <View
                        key={`coupon-${coupon.id}`}
                        style={{
                          backgroundColor: coupon.rarity === 'SSR' ? '#fef3c7' : '#f3e8ff',
                          borderRadius: 12,
                          padding: 14,
                          marginBottom: 10,
                          borderWidth: 2,
                          borderColor: coupon.rarity === 'SSR' ? '#fbbf24' : '#a855f7',
                        }}
                      >
                        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6 }}>
                          <View
                            style={{
                              backgroundColor: coupon.rarity === 'SSR' ? '#fbbf24' : '#a855f7',
                              paddingHorizontal: 8,
                              paddingVertical: 3,
                              borderRadius: 6,
                              marginRight: 8,
                            }}
                          >
                            <Text style={{ fontSize: 11, fontWeight: '800', color: '#ffffff' }}>
                              {coupon.rarity}
                            </Text>
                          </View>
                          {coupon.discount && (
                            <View
                              style={{
                                backgroundColor: '#ef4444',
                                paddingHorizontal: 6,
                                paddingVertical: 2,
                                borderRadius: 4,
                              }}
                            >
                              <Text style={{ fontSize: 10, fontWeight: '700', color: '#ffffff' }}>
                                {coupon.discount}
                              </Text>
                            </View>
                          )}
                        </View>
                        
                        <Text style={{ fontSize: 14, fontWeight: '700', color: '#1e293b', marginBottom: 2 }}>
                          {coupon.title}
                        </Text>
                        
                        {coupon.merchantName && (
                          <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                            <Ionicons name="storefront-outline" size={12} color="#94a3b8" />
                            <Text style={{ fontSize: 11, color: '#94a3b8', marginLeft: 4 }}>
                              {coupon.merchantName}
                            </Text>
                          </View>
                        )}
                      </View>
                    ))}
                  </View>
                ) : (
                  <View style={{ flex: 1, alignItems: 'center', justifyContent: 'center', paddingVertical: 60 }}>
                    <View
                      style={{
                        width: 80,
                        height: 80,
                        borderRadius: 40,
                        backgroundColor: '#fef3c7',
                        alignItems: 'center',
                        justifyContent: 'center',
                        marginBottom: 16,
                      }}
                    >
                      <Ionicons name="ticket-outline" size={40} color="#d97706" />
                    </View>
                    <Text style={{ fontSize: 14, color: '#94a3b8', textAlign: 'center' }}>
                      {state.language === 'zh-TW' ? 'æ­¤å€åŸŸå°šç„¡ç¨€æœ‰å„ªæƒ åˆ¸' : 'No rare coupons in this region'}
                    </Text>
                  </View>
                )}
              </ScrollView>
            )}
          </View>
        </View>
      </Modal>

      <LoadingAdScreen
        visible={showLoadingAd}
        onComplete={handleLoadingComplete}
        isApiComplete={isApiComplete}
        translations={{
          generatingItinerary: t.generatingItinerary || 'æ­£åœ¨ç”Ÿæˆè¡Œç¨‹...',
          sponsorAd: t.sponsorAd || 'è´ŠåŠ©å•†å»£å‘Š (æ¨¡æ“¬)',
          pleaseWait: t.pleaseWait || 'è«‹ç¨å€™',
          almostReady: t.almostReady || 'å³å°‡å®Œæˆ',
        }}
      />
    </ScrollView>
  );
}

=== File: src/screens/HomeScreen.tsx ===

import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../context/AppContext';
import { Card } from '../components/ui/Card';
import { MibuBrand } from '../../constants/Colors';

export function HomeScreen() {
  const { t } = useApp();

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <View style={styles.header}>
        <Text style={styles.title}>Mibu</Text>
        <Text style={styles.subtitle}>{t.appSubtitle}</Text>
      </View>

      <Card style={styles.announcementCard}>
        <View style={styles.cardHeader}>
          <Ionicons name="megaphone" size={24} color={MibuBrand.brown} />
          <Text style={styles.cardTitle}>{t.announcements}</Text>
        </View>
        <View style={styles.announcementContent}>
          <Text style={styles.announcementText}>
            â€¢ æ­¡è¿ä½¿ç”¨ Mibu æ—…éŠæ‰­è›‹ï¼æ¢ç´¢å°ç£å„åœ°çš„ç²¾å½©æ™¯é»
          </Text>
          <Text style={styles.announcementText}>
            â€¢ æ–°åŠŸèƒ½ï¼šæ—…ç¨‹ç­–åŠƒæ¨¡çµ„å·²ä¸Šç·šï¼Œè¦åŠƒä½ çš„å®Œç¾è¡Œç¨‹
          </Text>
        </View>
      </Card>

      <Card style={styles.flashCard}>
        <View style={styles.cardHeader}>
          <Ionicons name="flash" size={24} color="#ffffff" />
          <Text style={[styles.cardTitle, { color: '#ffffff' }]}>{t.flashEvents}</Text>
        </View>
        <View style={styles.announcementContent}>
          <Text style={[styles.announcementText, { color: 'rgba(255,255,255,0.95)' }]}>
            ğŸ å†¬å­£é™å®šï¼šå®œè˜­ç¤æºªæº«æ³‰å­£ - æ”¶é›†æº«æ³‰æ™¯é»ç²å¾—ç‰¹åˆ¥å„ªæƒ ï¼
          </Text>
          <Text style={[styles.announcementText, { color: 'rgba(255,255,255,0.95)' }]}>
            ğŸŒŸ æœ¬é€±ç†±é–€ï¼šå°åŒ—ä¿¡ç¾©å€è–èª•å¸‚é›†å·¡ç¦®
          </Text>
        </View>
      </Card>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  header: {
    alignItems: 'center',
    marginBottom: 24,
  },
  title: {
    fontSize: 36,
    fontWeight: '900',
    color: MibuBrand.brown,
    letterSpacing: -1,
  },
  subtitle: {
    fontSize: 16,
    color: MibuBrand.copper,
    marginTop: 4,
  },
  announcementCard: {
    backgroundColor: MibuBrand.highlight,
    borderWidth: 1,
    borderColor: MibuBrand.tan,
    marginBottom: 20,
    padding: 20,
  },
  flashCard: {
    backgroundColor: MibuBrand.brown,
    marginBottom: 24,
    padding: 20,
  },
  cardHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 10,
    marginBottom: 16,
  },
  cardTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: MibuBrand.brownDark,
  },
  announcementContent: {
    gap: 12,
  },
  announcementText: {
    fontSize: 16,
    color: MibuBrand.brownDark,
    lineHeight: 24,
  },
});

=== File: src/screens/ItemBoxScreen.tsx ===

import React, { useState, useEffect, useCallback } from 'react';
import { View, Text, ScrollView, TouchableOpacity, Modal, TextInput, Alert, ActivityIndicator, RefreshControl, Dimensions, Animated } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { InventoryItem, CouponTier } from '../types';
import { MibuBrand } from '../../constants/Colors';

const MAX_SLOTS = 30;
const GRID_COLS = 6;
const { width: SCREEN_WIDTH } = Dimensions.get('window');
const SLOT_SIZE = (SCREEN_WIDTH - 48) / GRID_COLS - 8;

const TIER_STYLES: Record<CouponTier, { borderColor: string; bgColor: string; glowColor: string; animate: boolean }> = {
  SP: { borderColor: MibuBrand.tierSP, bgColor: MibuBrand.tierSPBg, glowColor: 'rgba(212, 162, 76, 0.6)', animate: true },
  SSR: { borderColor: MibuBrand.tierSSR, bgColor: MibuBrand.tierSSRBg, glowColor: 'rgba(176, 136, 96, 0.4)', animate: false },
  SR: { borderColor: MibuBrand.tierSR, bgColor: MibuBrand.tierSRBg, glowColor: 'transparent', animate: false },
  S: { borderColor: MibuBrand.tierS, bgColor: MibuBrand.tierSBg, glowColor: 'transparent', animate: false },
  R: { borderColor: MibuBrand.tierR, bgColor: MibuBrand.tierRBg, glowColor: 'transparent', animate: false },
};

const TIER_ICONS: Record<CouponTier, string> = {
  SP: 'star',
  SSR: 'diamond',
  SR: 'trophy',
  S: 'ribbon',
  R: 'ticket',
};

interface InventorySlotProps {
  item: InventoryItem | null;
  index: number;
  onPress: (item: InventoryItem) => void;
  onLongPress: (item: InventoryItem) => void;
  language: string;
}

function InventorySlot({ item, index, onPress, onLongPress, language }: InventorySlotProps) {
  const [pulseAnim] = useState(new Animated.Value(1));

  useEffect(() => {
    if (item?.tier === 'SP') {
      const pulse = Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, { toValue: 1.05, duration: 800, useNativeDriver: true }),
          Animated.timing(pulseAnim, { toValue: 1, duration: 800, useNativeDriver: true }),
        ])
      );
      pulse.start();
      return () => pulse.stop();
    }
  }, [item?.tier, pulseAnim]);

  if (!item) {
    return (
      <View
        style={{
          width: SLOT_SIZE,
          height: SLOT_SIZE,
          margin: 4,
          borderRadius: 12,
          backgroundColor: '#f1f5f9',
          borderWidth: 2,
          borderColor: '#e2e8f0',
          borderStyle: 'dashed',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <Text style={{ fontSize: 10, color: '#cbd5e1' }}>{index + 1}</Text>
      </View>
    );
  }

  const tierStyle = TIER_STYLES[item.tier] || TIER_STYLES.R;
  const isExpired = item.isExpired || Boolean(item.expiresAt && new Date(item.expiresAt) < new Date());
  const isDisabled = item.status === 'redeemed' || item.status === 'deleted' || isExpired;

  const SlotContent = (
    <View
      style={{
        width: SLOT_SIZE,
        height: SLOT_SIZE,
        margin: 4,
        borderRadius: 12,
        backgroundColor: isDisabled ? '#e2e8f0' : tierStyle.bgColor,
        borderWidth: 3,
        borderColor: isDisabled ? '#9ca3af' : tierStyle.borderColor,
        alignItems: 'center',
        justifyContent: 'center',
        opacity: isDisabled ? 0.5 : 1,
        shadowColor: tierStyle.glowColor,
        shadowOffset: { width: 0, height: 0 },
        shadowOpacity: tierStyle.animate ? 1 : 0.5,
        shadowRadius: tierStyle.animate ? 10 : 4,
        elevation: tierStyle.animate ? 8 : 2,
        position: 'relative',
      }}
    >
      {!item.isRead && !isDisabled && (
        <View
          style={{
            position: 'absolute',
            top: -4,
            right: -4,
            width: 12,
            height: 12,
            borderRadius: 6,
            backgroundColor: '#ef4444',
            borderWidth: 2,
            borderColor: '#ffffff',
            zIndex: 10,
          }}
        />
      )}

      <Ionicons
        name={(TIER_ICONS[item.tier] || 'ticket') as any}
        size={20}
        color={isDisabled ? '#9ca3af' : tierStyle.borderColor}
      />

      <Text
        style={{
          fontSize: 8,
          fontWeight: '800',
          color: isDisabled ? '#9ca3af' : tierStyle.borderColor,
          marginTop: 2,
        }}
      >
        {item.tier}
      </Text>

      {isExpired && (
        <View
          style={{
            position: 'absolute',
            bottom: 2,
            backgroundColor: 'rgba(0,0,0,0.6)',
            paddingHorizontal: 4,
            paddingVertical: 1,
            borderRadius: 4,
          }}
        >
          <Text style={{ fontSize: 7, color: '#ffffff', fontWeight: '700' }}>
            {language === 'zh-TW' ? 'éæœŸ' : 'EXP'}
          </Text>
        </View>
      )}

      {item.status === 'redeemed' && (
        <View
          style={{
            position: 'absolute',
            bottom: 2,
            backgroundColor: 'rgba(22, 163, 74, 0.9)',
            paddingHorizontal: 4,
            paddingVertical: 1,
            borderRadius: 4,
          }}
        >
          <Text style={{ fontSize: 7, color: '#ffffff', fontWeight: '700' }}>
            {language === 'zh-TW' ? 'å·²ç”¨' : 'USED'}
          </Text>
        </View>
      )}
    </View>
  );

  if (item.tier === 'SP' && !isDisabled) {
    return (
      <TouchableOpacity
        onPress={() => onPress(item)}
        onLongPress={() => onLongPress(item)}
        disabled={isDisabled}
      >
        <Animated.View style={{ transform: [{ scale: pulseAnim }] }}>
          {SlotContent}
        </Animated.View>
      </TouchableOpacity>
    );
  }

  return (
    <TouchableOpacity
      onPress={() => onPress(item)}
      onLongPress={() => onLongPress(item)}
      disabled={isDisabled}
    >
      {SlotContent}
    </TouchableOpacity>
  );
}

export function ItemBoxScreen() {
  const { state, setUnreadCount } = useApp();
  const [items, setItems] = useState<InventoryItem[]>([]);
  const [slotCount, setSlotCount] = useState(0);
  const [maxSlots, setMaxSlots] = useState(MAX_SLOTS);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  
  const [selectedItem, setSelectedItem] = useState<InventoryItem | null>(null);
  const [detailModalVisible, setDetailModalVisible] = useState(false);
  const [redeemModalVisible, setRedeemModalVisible] = useState(false);
  const [deleteModalVisible, setDeleteModalVisible] = useState(false);
  const [redemptionCode, setRedemptionCode] = useState('');
  const [redeeming, setRedeeming] = useState(false);
  const [deleting, setDeleting] = useState(false);
  const [countdown, setCountdown] = useState<number | null>(null);
  const [redeemSuccess, setRedeemSuccess] = useState(false);

  const loadInventory = useCallback(async () => {
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) {
        setLoading(false);
        return;
      }
      
      const data = await apiService.getInventory(token);
      const inventoryItems = (data.items || []).filter(i => !i.isDeleted);
      setItems(inventoryItems);
      setSlotCount(data.slotCount || inventoryItems.length);
      setMaxSlots(data.maxSlots || MAX_SLOTS);
      const unreadCount = inventoryItems.filter((item: InventoryItem) => !item.isRead && item.status === 'active').length;
      setUnreadCount(unreadCount);
    } catch (error) {
      console.error('Failed to load inventory:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  }, [setUnreadCount]);

  useEffect(() => {
    loadInventory();
  }, [loadInventory]);

  useEffect(() => {
    let timer: ReturnType<typeof setInterval> | undefined;
    if (countdown !== null && countdown > 0) {
      timer = setInterval(() => {
        setCountdown(prev => (prev !== null && prev > 0) ? prev - 1 : null);
      }, 1000);
    } else if (countdown === 0) {
      setRedeemSuccess(false);
      setCountdown(null);
      setRedeemModalVisible(false);
      setSelectedItem(null);
    }
    return () => { if (timer) clearInterval(timer); };
  }, [countdown]);

  const handleRefresh = () => {
    setRefreshing(true);
    loadInventory();
  };

  const handleItemPress = async (item: InventoryItem) => {
    if (!item.isRead && item.status === 'active') {
      try {
        const token = await AsyncStorage.getItem('@mibu_token');
        if (token) {
          await apiService.markInventoryItemRead(token, item.id);
          setItems(prev => {
            const updated = prev.map(i => i.id === item.id ? { ...i, isRead: true } : i);
            const newUnreadCount = updated.filter(i => !i.isRead && i.status === 'active').length;
            setUnreadCount(newUnreadCount);
            return updated;
          });
        }
      } catch (error) {
        console.error('Failed to mark item as read:', error);
      }
    }
    
    setSelectedItem(item);
    setDetailModalVisible(true);
  };

  const handleItemLongPress = (item: InventoryItem) => {
    if (item.status === 'deleted' || item.isDeleted) return;
    setSelectedItem(item);
    setDeleteModalVisible(true);
  };

  const handleOpenRedeem = () => {
    setDetailModalVisible(false);
    setRedemptionCode('');
    setRedeemSuccess(false);
    setCountdown(null);
    setTimeout(() => setRedeemModalVisible(true), 300);
  };

  const handleRedeem = async () => {
    if (!selectedItem || !redemptionCode.trim()) {
      Alert.alert(
        state.language === 'zh-TW' ? 'æç¤º' : 'Notice',
        state.language === 'zh-TW' ? 'è«‹è¼¸å…¥å•†å®¶æ ¸éŠ·ç¢¼' : 'Please enter merchant redemption code'
      );
      return;
    }

    setRedeeming(true);
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      const response = await apiService.redeemInventoryItem(token, selectedItem.id, redemptionCode.trim());
      
      if (response.success) {
        setRedeemSuccess(true);
        setCountdown(180);
        setItems(prev => prev.map(i => i.id === selectedItem.id ? { ...i, isRedeemed: true, status: 'redeemed' as const } : i));
      } else {
        Alert.alert(
          state.language === 'zh-TW' ? 'æ ¸éŠ·å¤±æ•—' : 'Redemption Failed',
          response.message || (state.language === 'zh-TW' ? 'æ ¸éŠ·ç¢¼éŒ¯èª¤' : 'Invalid redemption code')
        );
      }
    } catch (error: any) {
      const errorMessage = error?.message || '';
      if (errorMessage.includes('expired') || errorMessage.includes('éæœŸ')) {
        Alert.alert(
          state.language === 'zh-TW' ? 'å·²éæœŸ' : 'Expired',
          state.language === 'zh-TW' ? 'æ­¤å„ªæƒ åˆ¸å·²éæœŸ' : 'This coupon has expired'
        );
      } else if (errorMessage.includes('redeemed') || errorMessage.includes('å·²ä½¿ç”¨')) {
        Alert.alert(
          state.language === 'zh-TW' ? 'å·²ä½¿ç”¨' : 'Already Used',
          state.language === 'zh-TW' ? 'æ­¤å„ªæƒ åˆ¸å·²ä½¿ç”¨' : 'This coupon has already been used'
        );
      } else {
        Alert.alert(
          state.language === 'zh-TW' ? 'éŒ¯èª¤' : 'Error',
          state.language === 'zh-TW' ? 'æ ¸éŠ·å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Redemption failed. Please try again.'
        );
      }
    } finally {
      setRedeeming(false);
    }
  };

  const handleDelete = async () => {
    if (!selectedItem) return;

    setDeleting(true);
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      const response = await apiService.deleteInventoryItem(token, selectedItem.id);
      if (response.success) {
        setDeleteModalVisible(false);
        setSelectedItem(null);
        await loadInventory();
      }
    } catch (error) {
      Alert.alert(
        state.language === 'zh-TW' ? 'éŒ¯èª¤' : 'Error',
        state.language === 'zh-TW' ? 'åˆªé™¤å¤±æ•—' : 'Delete failed'
      );
    } finally {
      setDeleting(false);
    }
  };

  const formatCountdown = (seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  const getTierLabel = (tier: CouponTier) => {
    const labels: Record<CouponTier, string> = {
      SP: 'Special',
      SSR: 'Super Rare',
      SR: 'Rare',
      S: 'Standard',
      R: 'Common',
    };
    return labels[tier] || tier;
  };

  const slots: (InventoryItem | null)[] = Array(maxSlots).fill(null);
  items.forEach(item => {
    if (item.slotIndex >= 0 && item.slotIndex < maxSlots) {
      slots[item.slotIndex] = item;
    }
  });

  if (loading) {
    return (
      <View style={{ flex: 1, backgroundColor: MibuBrand.creamLight, alignItems: 'center', justifyContent: 'center' }}>
        <ActivityIndicator size="large" color={MibuBrand.brown} />
        <Text style={{ marginTop: 16, color: MibuBrand.brownLight }}>
          {state.language === 'zh-TW' ? 'è¼‰å…¥ä¸­...' : 'Loading...'}
        </Text>
      </View>
    );
  }

  return (
    <View style={{ flex: 1, backgroundColor: MibuBrand.creamLight }}>
      <View style={{ padding: 16, borderBottomWidth: 1, borderBottomColor: MibuBrand.cream }}>
        <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' }}>
          <Text style={{ fontSize: 20, fontWeight: '800', color: MibuBrand.dark }}>
            {state.language === 'zh-TW' ? 'é“å…·ç®±' : 'Item Box'}
          </Text>
          <View style={{ flexDirection: 'row', alignItems: 'center', backgroundColor: MibuBrand.cream, paddingHorizontal: 12, paddingVertical: 6, borderRadius: 12 }}>
            <Ionicons name="cube" size={16} color={MibuBrand.brown} />
            <Text style={{ fontSize: 14, fontWeight: '700', color: MibuBrand.brown, marginLeft: 6 }}>
              {slotCount}/{maxSlots}
            </Text>
          </View>
        </View>

        <View style={{ flexDirection: 'row', marginTop: 12, gap: 8, flexWrap: 'wrap' }}>
          {(['SP', 'SSR', 'SR', 'S', 'R'] as CouponTier[]).map(tier => {
            const count = items.filter(i => i.tier === tier && i.status === 'active').length;
            return (
              <View
                key={tier}
                style={{
                  flexDirection: 'row',
                  alignItems: 'center',
                  backgroundColor: TIER_STYLES[tier].bgColor,
                  paddingHorizontal: 8,
                  paddingVertical: 4,
                  borderRadius: 8,
                  borderWidth: 1,
                  borderColor: TIER_STYLES[tier].borderColor,
                }}
              >
                <Text style={{ fontSize: 10, fontWeight: '700', color: TIER_STYLES[tier].borderColor }}>
                  {tier}: {count}
                </Text>
              </View>
            );
          })}
        </View>
      </View>

      <ScrollView
        contentContainerStyle={{ padding: 16, paddingBottom: 100 }}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} colors={[MibuBrand.brown]} tintColor={MibuBrand.brown} />
        }
      >
        <View style={{ flexDirection: 'row', flexWrap: 'wrap', justifyContent: 'flex-start' }}>
          {slots.map((item, index) => (
            <InventorySlot
              key={index}
              item={item}
              index={index}
              onPress={handleItemPress}
              onLongPress={handleItemLongPress}
              language={state.language}
            />
          ))}
        </View>
      </ScrollView>

      {/* Detail Modal */}
      <Modal
        visible={detailModalVisible}
        animationType="fade"
        transparent={true}
        onRequestClose={() => setDetailModalVisible(false)}
      >
        <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.6)', justifyContent: 'center', alignItems: 'center', padding: 20 }}>
          <View style={{ backgroundColor: MibuBrand.warmWhite, borderRadius: 24, padding: 24, width: '100%', maxWidth: 360, borderWidth: 2, borderColor: selectedItem ? TIER_STYLES[selectedItem.tier]?.borderColor : MibuBrand.tan }}>
            {selectedItem && (
              <>
                <View style={{ alignItems: 'center', marginBottom: 20 }}>
                  <View
                    style={{
                      width: 80,
                      height: 80,
                      borderRadius: 40,
                      backgroundColor: TIER_STYLES[selectedItem.tier]?.bgColor,
                      alignItems: 'center',
                      justifyContent: 'center',
                      borderWidth: 3,
                      borderColor: TIER_STYLES[selectedItem.tier]?.borderColor,
                      marginBottom: 12,
                    }}
                  >
                    <Ionicons
                      name={(TIER_ICONS[selectedItem.tier] || 'ticket') as any}
                      size={36}
                      color={TIER_STYLES[selectedItem.tier]?.borderColor}
                    />
                  </View>
                  <Text style={{ fontSize: 12, fontWeight: '700', color: TIER_STYLES[selectedItem.tier]?.borderColor }}>
                    {selectedItem.tier} - {getTierLabel(selectedItem.tier)}
                  </Text>
                </View>

                <Text style={{ fontSize: 18, fontWeight: '800', color: MibuBrand.dark, textAlign: 'center', marginBottom: 8 }}>
                  {selectedItem.title}
                </Text>

                {selectedItem.description && (
                  <Text style={{ fontSize: 14, color: MibuBrand.brownLight, textAlign: 'center', marginBottom: 16 }}>
                    {selectedItem.description}
                  </Text>
                )}

                {selectedItem.merchantName && (
                  <View style={{ flexDirection: 'row', alignItems: 'center', justifyContent: 'center', marginBottom: 16 }}>
                    <Ionicons name="storefront-outline" size={14} color={MibuBrand.copper} />
                    <Text style={{ fontSize: 13, color: MibuBrand.copper, marginLeft: 6 }}>{selectedItem.merchantName}</Text>
                  </View>
                )}

                {selectedItem.expiresAt && (
                  <View style={{ backgroundColor: selectedItem.isExpired ? MibuBrand.error : MibuBrand.cream, padding: 12, borderRadius: 12, marginBottom: 20 }}>
                    <Text style={{ fontSize: 12, color: selectedItem.isExpired ? '#ffffff' : MibuBrand.brown, textAlign: 'center' }}>
                      {selectedItem.isExpired
                        ? (state.language === 'zh-TW' ? 'å·²éæœŸ' : 'Expired')
                        : `${state.language === 'zh-TW' ? 'æœ‰æ•ˆæœŸè‡³' : 'Valid until'} ${new Date(selectedItem.expiresAt).toLocaleDateString()}`
                      }
                    </Text>
                  </View>
                )}

                <View style={{ flexDirection: 'row', gap: 12 }}>
                  <TouchableOpacity
                    onPress={() => setDetailModalVisible(false)}
                    style={{ flex: 1, backgroundColor: MibuBrand.tan, paddingVertical: 14, borderRadius: 12, alignItems: 'center' }}
                  >
                    <Text style={{ fontSize: 16, fontWeight: '700', color: MibuBrand.dark }}>
                      {state.language === 'zh-TW' ? 'é—œé–‰' : 'Close'}
                    </Text>
                  </TouchableOpacity>

                  {selectedItem.status === 'active' && !selectedItem.isExpired && (
                    <TouchableOpacity
                      onPress={handleOpenRedeem}
                      style={{ flex: 1, backgroundColor: MibuBrand.brown, paddingVertical: 14, borderRadius: 12, alignItems: 'center' }}
                    >
                      <Text style={{ fontSize: 16, fontWeight: '700', color: '#ffffff' }}>
                        {state.language === 'zh-TW' ? 'æ ¸éŠ·' : 'Redeem'}
                      </Text>
                    </TouchableOpacity>
                  )}
                </View>
              </>
            )}
          </View>
        </View>
      </Modal>

      {/* Redeem Modal */}
      <Modal
        visible={redeemModalVisible}
        animationType="slide"
        transparent={true}
        onRequestClose={() => !redeemSuccess && setRedeemModalVisible(false)}
      >
        <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.6)', justifyContent: 'center', alignItems: 'center', padding: 20 }}>
          <View style={{ backgroundColor: MibuBrand.warmWhite, borderRadius: 24, padding: 24, width: '100%', maxWidth: 360 }}>
            {redeemSuccess ? (
              <View style={{ alignItems: 'center' }}>
                <View style={{ width: 80, height: 80, borderRadius: 40, backgroundColor: MibuBrand.success, alignItems: 'center', justifyContent: 'center', marginBottom: 16 }}>
                  <Ionicons name="checkmark-circle" size={48} color="#ffffff" />
                </View>
                <Text style={{ fontSize: 20, fontWeight: '800', color: MibuBrand.success, marginBottom: 8 }}>
                  {state.language === 'zh-TW' ? 'æ ¸éŠ·æˆåŠŸï¼' : 'Redeemed!'}
                </Text>
                <Text style={{ fontSize: 14, color: MibuBrand.brownLight, textAlign: 'center', marginBottom: 16 }}>
                  {state.language === 'zh-TW' ? 'è«‹å‡ºç¤ºæ­¤ç•«é¢çµ¦å•†å®¶ç¢ºèª' : 'Please show this screen to the merchant'}
                </Text>
                
                {countdown !== null && (
                  <View style={{ backgroundColor: MibuBrand.brown, paddingHorizontal: 32, paddingVertical: 20, borderRadius: 16, marginBottom: 20 }}>
                    <Text style={{ fontSize: 48, fontWeight: '900', color: '#ffffff', textAlign: 'center' }}>
                      {formatCountdown(countdown)}
                    </Text>
                    <Text style={{ fontSize: 12, color: MibuBrand.cream, textAlign: 'center', marginTop: 4 }}>
                      {state.language === 'zh-TW' ? 'å€’æ•¸è¨ˆæ™‚' : 'Countdown'}
                    </Text>
                  </View>
                )}

                <TouchableOpacity
                  onPress={() => setRedeemModalVisible(false)}
                  style={{ backgroundColor: MibuBrand.tan, paddingVertical: 14, paddingHorizontal: 32, borderRadius: 12 }}
                >
                  <Text style={{ fontSize: 16, fontWeight: '700', color: MibuBrand.dark }}>
                    {state.language === 'zh-TW' ? 'å®Œæˆ' : 'Done'}
                  </Text>
                </TouchableOpacity>
              </View>
            ) : (
              <>
                <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 20 }}>
                  <Text style={{ fontSize: 18, fontWeight: '800', color: MibuBrand.dark }}>
                    {state.language === 'zh-TW' ? 'æ ¸éŠ·å„ªæƒ åˆ¸' : 'Redeem Coupon'}
                  </Text>
                  <TouchableOpacity onPress={() => setRedeemModalVisible(false)}>
                    <Ionicons name="close" size={24} color={MibuBrand.brownLight} />
                  </TouchableOpacity>
                </View>

                {selectedItem && (
                  <View style={{ backgroundColor: MibuBrand.cream, borderRadius: 12, padding: 16, marginBottom: 20, borderWidth: 1, borderColor: TIER_STYLES[selectedItem.tier]?.borderColor }}>
                    <Text style={{ fontSize: 16, fontWeight: '700', color: MibuBrand.dark, marginBottom: 4 }}>
                      {selectedItem.title}
                    </Text>
                    {selectedItem.description && (
                      <Text style={{ fontSize: 13, color: MibuBrand.brownLight }}>{selectedItem.description}</Text>
                    )}
                  </View>
                )}

                <Text style={{ fontSize: 14, fontWeight: '600', color: MibuBrand.brownLight, marginBottom: 8 }}>
                  {state.language === 'zh-TW' ? 'è«‹è¼¸å…¥å•†å®¶æ ¸éŠ·ç¢¼' : 'Enter Merchant Redemption Code'}
                </Text>
                <TextInput
                  value={redemptionCode}
                  onChangeText={setRedemptionCode}
                  placeholder={state.language === 'zh-TW' ? '8ä½æ ¸éŠ·ç¢¼' : '8-digit code'}
                  placeholderTextColor={MibuBrand.copper}
                  autoCapitalize="characters"
                  maxLength={8}
                  style={{
                    backgroundColor: MibuBrand.cream,
                    borderRadius: 12,
                    padding: 16,
                    fontSize: 24,
                    fontWeight: '700',
                    textAlign: 'center',
                    letterSpacing: 4,
                    color: MibuBrand.brown,
                    marginBottom: 20,
                    borderWidth: 2,
                    borderColor: MibuBrand.tan,
                  }}
                />

                <TouchableOpacity
                  onPress={handleRedeem}
                  disabled={redeeming || redemptionCode.length < 8}
                  style={{
                    backgroundColor: redemptionCode.length >= 8 ? MibuBrand.brown : MibuBrand.tan,
                    paddingVertical: 16,
                    borderRadius: 12,
                    alignItems: 'center',
                  }}
                >
                  {redeeming ? (
                    <ActivityIndicator color="#ffffff" />
                  ) : (
                    <Text style={{ fontSize: 16, fontWeight: '700', color: redemptionCode.length >= 8 ? '#ffffff' : MibuBrand.brownLight }}>
                      {state.language === 'zh-TW' ? 'ç¢ºèªæ ¸éŠ·' : 'Confirm Redemption'}
                    </Text>
                  )}
                </TouchableOpacity>
              </>
            )}
          </View>
        </View>
      </Modal>

      {/* Delete Confirmation Modal */}
      <Modal
        visible={deleteModalVisible}
        animationType="fade"
        transparent={true}
        onRequestClose={() => setDeleteModalVisible(false)}
      >
        <View style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.6)', justifyContent: 'center', alignItems: 'center', padding: 20 }}>
          <View style={{ backgroundColor: MibuBrand.warmWhite, borderRadius: 24, padding: 24, width: '100%', maxWidth: 360 }}>
            <View style={{ alignItems: 'center', marginBottom: 20 }}>
              <View style={{ width: 60, height: 60, borderRadius: 30, backgroundColor: '#fef2f2', alignItems: 'center', justifyContent: 'center', marginBottom: 12 }}>
                <Ionicons name="trash" size={28} color={MibuBrand.error} />
              </View>
              <Text style={{ fontSize: 18, fontWeight: '800', color: MibuBrand.dark, marginBottom: 8 }}>
                {state.language === 'zh-TW' ? 'ç¢ºå®šåˆªé™¤ï¼Ÿ' : 'Delete Item?'}
              </Text>
              <Text style={{ fontSize: 14, color: MibuBrand.brownLight, textAlign: 'center' }}>
                {state.language === 'zh-TW' ? 'æ­¤æ“ä½œç„¡æ³•å¾©åŸ' : 'This action cannot be undone'}
              </Text>
            </View>

            {selectedItem && (
              <View style={{ backgroundColor: MibuBrand.cream, borderRadius: 12, padding: 12, marginBottom: 20 }}>
                <Text style={{ fontSize: 14, fontWeight: '700', color: MibuBrand.dark, textAlign: 'center' }}>
                  {selectedItem.title}
                </Text>
              </View>
            )}

            <View style={{ flexDirection: 'row', gap: 12 }}>
              <TouchableOpacity
                onPress={() => setDeleteModalVisible(false)}
                style={{ flex: 1, backgroundColor: MibuBrand.tan, paddingVertical: 14, borderRadius: 12, alignItems: 'center' }}
              >
                <Text style={{ fontSize: 16, fontWeight: '700', color: MibuBrand.dark }}>
                  {state.language === 'zh-TW' ? 'å–æ¶ˆ' : 'Cancel'}
                </Text>
              </TouchableOpacity>

              <TouchableOpacity
                onPress={handleDelete}
                disabled={deleting}
                style={{ flex: 1, backgroundColor: MibuBrand.error, paddingVertical: 14, borderRadius: 12, alignItems: 'center' }}
              >
                {deleting ? (
                  <ActivityIndicator color="#ffffff" />
                ) : (
                  <Text style={{ fontSize: 16, fontWeight: '700', color: '#ffffff' }}>
                    {state.language === 'zh-TW' ? 'åˆªé™¤' : 'Delete'}
                  </Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
    </View>
  );
}

=== File: src/screens/ItemsScreen.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  ScrollView,
  TouchableOpacity,
  Image,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import * as WebBrowser from 'expo-web-browser';
import { useApp } from '../context/AppContext';
import { GachaItem } from '../types';
import { getCategoryLabel, getCategoryColor } from '../constants/translations';
import { MibuBrand, getCategoryToken, deriveMerchantScheme } from '../../constants/Colors';

const RARITY_COLORS: Record<string, string> = {
  SP: MibuBrand.tierSP,
  SSR: MibuBrand.tierSSR,
  SR: MibuBrand.tierSR,
  S: MibuBrand.tierS,
  R: MibuBrand.tierR,
  N: '#94a3b8',
};

const RARITY_BG_COLORS: Record<string, string> = {
  SP: MibuBrand.tierSPBg,
  SSR: MibuBrand.tierSSRBg,
  SR: MibuBrand.tierSRBg,
  S: MibuBrand.tierSBg,
  R: MibuBrand.tierRBg,
  N: '#f1f5f9',
};

interface ItemCardProps {
  item: GachaItem;
  translations: Record<string, string>;
  language: string;
}

function ItemCard({ item, translations, language }: ItemCardProps) {
  const categoryToken = getCategoryToken(item.category as string);
  const categoryLabel = getCategoryLabel(item.category as string, language as any);

  const isMerchantPro = item.merchant?.isPro && item.merchant?.brandColor;
  const merchantScheme = isMerchantPro 
    ? deriveMerchantScheme(item.merchant!.brandColor!) 
    : null;
  
  const stripeColor = merchantScheme ? merchantScheme.accent : categoryToken.stripe;
  const titleColor = merchantScheme ? merchantScheme.accent : MibuBrand.dark;
  const merchantPromo = item.merchant?.promo;

  const getLocalizedContent = (content: any): string => {
    if (typeof content === 'string') return content;
    if (typeof content === 'object' && content !== null) {
      return content[language] || content['zh-TW'] || content['en'] || '';
    }
    return '';
  };

  const placeName = getLocalizedContent(item.place_name) || getLocalizedContent(item.verified_name) || '';
  const description = getLocalizedContent(item.ai_description) || getLocalizedContent(item.description) || '';

  const getDurationText = () => {
    if (item.duration) return item.duration;
    if (item.suggested_time) return item.suggested_time;
    const category = (item.category || '').toString().toLowerCase();
    if (category.includes('food') || category.includes('ç¾é£Ÿ') || category === 'f') {
      return '0.5-1h';
    }
    if (category.includes('shop') || category.includes('è³¼ç‰©') || category === 's') {
      return '1-2h';
    }
    return '2-3h';
  };

  const handleOpenMaps = async () => {
    if (!placeName) return;
    const url = `https://www.google.com/search?q=${encodeURIComponent(placeName)}`;
    try {
      await WebBrowser.openBrowserAsync(url);
    } catch (error) {
      console.log('Failed to open URL:', error);
    }
  };

  const rarity = item.rarity || 'N';
  const rarityColor = RARITY_COLORS[rarity] || RARITY_COLORS.N;
  const rarityBg = RARITY_BG_COLORS[rarity] || RARITY_BG_COLORS.N;

  const hasCoupon = item.coupon_data;
  const couponText = item.coupon_data?.title ? getLocalizedContent(item.coupon_data.title) : '';
  const couponCode = item.coupon_data?.code || '';

  return (
    <View
      style={{
        backgroundColor: MibuBrand.warmWhite,
        borderRadius: 16,
        marginHorizontal: 16,
        marginBottom: 12,
        shadowColor: MibuBrand.brown,
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.06,
        shadowRadius: 8,
        elevation: 2,
        flexDirection: 'row',
        overflow: 'hidden',
      }}
    >
      {/* å·¦å´æ¢ç´‹ï¼ˆå•†å®¶PROç”¨å“ç‰Œè‰²ï¼Œä¸€èˆ¬ç”¨é¡åˆ¥è‰²ï¼‰ */}
      <View
        style={{
          width: 4,
          backgroundColor: stripeColor,
        }}
      />
      <View style={{ flex: 1, padding: 20 }}>
        <View style={{ flexDirection: 'row', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: 12 }}>
          <View
            style={{
              backgroundColor: MibuBrand.creamLight,
              paddingHorizontal: 10,
              paddingVertical: 5,
              borderRadius: 12,
            }}
          >
            <Text style={{ fontSize: 12, fontWeight: '600', color: MibuBrand.copper }}>
              {getDurationText()}
            </Text>
          </View>

          {/* é¡åˆ¥æ¨™ç±¤ä½¿ç”¨æŸ”å’Œè‰² */}
          <View
            style={{
              backgroundColor: categoryToken.badge,
              paddingHorizontal: 12,
              paddingVertical: 5,
              borderRadius: 12,
            }}
          >
            <Text style={{ fontSize: 12, fontWeight: '600', color: categoryToken.badgeText }}>
              {categoryLabel}
            </Text>
          </View>
        </View>

        <Text
          style={{ fontSize: 20, fontWeight: '700', color: titleColor, marginBottom: 8, letterSpacing: -0.3 }}
          numberOfLines={2}
        >
          {placeName}
        </Text>

        {description ? (
          <Text
            style={{ fontSize: 14, color: MibuBrand.brownLight, lineHeight: 22, marginBottom: 16 }}
          >
            {description}
          </Text>
        ) : null}

        {/* å•†å®¶å„ªæƒ å…¬å‘Šï¼ˆPROå•†å®¶å°ˆå±¬ï¼‰ */}
        {merchantPromo && (
          <View
            style={{
              borderWidth: 1.5,
              borderColor: merchantScheme?.accent || MibuBrand.copper,
              borderStyle: 'dashed',
              borderRadius: 12,
              padding: 14,
              marginBottom: 16,
            }}
          >
            <Text style={{ fontSize: 13, fontWeight: '600', color: MibuBrand.dark }}>
              ğŸ {merchantPromo}
            </Text>
          </View>
        )}

        {/* å„ªæƒ åˆ¸å€å¡Šï¼ˆæ‰­è›‹çå‹µï¼‰ */}
        {hasCoupon && (
          <View
            style={{
              backgroundColor: MibuBrand.highlight,
              borderRadius: 12,
              padding: 14,
              marginBottom: 16,
              flexDirection: 'row',
              alignItems: 'center',
            }}
          >
            <View
              style={{
                backgroundColor: rarityBg,
                paddingHorizontal: 8,
                paddingVertical: 4,
                borderRadius: 6,
                marginRight: 10,
              }}
            >
              <Text style={{ fontSize: 11, fontWeight: '800', color: rarityColor }}>
                {rarity}
              </Text>
            </View>
            <View style={{ flex: 1 }}>
              <Text style={{ fontSize: 13, fontWeight: '600', color: MibuBrand.dark, marginBottom: 2 }}>
                {couponText}
              </Text>
              {couponCode && (
                <Text style={{ fontSize: 11, color: MibuBrand.copper }}>
                  CODE: {couponCode}
                </Text>
              )}
            </View>
          </View>
        )}

        <TouchableOpacity
          style={{
            backgroundColor: MibuBrand.creamLight,
            borderRadius: 12,
            paddingVertical: 14,
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'center',
          }}
          onPress={handleOpenMaps}
        >
          <Ionicons name="location-outline" size={16} color={MibuBrand.copper} />
          <Text style={{ fontSize: 14, fontWeight: '600', color: MibuBrand.copper, marginLeft: 6 }}>
            {translations.viewOnMap || 'åœ¨ Google åœ°åœ–ä¸­æŸ¥çœ‹'}
          </Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

export function ItemsScreen() {
  const router = useRouter();
  const { state, t } = useApp();

  const items = state.result?.inventory || [];
  const meta = state.result?.meta;

  const handleBackToGacha = () => {
    router.back();
  };

  if (items.length === 0) {
    return (
      <View
        style={{
          flex: 1,
          backgroundColor: MibuBrand.creamLight,
          alignItems: 'center',
          justifyContent: 'center',
          padding: 20,
        }}
      >
        <View
          style={{
            width: 90,
            height: 90,
            borderRadius: 45,
            backgroundColor: MibuBrand.cream,
            alignItems: 'center',
            justifyContent: 'center',
            marginBottom: 20,
          }}
        >
          <Ionicons name="cube-outline" size={40} color={MibuBrand.copper} />
        </View>
        <Text style={{ fontSize: 18, fontWeight: '700', color: MibuBrand.brown, marginBottom: 6 }}>
          {t.noResults || 'å°šç„¡çµæœ'}
        </Text>
        <Text style={{ fontSize: 14, color: MibuBrand.brownLight, textAlign: 'center', marginBottom: 28 }}>
          {t.tryGachaFirst || 'å…ˆä¾†ä¸€ç™¼æ‰­è›‹å§ï¼'}
        </Text>
        <TouchableOpacity
          style={{
            backgroundColor: MibuBrand.brown,
            paddingVertical: 14,
            paddingHorizontal: 28,
            borderRadius: 24,
          }}
          onPress={handleBackToGacha}
        >
          <Text style={{ fontSize: 15, fontWeight: '700', color: MibuBrand.warmWhite }}>
            {t.startGacha || 'é–‹å§‹æ‰­è›‹'}
          </Text>
        </TouchableOpacity>
      </View>
    );
  }

  const getLocalizedString = (content: any): string => {
    if (typeof content === 'string') return content;
    if (typeof content === 'object' && content !== null) {
      return content[state.language] || content['zh-TW'] || content['en'] || '';
    }
    return '';
  };

  const cityName = getLocalizedString(meta?.city) || '';
  const districtName = getLocalizedString(meta?.locked_district) || '';

  const themeIntro = (meta as any)?.themeIntro;

  return (
    <View style={{ flex: 1, backgroundColor: MibuBrand.creamLight }}>
      <View
        style={{
          paddingTop: 56,
          paddingHorizontal: 20,
          paddingBottom: 16,
          alignItems: 'center',
        }}
      >
        <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 6 }}>
          <Image
            source={require('../../assets/images/icon.png')}
            style={{ width: 28, height: 28, marginRight: 6 }}
            resizeMode="contain"
          />
          <Text style={{ fontSize: 16, fontWeight: '600', color: MibuBrand.brown, letterSpacing: 1 }}>
            MIBU
          </Text>
        </View>

        <Text style={{ fontSize: 32, fontWeight: '800', color: MibuBrand.dark, marginBottom: 4, letterSpacing: -0.5 }}>
          {cityName}
        </Text>

        {districtName && (
          <Text style={{ fontSize: 14, color: MibuBrand.brownLight }}>
            {t.exploring || 'æ­£åœ¨æ¢ç´¢'}{' '}
            <Text style={{ color: MibuBrand.brown, fontWeight: '600' }}>
              {districtName}
            </Text>
          </Text>
        )}

        {themeIntro && (
          <Text style={{ fontSize: 13, color: MibuBrand.copper, marginTop: 8, textAlign: 'center', fontStyle: 'italic' }}>
            "{themeIntro}"
          </Text>
        )}
      </View>

      <ScrollView
        style={{ flex: 1 }}
        contentContainerStyle={{ paddingBottom: 100, paddingTop: 8 }}
        showsVerticalScrollIndicator={false}
      >
        {items.map((item, index) => (
          <ItemCard
            key={item.id || index}
            item={item}
            translations={t}
            language={state.language}
          />
        ))}
      </ScrollView>

      <View
        style={{
          position: 'absolute',
          bottom: 0,
          left: 0,
          right: 0,
          paddingHorizontal: 20,
          paddingBottom: 36,
          paddingTop: 12,
          backgroundColor: 'transparent',
        }}
      >
        <TouchableOpacity
          style={{
            backgroundColor: MibuBrand.brown,
            paddingVertical: 16,
            borderRadius: 28,
            flexDirection: 'row',
            alignItems: 'center',
            justifyContent: 'center',
            shadowColor: MibuBrand.dark,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.15,
            shadowRadius: 12,
            elevation: 6,
          }}
          onPress={handleBackToGacha}
        >
          <Text style={{ fontSize: 16, fontWeight: '700', color: MibuBrand.warmWhite, marginRight: 8 }}>
            {t.reGacha || 'é‡æ–°æ‰­è›‹'}
          </Text>
          <Ionicons name="refresh" size={18} color={MibuBrand.warmWhite} />
        </TouchableOpacity>
      </View>
    </View>
  );
}

=== File: src/screens/ItineraryScreen.tsx ===

import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../context/AppContext';

export function ItineraryScreen() {
  const { state } = useApp();

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <Text style={styles.title}>
        {state.language === 'zh-TW' ? 'è¡Œç¨‹' : 'Itinerary'}
      </Text>

      <View style={styles.comingSoon}>
        <View style={styles.iconContainer}>
          <Ionicons name="calendar" size={48} color="#f59e0b" />
        </View>
        <Text style={styles.comingSoonTitle}>
          {state.language === 'zh-TW' ? 'å³å°‡æ¨å‡º' : 'Coming Soon'}
        </Text>
        <Text style={styles.comingSoonDesc}>
          {state.language === 'zh-TW'
            ? 'è¦åŠƒä¸¦ç®¡ç†æ‚¨çš„å®Œç¾æ—…ç¨‹'
            : 'Plan and manage your perfect trip'}
        </Text>
      </View>

      <View style={styles.featureCard}>
        <Ionicons name="list" size={32} color="#f59e0b" />
        <View style={styles.featureInfo}>
          <Text style={styles.featureTitle}>
            {state.language === 'zh-TW' ? 'è¡Œç¨‹ç®¡ç†' : 'Trip Management'}
          </Text>
          <Text style={styles.featureDesc}>
            {state.language === 'zh-TW' 
              ? 'å°‡æ”¶è—çš„æ™¯é»åŠ å…¥è¡Œç¨‹ï¼Œè¼•é¬†è¦åŠƒ' 
              : 'Add collected spots to your itinerary easily'}
          </Text>
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  title: {
    fontSize: 28,
    fontWeight: '900',
    color: '#1e293b',
    marginBottom: 24,
  },
  comingSoon: {
    backgroundColor: '#ffffff',
    borderRadius: 24,
    padding: 32,
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 2,
    borderColor: '#f1f5f9',
  },
  iconContainer: {
    width: 80,
    height: 80,
    backgroundColor: '#fef3c7',
    borderRadius: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  comingSoonTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 8,
  },
  comingSoonDesc: {
    fontSize: 14,
    color: '#64748b',
    textAlign: 'center',
  },
  featureCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    padding: 20,
    borderRadius: 16,
    gap: 16,
    borderWidth: 2,
    borderColor: '#f1f5f9',
  },
  featureInfo: {
    flex: 1,
  },
  featureTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  featureDesc: {
    fontSize: 14,
    color: '#64748b',
  },
});

=== File: src/screens/LocationScreen.tsx ===

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  View, 
  StyleSheet, 
  ActivityIndicator,
  TouchableOpacity,
  Platform,
  Text,
  Switch,
} from 'react-native';
import * as Location from 'expo-location';
import MapView, { Marker, PROVIDER_GOOGLE } from 'react-native-maps';
import { Ionicons } from '@expo/vector-icons';
import { API_BASE_URL } from '../constants/translations';
import { useApp } from '../context/AppContext';

const THROTTLE_INTERVAL = 10000;
const MIN_DISTANCE_METERS = 10;

interface PlannerLocation {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
}

function getDistanceFromLatLonInMeters(
  lat1: number, lon1: number, 
  lat2: number, lon2: number
): number {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

export function LocationScreen() {
  const { t } = useApp();
  const [location, setLocation] = useState<Location.LocationObject | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);
  const [isSharingEnabled, setIsSharingEnabled] = useState(false);
  const [plannerLocations, setPlannerLocations] = useState<PlannerLocation[]>([]);
  
  const mapRef = useRef<MapView | null>(null);
  const lastReportedLocation = useRef<{ latitude: number; longitude: number } | null>(null);
  const lastReportTime = useRef<number>(0);
  const locationSubscription = useRef<Location.LocationSubscription | null>(null);

  const updateUserLocation = useCallback(async (latitude: number, longitude: number, sharing: boolean) => {
    try {
      console.log('ğŸ”— Debug URL:', API_BASE_URL + '/api/location/update');
      const response = await fetch(`${API_BASE_URL}/api/location/update`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ latitude, longitude, isSharingEnabled: sharing }),
      });
      
      if (response.ok) {
        const contentLength = response.headers.get('content-length');
        if (contentLength && parseInt(contentLength) > 0) {
          const data = await response.json();
          if (data.plannerLocations && Array.isArray(data.plannerLocations)) {
            setPlannerLocations(data.plannerLocations);
          }
        }
      }
    } catch (error) {
      console.error('Failed to update location:', error);
    }
  }, []);

  const shouldReportLocation = useCallback((latitude: number, longitude: number): boolean => {
    const now = Date.now();
    const timeSinceLastReport = now - lastReportTime.current;
    
    if (timeSinceLastReport >= THROTTLE_INTERVAL) {
      return true;
    }
    
    if (lastReportedLocation.current) {
      const distance = getDistanceFromLatLonInMeters(
        lastReportedLocation.current.latitude,
        lastReportedLocation.current.longitude,
        latitude,
        longitude
      );
      
      if (distance >= MIN_DISTANCE_METERS) {
        return true;
      }
    }
    
    return false;
  }, []);

  const handleLocationUpdate = useCallback((newLocation: Location.LocationObject) => {
    setLocation(newLocation);
    
    const { latitude, longitude } = newLocation.coords;
    
    if (shouldReportLocation(latitude, longitude)) {
      updateUserLocation(latitude, longitude, isSharingEnabled);
      lastReportedLocation.current = { latitude, longitude };
      lastReportTime.current = Date.now();
    }
  }, [shouldReportLocation, updateUserLocation, isSharingEnabled]);

  const startLocationTracking = useCallback(async () => {
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        setErrorMsg(t.locationPermissionRequired);
        setLoading(false);
        return;
      }

      const currentLocation = await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.High,
      });
      
      handleLocationUpdate(currentLocation);
      setLoading(false);

      locationSubscription.current = await Location.watchPositionAsync(
        {
          accuracy: Location.Accuracy.Balanced,
          timeInterval: 5000,
          distanceInterval: 5,
        },
        handleLocationUpdate
      );
    } catch (error) {
      console.error('Location error:', error);
      setErrorMsg(t.unableToGetLocation);
      setLoading(false);
    }
  }, [handleLocationUpdate, t]);

  useEffect(() => {
    startLocationTracking();
    
    return () => {
      if (locationSubscription.current) {
        locationSubscription.current.remove();
      }
    };
  }, [startLocationTracking]);

  const centerOnUser = useCallback(() => {
    if (location && mapRef.current) {
      mapRef.current.animateToRegion({
        latitude: location.coords.latitude,
        longitude: location.coords.longitude,
        latitudeDelta: 0.01,
        longitudeDelta: 0.01,
      }, 500);
    }
  }, [location]);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#22c55e" />
        <Text style={styles.loadingText}>{t.gettingLocation}</Text>
      </View>
    );
  }

  if (errorMsg) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="location-outline" size={48} color="#ef4444" />
        <Text style={styles.errorText}>{errorMsg}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={startLocationTracking}>
          <Text style={styles.retryButtonText}>{t.retry}</Text>
        </TouchableOpacity>
      </View>
    );
  }

  const initialRegion = {
    latitude: location?.coords.latitude || 25.0330,
    longitude: location?.coords.longitude || 121.5654,
    latitudeDelta: 0.01,
    longitudeDelta: 0.01,
  };

  return (
    <View style={styles.container}>
      <View style={styles.sharingToggle}>
        <View style={styles.sharingInfo}>
          <Ionicons name="people" size={20} color="#64748b" />
          <Text style={styles.sharingText}>{t.shareLocationToPlanner}</Text>
        </View>
        <Switch
          value={isSharingEnabled}
          onValueChange={setIsSharingEnabled}
          trackColor={{ false: '#d1d5db', true: '#86efac' }}
          thumbColor={isSharingEnabled ? '#22c55e' : '#f4f4f5'}
        />
      </View>
      
      <MapView
        ref={mapRef}
        style={styles.map}
        provider={Platform.OS === 'android' ? PROVIDER_GOOGLE : undefined}
        initialRegion={initialRegion}
        showsUserLocation={true}
        showsMyLocationButton={false}
        showsCompass={true}
        rotateEnabled={true}
        pitchEnabled={true}
      >
        {location && (
          <Marker
            coordinate={{
              latitude: location.coords.latitude,
              longitude: location.coords.longitude,
            }}
            title={t.yourLocation}
          >
            <View style={styles.userMarker}>
              <View style={styles.userMarkerInner} />
            </View>
          </Marker>
        )}
        
        {plannerLocations.map((planner) => (
          <Marker
            key={planner.id}
            coordinate={{
              latitude: planner.latitude,
              longitude: planner.longitude,
            }}
            title={planner.name}
            description={t.planner}
          >
            <View style={styles.plannerMarker}>
              <Ionicons name="person" size={16} color="#ffffff" />
            </View>
          </Marker>
        ))}
      </MapView>
      
      <TouchableOpacity style={styles.centerButton} onPress={centerOnUser}>
        <Ionicons name="locate" size={24} color="#22c55e" />
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  sharingToggle: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#ffffff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  sharingInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  sharingText: {
    fontSize: 15,
    color: '#334155',
    fontWeight: '500',
  },
  map: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#64748b',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
    padding: 24,
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#64748b',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 20,
    backgroundColor: '#22c55e',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 12,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  centerButton: {
    position: 'absolute',
    bottom: 24,
    right: 16,
    width: 48,
    height: 48,
    backgroundColor: '#ffffff',
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.15,
    shadowRadius: 4,
    elevation: 4,
  },
  userMarker: {
    width: 24,
    height: 24,
    backgroundColor: 'rgba(34, 197, 94, 0.3)',
    borderRadius: 12,
    justifyContent: 'center',
    alignItems: 'center',
  },
  userMarkerInner: {
    width: 12,
    height: 12,
    backgroundColor: '#22c55e',
    borderRadius: 6,
    borderWidth: 2,
    borderColor: '#ffffff',
  },
  plannerMarker: {
    width: 32,
    height: 32,
    backgroundColor: '#8b5cf6',
    borderRadius: 16,
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 3,
    borderColor: '#ffffff',
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
    shadowRadius: 3,
    elevation: 4,
  },
});

=== File: src/screens/LocationScreen.web.tsx ===

import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  View, 
  StyleSheet, 
  ActivityIndicator,
  TouchableOpacity,
  Text,
  Switch,
  ScrollView,
} from 'react-native';
import * as Location from 'expo-location';
import { Ionicons } from '@expo/vector-icons';
import { API_BASE_URL } from '../constants/translations';
import { useApp } from '../context/AppContext';

const THROTTLE_INTERVAL = 10000;
const MIN_DISTANCE_METERS = 10;

interface PlannerLocation {
  id: string;
  name: string;
  latitude: number;
  longitude: number;
}

function getDistanceFromLatLonInMeters(
  lat1: number, lon1: number, 
  lat2: number, lon2: number
): number {
  const R = 6371000;
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

export function LocationScreen() {
  const { t } = useApp();
  const [location, setLocation] = useState<Location.LocationObject | null>(null);
  const [loading, setLoading] = useState(true);
  const [errorMsg, setErrorMsg] = useState<string | null>(null);
  const [isSharingEnabled, setIsSharingEnabled] = useState(false);
  const [plannerLocations, setPlannerLocations] = useState<PlannerLocation[]>([]);
  
  const lastReportedLocation = useRef<{ latitude: number; longitude: number } | null>(null);
  const lastReportTime = useRef<number>(0);
  const locationSubscription = useRef<Location.LocationSubscription | null>(null);

  const updateUserLocation = useCallback(async (latitude: number, longitude: number, sharing: boolean) => {
    try {
      console.log('ğŸ”— Debug URL:', API_BASE_URL + '/api/location/update');
      const response = await fetch(`${API_BASE_URL}/api/location/update`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ latitude, longitude, isSharingEnabled: sharing }),
      });
      
      if (response.ok) {
        const contentLength = response.headers.get('content-length');
        if (contentLength && parseInt(contentLength) > 0) {
          const data = await response.json();
          if (data.plannerLocations && Array.isArray(data.plannerLocations)) {
            setPlannerLocations(data.plannerLocations);
          }
        }
      }
    } catch (error) {
      console.error('Failed to update location:', error);
    }
  }, []);

  const shouldReportLocation = useCallback((latitude: number, longitude: number): boolean => {
    const now = Date.now();
    const timeSinceLastReport = now - lastReportTime.current;
    
    if (timeSinceLastReport >= THROTTLE_INTERVAL) {
      return true;
    }
    
    if (lastReportedLocation.current) {
      const distance = getDistanceFromLatLonInMeters(
        lastReportedLocation.current.latitude,
        lastReportedLocation.current.longitude,
        latitude,
        longitude
      );
      
      if (distance >= MIN_DISTANCE_METERS) {
        return true;
      }
    }
    
    return false;
  }, []);

  const handleLocationUpdate = useCallback((newLocation: Location.LocationObject) => {
    setLocation(newLocation);
    
    const { latitude, longitude } = newLocation.coords;
    
    if (shouldReportLocation(latitude, longitude)) {
      updateUserLocation(latitude, longitude, isSharingEnabled);
      lastReportedLocation.current = { latitude, longitude };
      lastReportTime.current = Date.now();
    }
  }, [shouldReportLocation, updateUserLocation, isSharingEnabled]);

  const startLocationTracking = useCallback(async () => {
    try {
      const { status } = await Location.requestForegroundPermissionsAsync();
      if (status !== 'granted') {
        setErrorMsg(t.locationPermissionRequired);
        setLoading(false);
        return;
      }

      const currentLocation = await Location.getCurrentPositionAsync({
        accuracy: Location.Accuracy.High,
      });
      
      handleLocationUpdate(currentLocation);
      setLoading(false);

      locationSubscription.current = await Location.watchPositionAsync(
        {
          accuracy: Location.Accuracy.Balanced,
          timeInterval: 5000,
          distanceInterval: 5,
        },
        handleLocationUpdate
      );
    } catch (error) {
      console.error('Location error:', error);
      setErrorMsg(t.unableToGetLocation);
      setLoading(false);
    }
  }, [handleLocationUpdate, t]);

  useEffect(() => {
    startLocationTracking();
    
    return () => {
      if (locationSubscription.current) {
        locationSubscription.current.remove();
      }
    };
  }, [startLocationTracking]);

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#22c55e" />
        <Text style={styles.loadingText}>{t.gettingLocation}</Text>
      </View>
    );
  }

  if (errorMsg) {
    return (
      <View style={styles.errorContainer}>
        <Ionicons name="location-outline" size={48} color="#ef4444" />
        <Text style={styles.errorText}>{errorMsg}</Text>
        <TouchableOpacity style={styles.retryButton} onPress={startLocationTracking}>
          <Text style={styles.retryButtonText}>{t.retry}</Text>
        </TouchableOpacity>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.sharingToggle}>
        <View style={styles.sharingInfo}>
          <Ionicons name="people" size={20} color="#64748b" />
          <Text style={styles.sharingText}>{t.shareLocationToPlanner}</Text>
        </View>
        <Switch
          value={isSharingEnabled}
          onValueChange={setIsSharingEnabled}
          trackColor={{ false: '#d1d5db', true: '#86efac' }}
          thumbColor={isSharingEnabled ? '#22c55e' : '#f4f4f5'}
        />
      </View>
      
      <ScrollView style={styles.listContainer} contentContainerStyle={styles.listContent}>
        <View style={styles.locationCard}>
          <View style={styles.locationIcon}>
            <Ionicons name="navigate" size={24} color="#22c55e" />
          </View>
          <View style={styles.locationInfo}>
            <Text style={styles.locationTitle}>{t.yourLocation}</Text>
            <Text style={styles.locationCoords}>
              {location?.coords.latitude.toFixed(6)}, {location?.coords.longitude.toFixed(6)}
            </Text>
          </View>
        </View>

        {plannerLocations.length > 0 && (
          <View style={styles.plannerSection}>
            <Text style={styles.sectionTitle}>{t.planner}</Text>
            {plannerLocations.map((planner) => (
              <View key={planner.id} style={styles.plannerCard}>
                <View style={styles.plannerIcon}>
                  <Ionicons name="person" size={20} color="#8b5cf6" />
                </View>
                <View style={styles.locationInfo}>
                  <Text style={styles.locationTitle}>{planner.name}</Text>
                  <Text style={styles.locationCoords}>
                    {planner.latitude.toFixed(6)}, {planner.longitude.toFixed(6)}
                  </Text>
                </View>
              </View>
            ))}
          </View>
        )}

        <View style={styles.webNotice}>
          <Ionicons name="information-circle-outline" size={20} color="#64748b" />
          <Text style={styles.webNoticeText}>
            Map view is only available on mobile devices
          </Text>
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  sharingToggle: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#ffffff',
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  sharingInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  sharingText: {
    fontSize: 15,
    color: '#334155',
    fontWeight: '500',
  },
  listContainer: {
    flex: 1,
  },
  listContent: {
    padding: 16,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#64748b',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
    padding: 24,
  },
  errorText: {
    marginTop: 12,
    fontSize: 16,
    color: '#64748b',
    textAlign: 'center',
  },
  retryButton: {
    marginTop: 20,
    backgroundColor: '#22c55e',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 12,
  },
  retryButtonText: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
  locationCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    padding: 16,
    borderRadius: 12,
    marginBottom: 12,
    gap: 12,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  locationIcon: {
    width: 48,
    height: 48,
    backgroundColor: '#dcfce7',
    borderRadius: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  locationInfo: {
    flex: 1,
  },
  locationTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1e293b',
    marginBottom: 4,
  },
  locationCoords: {
    fontSize: 13,
    color: '#64748b',
    fontFamily: 'monospace',
  },
  plannerSection: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 12,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  plannerCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    padding: 16,
    borderRadius: 12,
    marginBottom: 8,
    gap: 12,
    borderWidth: 1,
    borderColor: '#e9d5ff',
  },
  plannerIcon: {
    width: 40,
    height: 40,
    backgroundColor: '#f3e8ff',
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  webNotice: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    marginTop: 24,
    padding: 16,
    backgroundColor: '#f1f5f9',
    borderRadius: 12,
  },
  webNoticeText: {
    fontSize: 14,
    color: '#64748b',
  },
});

=== File: src/screens/MerchantAnalyticsScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  RefreshControl,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MibuBrand } from '../../constants/Colors';

interface AnalyticsData {
  totalItineraryCards: number;
  totalCoupons: number;
  activeCoupons: number;
  couponRedemptions: number;
  dailyCollectionCount: number;
  totalCollectionUsers: number;
  collectionClickCount: number;
  couponUsageCount: number;
  couponUsageRate: number;
  prizePoolViews: number;
}

export function MerchantAnalyticsScreen() {
  const { state } = useApp();
  const router = useRouter();
  const isZh = state.language === 'zh-TW';

  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);
  const [analytics, setAnalytics] = useState<AnalyticsData | null>(null);

  const translations = {
    title: isZh ? 'æ•¸æ“šåˆ†æ' : 'Analytics',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    totalItineraryCards: isZh ? 'è¡Œç¨‹å¡ç¸½æ•¸' : 'Total Itinerary Cards',
    totalCoupons: isZh ? 'å„ªæƒ åˆ¸ç¸½æ•¸' : 'Total Coupons',
    activeCoupons: isZh ? 'å•Ÿç”¨ä¸­' : 'Active Coupons',
    couponRedemptions: isZh ? 'å„ªæƒ åˆ¸æ ¸éŠ·' : 'Coupon Redemptions',
    dailyCollection: isZh ? 'ä»Šæ—¥æ”¶éŒ„æ¬¡æ•¸' : 'Daily Collections',
    totalCollectionUsers: isZh ? 'ç´¯è¨ˆæ”¶éŒ„ç”¨æˆ¶' : 'Total Collection Users',
    collectionClicks: isZh ? 'åœ–é‘‘é»æ“Šæ¬¡æ•¸' : 'Collection Clicks',
    couponUsageCount: isZh ? 'å„ªæƒ åˆ¸ä½¿ç”¨æ¬¡æ•¸' : 'Coupon Usage Count',
    couponUsageRate: isZh ? 'ä½¿ç”¨ç‡' : 'Usage Rate',
    prizePoolViews: isZh ? 'çæ± ç€è¦½æ¬¡æ•¸' : 'Prize Pool Views',
    noData: isZh ? 'æš«ç„¡æ•¸æ“š' : 'No data',
    comingSoon: isZh ? 'å³å°‡æ¨å‡º' : 'Coming Soon',
    times: isZh ? 'æ¬¡' : 'times',
    count: isZh ? 'å¼µ' : '',
    users: isZh ? 'äºº' : 'users',
  };

  useEffect(() => {
    loadAnalytics();
  }, []);

  const loadAnalytics = async () => {
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      const response = await apiService.getMerchantAnalytics(token);
      if (response.success) {
        const a = response.analytics;
        const s = response.stats;
        setAnalytics({
          totalItineraryCards: a?.totalItineraryCards || 0,
          totalCoupons: a?.totalCoupons || s?.totalCoupons || 0,
          activeCoupons: a?.activeCoupons || s?.activeCoupons || 0,
          couponRedemptions: a?.couponRedemptions || s?.totalRedemptions || 0,
          dailyCollectionCount: a?.dailyCollectionCount || 0,
          totalCollectionUsers: a?.totalCollectionUsers || 0,
          collectionClickCount: a?.collectionClickCount || s?.viewCount || 0,
          couponUsageCount: a?.couponUsageCount || 0,
          couponUsageRate: a?.couponUsageRate || 0,
          prizePoolViews: a?.prizePoolViews || 0,
        });
      }
    } catch (error) {
      console.error('Failed to load analytics:', error);
    } finally {
      setLoading(false);
      setRefreshing(false);
    }
  };

  const handleRefresh = () => {
    setRefreshing(true);
    loadAnalytics();
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={MibuBrand.brown} />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  const StatCard = ({ 
    icon, 
    label, 
    value, 
    unit, 
    color = MibuBrand.brown,
    comingSoon = false 
  }: { 
    icon: string; 
    label: string; 
    value: number | undefined; 
    unit?: string;
    color?: string;
    comingSoon?: boolean;
  }) => (
    <View style={[styles.statCard, comingSoon && styles.statCardDisabled]}>
      <View style={[styles.statIcon, { backgroundColor: `${color}15` }]}>
        <Ionicons name={icon as any} size={24} color={color} />
      </View>
      <Text style={styles.statLabel}>{label}</Text>
      {comingSoon ? (
        <Text style={styles.comingSoon}>{translations.comingSoon}</Text>
      ) : (
        <Text style={styles.statValue}>
          {value !== undefined ? value : '-'}
          {unit && <Text style={styles.statUnit}> {unit}</Text>}
        </Text>
      )}
    </View>
  );

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color={MibuBrand.dark} />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
        <View style={styles.placeholder} />
      </View>

      <ScrollView 
        style={styles.content}
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
        }
      >
        <Text style={styles.sectionTitle}>
          {isZh ? 'è¡Œç¨‹å¡èˆ‡å„ªæƒ åˆ¸' : 'Itinerary Cards & Coupons'}
        </Text>
        <View style={styles.statsGrid}>
          <StatCard 
            icon="map-outline" 
            label={translations.totalItineraryCards} 
            value={analytics?.totalItineraryCards}
            unit={translations.count}
          />
          <StatCard 
            icon="pricetag-outline" 
            label={translations.totalCoupons} 
            value={analytics?.totalCoupons}
            unit={translations.count}
            color="#6366f1"
          />
          <StatCard 
            icon="checkmark-circle-outline" 
            label={translations.activeCoupons} 
            value={analytics?.activeCoupons}
            color="#10b981"
          />
          <StatCard 
            icon="ticket-outline" 
            label={translations.couponRedemptions} 
            value={analytics?.couponRedemptions}
            unit={translations.times}
            color="#f59e0b"
          />
        </View>

        <Text style={styles.sectionTitle}>
          {isZh ? 'åœ–é‘‘æ”¶éŒ„æ•¸æ“š' : 'Collection Statistics'}
        </Text>
        <View style={styles.statsGrid}>
          <StatCard 
            icon="today-outline" 
            label={translations.dailyCollection} 
            value={analytics?.dailyCollectionCount}
            unit={translations.times}
            color="#0891b2"
          />
          <StatCard 
            icon="people-outline" 
            label={translations.totalCollectionUsers} 
            value={analytics?.totalCollectionUsers}
            unit={translations.users}
            color="#7c3aed"
          />
          <StatCard 
            icon="hand-left-outline" 
            label={translations.collectionClicks} 
            value={analytics?.collectionClickCount}
            unit={translations.times}
            color="#db2777"
          />
        </View>

        <Text style={styles.sectionTitle}>
          {isZh ? 'å„ªæƒ åˆ¸ä½¿ç”¨æ•¸æ“š' : 'Coupon Usage Statistics'}
        </Text>
        <View style={styles.statsGrid}>
          <StatCard 
            icon="receipt-outline" 
            label={translations.couponUsageCount} 
            value={analytics?.couponUsageCount}
            unit={translations.times}
            color="#10b981"
          />
          <StatCard 
            icon="analytics-outline" 
            label={translations.couponUsageRate} 
            value={analytics?.couponUsageRate !== undefined 
              ? Math.round(analytics.couponUsageRate * 100) 
              : undefined}
            unit="%"
            color="#6366f1"
          />
          <StatCard 
            icon="gift-outline" 
            label={translations.prizePoolViews} 
            value={analytics?.prizePoolViews}
            unit={translations.times}
            color="#ea580c"
          />
        </View>
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: MibuBrand.creamLight,
  },
  loadingText: {
    marginTop: 12,
    fontSize: 14,
    color: '#64748b',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingHorizontal: 16,
    paddingTop: 60,
    paddingBottom: 16,
    backgroundColor: MibuBrand.cream,
    borderBottomWidth: 1,
    borderBottomColor: MibuBrand.tanLight,
  },
  backButton: {
    padding: 8,
  },
  title: {
    fontSize: 18,
    fontWeight: '600',
    color: MibuBrand.dark,
  },
  placeholder: {
    width: 40,
  },
  content: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 40,
  },
  sectionTitle: {
    fontSize: 16,
    fontWeight: '600',
    color: MibuBrand.dark,
    marginBottom: 12,
    marginTop: 8,
  },
  statsGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 12,
    marginBottom: 16,
  },
  statCard: {
    width: '47%',
    backgroundColor: '#fff',
    borderRadius: 16,
    padding: 16,
    borderWidth: 1,
    borderColor: MibuBrand.tanLight,
  },
  statCardDisabled: {
    opacity: 0.6,
  },
  statIcon: {
    width: 44,
    height: 44,
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 12,
  },
  statLabel: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 4,
  },
  statValue: {
    fontSize: 24,
    fontWeight: '700',
    color: MibuBrand.dark,
  },
  statUnit: {
    fontSize: 14,
    fontWeight: '400',
    color: '#94a3b8',
  },
  comingSoon: {
    fontSize: 12,
    color: '#94a3b8',
    fontStyle: 'italic',
  },
});

=== File: src/screens/MerchantCouponsScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  Alert,
  ActivityIndicator,
  Modal,
  Platform,
  KeyboardAvoidingView,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MerchantCoupon, MerchantCouponTier, CreateMerchantCouponParams, UpdateMerchantCouponParams } from '../types';
import { TierBadge } from '../components/TierBadge';
import { TIER_ORDER, getTierStyle } from '../constants/tierStyles';

export function MerchantCouponsScreen() {
  const { state } = useApp();
  const router = useRouter();
  const isZh = state.language === 'zh-TW';

  const [loading, setLoading] = useState(true);
  const [coupons, setCoupons] = useState<MerchantCoupon[]>([]);
  const [showModal, setShowModal] = useState(false);
  const [editingCoupon, setEditingCoupon] = useState<MerchantCoupon | null>(null);
  const [saving, setSaving] = useState(false);

  const [formData, setFormData] = useState<{
    name: string;
    tier: MerchantCouponTier;
    content: string;
    terms: string;
    quantity: string;
    validUntil: string;
  }>({
    name: '',
    tier: 'R',
    content: '',
    terms: '',
    quantity: '100',
    validUntil: '',
  });

  const translations = {
    title: isZh ? 'å„ªæƒ åˆ¸ç®¡ç†' : 'Coupon Management',
    addCoupon: isZh ? 'æ–°å¢å„ªæƒ åˆ¸' : 'Add Coupon',
    editCoupon: isZh ? 'ç·¨è¼¯å„ªæƒ åˆ¸' : 'Edit Coupon',
    name: isZh ? 'å„ªæƒ åˆ¸åç¨±' : 'Coupon Name',
    tier: isZh ? 'ç¨€æœ‰åº¦ç­‰ç´š' : 'Rarity Tier',
    content: isZh ? 'å„ªæƒ å…§å®¹' : 'Discount Content',
    terms: isZh ? 'ä½¿ç”¨æ¢æ¬¾' : 'Terms & Conditions',
    quantity: isZh ? 'ç™¼æ”¾æ•¸é‡' : 'Quantity',
    validUntil: isZh ? 'æœ‰æ•ˆæœŸé™ (YYYY-MM-DD)' : 'Valid Until (YYYY-MM-DD)',
    save: isZh ? 'å„²å­˜' : 'Save',
    cancel: isZh ? 'å–æ¶ˆ' : 'Cancel',
    delete: isZh ? 'åˆªé™¤' : 'Delete',
    remaining: isZh ? 'å‰©é¤˜' : 'Remaining',
    active: isZh ? 'å•Ÿç”¨ä¸­' : 'Active',
    inactive: isZh ? 'å·²åœç”¨' : 'Inactive',
    expired: isZh ? 'å·²éæœŸ' : 'Expired',
    noCoupons: isZh ? 'å°šæœªå‰µå»ºå„ªæƒ åˆ¸' : 'No coupons yet',
    confirmDelete: isZh ? 'ç¢ºå®šè¦åˆªé™¤æ­¤å„ªæƒ åˆ¸å—ï¼Ÿ' : 'Delete this coupon?',
    tierProbability: isZh ? 'æŠ½ä¸­æ©Ÿç‡' : 'Draw Probability',
  };

  useEffect(() => {
    loadCoupons();
  }, []);

  const loadCoupons = async () => {
    try {
      setLoading(true);
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      const response = await apiService.getMerchantCoupons(token);
      setCoupons(response.coupons || []);
    } catch (error) {
      console.error('Failed to load coupons:', error);
    } finally {
      setLoading(false);
    }
  };

  const openCreateModal = () => {
    setEditingCoupon(null);
    setFormData({
      name: '',
      tier: 'R',
      content: '',
      terms: '',
      quantity: '100',
      validUntil: '',
    });
    setShowModal(true);
  };

  const openEditModal = (coupon: MerchantCoupon) => {
    setEditingCoupon(coupon);
    setFormData({
      name: coupon.name,
      tier: coupon.tier,
      content: coupon.content,
      terms: coupon.terms || '',
      quantity: String(coupon.quantity),
      validUntil: coupon.validUntil ? coupon.validUntil.split('T')[0] : '',
    });
    setShowModal(true);
  };

  const handleSave = async () => {
    if (!formData.name.trim() || !formData.content.trim()) {
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è«‹å¡«å¯«å¿…è¦æ¬„ä½' : 'Please fill required fields');
      return;
    }

    setSaving(true);
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      const parsedQuantity = parseInt(formData.quantity, 10);
      const quantity = isNaN(parsedQuantity) || parsedQuantity < 1 ? 100 : parsedQuantity;

      if (editingCoupon) {
        const updateParams: UpdateMerchantCouponParams = {};
        if (formData.name.trim() !== editingCoupon.name) {
          updateParams.name = formData.name.trim();
        }
        if (formData.tier !== editingCoupon.tier) {
          updateParams.tier = formData.tier;
        }
        if (formData.content.trim() !== editingCoupon.content) {
          updateParams.content = formData.content.trim();
        }
        if (formData.terms.trim() !== (editingCoupon.terms || '')) {
          updateParams.terms = formData.terms.trim() || undefined;
        }
        if (quantity !== editingCoupon.quantity) {
          updateParams.quantity = quantity;
        }
        const validUntilVal = formData.validUntil || undefined;
        const existingValidUntil = editingCoupon.validUntil ? editingCoupon.validUntil.split('T')[0] : undefined;
        if (validUntilVal !== existingValidUntil) {
          updateParams.validUntil = validUntilVal;
        }
        
        if (Object.keys(updateParams).length > 0) {
          await apiService.updateMerchantCoupon(token, editingCoupon.id, updateParams);
        }
      } else {
        const createParams: CreateMerchantCouponParams = {
          name: formData.name.trim(),
          tier: formData.tier,
          content: formData.content.trim(),
          terms: formData.terms.trim() || undefined,
          quantity,
          validUntil: formData.validUntil || undefined,
          isActive: true,
        };
        await apiService.createMerchantCoupon(token, createParams);
      }

      setShowModal(false);
      loadCoupons();
    } catch (error) {
      console.error('Save failed:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'å„²å­˜å¤±æ•—' : 'Save failed');
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = async (couponId: number) => {
    Alert.alert(
      isZh ? 'ç¢ºèªåˆªé™¤' : 'Confirm Delete',
      translations.confirmDelete,
      [
        { text: translations.cancel, style: 'cancel' },
        {
          text: translations.delete,
          style: 'destructive',
          onPress: async () => {
            try {
              const token = await AsyncStorage.getItem('@mibu_token');
              if (!token) return;

              await apiService.deleteMerchantCoupon(token, couponId);
              loadCoupons();
            } catch (error) {
              Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'åˆªé™¤å¤±æ•—' : 'Delete failed');
            }
          },
        },
      ]
    );
  };

  const toggleActive = async (coupon: MerchantCoupon) => {
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      await apiService.updateMerchantCoupon(token, coupon.id, { isActive: !coupon.isActive });
      loadCoupons();
    } catch (error) {
      console.error('Toggle failed:', error);
    }
  };

  const formatDate = (dateStr: string | null) => {
    if (!dateStr) return '-';
    return new Date(dateStr).toLocaleDateString(isZh ? 'zh-TW' : 'en-US');
  };

  const isExpired = (dateStr: string | null) => {
    if (!dateStr) return false;
    return new Date(dateStr) < new Date();
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
      </View>
    );
  }

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={100}
    >
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{translations.title}</Text>
        <TouchableOpacity onPress={openCreateModal} style={styles.addButton}>
          <Ionicons name="add" size={24} color="#ffffff" />
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
        <View style={styles.probabilityInfo}>
          <Text style={styles.probabilityTitle}>{translations.tierProbability}</Text>
          <View style={styles.probabilityGrid}>
            {TIER_ORDER.map(tier => {
              const style = getTierStyle(tier);
              return (
                <View key={tier} style={styles.probabilityItem}>
                  <TierBadge tier={tier} isZh={isZh} size="small" />
                  <Text style={[styles.probabilityValue, { color: style.textColor }]}>
                    {style.probability}%
                  </Text>
                </View>
              );
            })}
          </View>
        </View>

        {coupons.length === 0 ? (
          <View style={styles.emptyState}>
            <Ionicons name="pricetag-outline" size={64} color="#cbd5e1" />
            <Text style={styles.emptyText}>{translations.noCoupons}</Text>
            <TouchableOpacity style={styles.emptyAddButton} onPress={openCreateModal}>
              <Ionicons name="add" size={20} color="#ffffff" />
              <Text style={styles.emptyAddText}>{translations.addCoupon}</Text>
            </TouchableOpacity>
          </View>
        ) : (
          coupons.map(coupon => (
            <TouchableOpacity
              key={coupon.id}
              style={[
                styles.couponCard,
                !coupon.isActive && styles.couponCardInactive,
              ]}
              onPress={() => openEditModal(coupon)}
            >
              <View style={styles.couponHeader}>
                <TierBadge tier={coupon.tier} isZh={isZh} />
                <View style={[
                  styles.statusBadge,
                  coupon.isActive
                    ? (isExpired(coupon.validUntil) ? styles.statusExpired : styles.statusActive)
                    : styles.statusInactive
                ]}>
                  <Text style={styles.statusText}>
                    {coupon.isActive
                      ? (isExpired(coupon.validUntil) ? translations.expired : translations.active)
                      : translations.inactive}
                  </Text>
                </View>
              </View>

              <Text style={styles.couponName}>{coupon.name}</Text>
              <Text style={styles.couponContent}>{coupon.content}</Text>

              <View style={styles.couponMeta}>
                <View style={styles.metaItem}>
                  <Ionicons name="layers-outline" size={14} color="#64748b" />
                  <Text style={styles.metaText}>
                    {translations.remaining}: {coupon.remainingQuantity}/{coupon.quantity}
                  </Text>
                </View>
                {coupon.validUntil && (
                  <View style={styles.metaItem}>
                    <Ionicons name="calendar-outline" size={14} color="#64748b" />
                    <Text style={styles.metaText}>{formatDate(coupon.validUntil)}</Text>
                  </View>
                )}
              </View>

              <View style={styles.couponActions}>
                <TouchableOpacity
                  style={styles.actionButton}
                  onPress={() => toggleActive(coupon)}
                >
                  <Ionicons
                    name={coupon.isActive ? 'pause-circle-outline' : 'play-circle-outline'}
                    size={20}
                    color={coupon.isActive ? '#f59e0b' : '#22c55e'}
                  />
                </TouchableOpacity>
                <TouchableOpacity
                  style={styles.actionButton}
                  onPress={() => handleDelete(coupon.id)}
                >
                  <Ionicons name="trash-outline" size={20} color="#ef4444" />
                </TouchableOpacity>
              </View>
            </TouchableOpacity>
          ))
        )}

        <View style={{ height: 100 }} />
      </ScrollView>

      <Modal visible={showModal} animationType="slide" transparent>
        <KeyboardAvoidingView
          style={styles.modalOverlay}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        >
          <View style={styles.modalContent}>
            <View style={styles.modalHeader}>
              <Text style={styles.modalTitle}>
                {editingCoupon ? translations.editCoupon : translations.addCoupon}
              </Text>
              <TouchableOpacity onPress={() => setShowModal(false)}>
                <Ionicons name="close" size={24} color="#64748b" />
              </TouchableOpacity>
            </View>

            <ScrollView style={styles.modalBody} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
              <Text style={styles.inputLabel}>{translations.name} *</Text>
              <TextInput
                style={styles.input}
                value={formData.name}
                onChangeText={text => setFormData({ ...formData, name: text })}
                placeholder={isZh ? 'ä¾‹ï¼šä¹æŠ˜å„ªæƒ ' : 'e.g., 10% Off'}
                placeholderTextColor="#94a3b8"
              />

              <Text style={styles.inputLabel}>{translations.tier}</Text>
              <View style={styles.tierGrid}>
                {TIER_ORDER.map(tier => {
                  const tierStyle = getTierStyle(tier);
                  return (
                    <TouchableOpacity
                      key={tier}
                      style={[
                        styles.tierOption,
                        formData.tier === tier && {
                          backgroundColor: tierStyle.backgroundColor,
                          borderColor: tierStyle.borderColor,
                        },
                      ]}
                      onPress={() => setFormData({ ...formData, tier })}
                    >
                      <Text style={[
                        styles.tierOptionText,
                        formData.tier === tier && { color: tierStyle.textColor, fontWeight: '700' },
                      ]}>
                        {tier} ({tierStyle.probability}%)
                      </Text>
                    </TouchableOpacity>
                  );
                })}
              </View>

              <Text style={styles.inputLabel}>{translations.content} *</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={formData.content}
                onChangeText={text => setFormData({ ...formData, content: text })}
                placeholder={isZh ? 'å„ªæƒ è©³ç´°å…§å®¹' : 'Discount details'}
                placeholderTextColor="#94a3b8"
                multiline
                numberOfLines={3}
              />

              <Text style={styles.inputLabel}>{translations.terms}</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={formData.terms}
                onChangeText={text => setFormData({ ...formData, terms: text })}
                placeholder={isZh ? 'ä½¿ç”¨æ¢æ¬¾ï¼ˆé¸å¡«ï¼‰' : 'Terms (optional)'}
                placeholderTextColor="#94a3b8"
                multiline
                numberOfLines={2}
              />

              <View style={styles.inputRow}>
                <View style={styles.inputHalf}>
                  <Text style={styles.inputLabel}>{translations.quantity}</Text>
                  <TextInput
                    style={styles.input}
                    value={formData.quantity}
                    onChangeText={text => setFormData({ ...formData, quantity: text.replace(/[^0-9]/g, '') })}
                    keyboardType="number-pad"
                    placeholder="100"
                    placeholderTextColor="#94a3b8"
                  />
                </View>
                <View style={styles.inputHalf}>
                  <Text style={styles.inputLabel}>{translations.validUntil}</Text>
                  <TextInput
                    style={styles.input}
                    value={formData.validUntil}
                    onChangeText={text => setFormData({ ...formData, validUntil: text })}
                    placeholder="2025-12-31"
                    placeholderTextColor="#94a3b8"
                  />
                </View>
              </View>
            </ScrollView>

            <View style={styles.modalFooter}>
              <TouchableOpacity
                style={styles.cancelButton}
                onPress={() => setShowModal(false)}
              >
                <Text style={styles.cancelButtonText}>{translations.cancel}</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[styles.saveButton, saving && styles.saveButtonDisabled]}
                onPress={handleSave}
                disabled={saving}
              >
                {saving ? (
                  <ActivityIndicator color="#ffffff" size="small" />
                ) : (
                  <Text style={styles.saveButtonText}>{translations.save}</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: Platform.OS === 'ios' ? 60 : 40,
    paddingHorizontal: 16,
    paddingBottom: 16,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  addButton: {
    width: 40,
    height: 40,
    backgroundColor: '#6366f1',
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    flex: 1,
    padding: 16,
  },
  probabilityInfo: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    marginBottom: 16,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  probabilityTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 12,
  },
  probabilityGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
  },
  probabilityItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
  },
  probabilityValue: {
    fontSize: 12,
    fontWeight: '600',
  },
  emptyState: {
    alignItems: 'center',
    paddingVertical: 60,
  },
  emptyText: {
    fontSize: 16,
    color: '#94a3b8',
    marginTop: 16,
    marginBottom: 24,
  },
  emptyAddButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    backgroundColor: '#6366f1',
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 12,
  },
  emptyAddText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
  couponCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  couponCardInactive: {
    opacity: 0.6,
  },
  couponHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 6,
  },
  statusActive: {
    backgroundColor: '#dcfce7',
  },
  statusInactive: {
    backgroundColor: '#f1f5f9',
  },
  statusExpired: {
    backgroundColor: '#fef2f2',
  },
  statusText: {
    fontSize: 11,
    fontWeight: '600',
    color: '#334155',
  },
  couponName: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 6,
  },
  couponContent: {
    fontSize: 14,
    color: '#64748b',
    lineHeight: 20,
    marginBottom: 12,
  },
  couponMeta: {
    flexDirection: 'row',
    gap: 16,
    marginBottom: 12,
  },
  metaItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 4,
  },
  metaText: {
    fontSize: 12,
    color: '#64748b',
  },
  couponActions: {
    flexDirection: 'row',
    justifyContent: 'flex-end',
    gap: 8,
    borderTopWidth: 1,
    borderTopColor: '#f1f5f9',
    paddingTop: 12,
  },
  actionButton: {
    padding: 8,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    maxHeight: '90%',
  },
  modalHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1e293b',
  },
  modalBody: {
    padding: 20,
  },
  inputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#334155',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f8fafc',
    borderRadius: 12,
    padding: 14,
    fontSize: 16,
    color: '#1e293b',
    borderWidth: 1,
    borderColor: '#e2e8f0',
    marginBottom: 16,
  },
  textArea: {
    minHeight: 80,
    textAlignVertical: 'top',
  },
  tierGrid: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 16,
  },
  tierOption: {
    paddingHorizontal: 14,
    paddingVertical: 10,
    borderRadius: 10,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    backgroundColor: '#f8fafc',
  },
  tierOptionText: {
    fontSize: 13,
    color: '#64748b',
  },
  inputRow: {
    flexDirection: 'row',
    gap: 12,
  },
  inputHalf: {
    flex: 1,
  },
  modalFooter: {
    flexDirection: 'row',
    gap: 12,
    padding: 20,
    borderTopWidth: 1,
    borderTopColor: '#e2e8f0',
  },
  cancelButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#f1f5f9',
    alignItems: 'center',
  },
  cancelButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#64748b',
  },
  saveButton: {
    flex: 1,
    paddingVertical: 14,
    borderRadius: 12,
    backgroundColor: '#6366f1',
    alignItems: 'center',
  },
  saveButtonDisabled: {
    opacity: 0.7,
  },
  saveButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
});

=== File: src/screens/MerchantDashboardScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Linking,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MerchantDailyCode, MerchantCredits } from '../types';
import { RoleSwitcher } from '../components/RoleSwitcher';
import { MibuBrand } from '../../constants/Colors';

export function MerchantDashboardScreen() {
  const { state, getToken, setUser } = useApp();
  const router = useRouter();
  const [dailyCode, setDailyCode] = useState<MerchantDailyCode | null>(null);
  const [credits, setCredits] = useState<MerchantCredits | null>(null);
  const [loading, setLoading] = useState(true);
  const [purchasing, setPurchasing] = useState(false);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å•†å®¶å¾Œå°' : 'Merchant Dashboard',
    dailyCode: isZh ? 'ä»Šæ—¥æ ¸éŠ·ç¢¼' : "Today's Verification Code",
    expiresAt: isZh ? 'æœ‰æ•ˆæœŸè‡³' : 'Valid until',
    credits: isZh ? 'é»æ•¸é¤˜é¡' : 'Credit Balance',
    points: isZh ? 'é»' : 'pts',
    topUp: isZh ? 'å„²å€¼' : 'Top Up',
    useStripe: isZh ? 'ä½¿ç”¨ Stripe ä»˜æ¬¾' : 'Pay with Stripe',
    useRecur: isZh ? 'ä½¿ç”¨ Recur ä»˜æ¬¾' : 'Pay with Recur',
    purchaseAmount: isZh ? 'è³¼è²·é»æ•¸' : 'Purchase Credits',
    min100: isZh ? 'æœ€ä½ 100 é»' : 'Minimum 100 points',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    error: isZh ? 'è¼‰å…¥å¤±æ•—' : 'Failed to load',
    logout: isZh ? 'ç™»å‡º' : 'Logout',
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem('@mibu_token');
    await AsyncStorage.removeItem('@mibu_user');
    setUser(null);
    router.replace('/login');
  };

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;

      const [codeData, creditsData] = await Promise.all([
        apiService.getMerchantDailyCode(token).catch(() => null),
        apiService.getMerchantCredits(token).catch(() => null),
      ]);

      setDailyCode(codeData);
      setCredits(creditsData);
    } catch (error) {
      console.error('Failed to load merchant data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handlePurchase = async (provider: 'stripe' | 'recur', amount: number) => {
    try {
      setPurchasing(true);
      const token = await getToken();
      if (!token) return;

      const response = await apiService.purchaseCredits(token, amount, provider);
      
      if (response.checkoutUrl) {
        await Linking.openURL(response.checkoutUrl);
      } else {
        Alert.alert(
          isZh ? 'æˆåŠŸ' : 'Success',
          response.message || (isZh ? 'äº¤æ˜“å·²å»ºç«‹' : 'Transaction created')
        );
      }
    } catch (error) {
      console.error('Purchase failed:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'è³¼è²·å¤±æ•—' : 'Purchase failed');
    } finally {
      setPurchasing(false);
    }
  };

  const formatExpiry = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleString(isZh ? 'zh-TW' : 'en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <View style={styles.header}>
        <View style={styles.headerLeft}>
          <Text style={styles.title}>{translations.title}</Text>
          {state.user?.isSuperAdmin && <RoleSwitcher compact />}
        </View>
        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <Ionicons name="log-out-outline" size={20} color="#ef4444" />
          <Text style={styles.logoutText}>{translations.logout}</Text>
        </TouchableOpacity>
      </View>

      <View style={styles.codeCard}>
        <Text style={styles.cardLabel}>{translations.dailyCode}</Text>
        {dailyCode ? (
          <>
            <Text style={styles.codeText}>{dailyCode.code}</Text>
            <Text style={styles.expiryText}>
              {translations.expiresAt}: {formatExpiry(dailyCode.expiresAt)}
            </Text>
          </>
        ) : (
          <Text style={styles.errorText}>{translations.error}</Text>
        )}
      </View>

      <View style={styles.creditsCard}>
        <View style={styles.creditsHeader}>
          <Ionicons name="wallet-outline" size={24} color={MibuBrand.brown} />
          <Text style={styles.cardLabel}>{translations.credits}</Text>
        </View>
        <Text style={styles.creditsAmount}>
          {credits?.creditBalance ?? 0}
          <Text style={styles.creditsUnit}> {translations.points}</Text>
        </Text>
      </View>

      <View style={styles.menuSection}>
        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/merchant/analytics' as any)}
        >
          <View style={[styles.menuIcon, { backgroundColor: MibuBrand.highlight }]}>
            <Ionicons name="stats-chart-outline" size={24} color={MibuBrand.brown} />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'æ•¸æ“šåˆ†æ' : 'Analytics'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'æŸ¥çœ‹åº—å®¶èˆ‡å„ªæƒ åˆ¸çµ±è¨ˆ' : 'View statistics and insights'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/merchant/transactions' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="receipt-outline" size={24} color={MibuBrand.brown} />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'äº¤æ˜“è¨˜éŒ„' : 'Transaction History'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'æŸ¥çœ‹æ‰€æœ‰äº¤æ˜“' : 'View all transactions'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/merchant/verify' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="shield-checkmark-outline" size={24} color={MibuBrand.brown} />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'é©—è­‰æ ¸éŠ·ç¢¼' : 'Verify Code'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'é©—è­‰å…¶ä»–å•†å®¶çš„æ ¸éŠ·ç¢¼' : 'Verify merchant codes'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/merchant/places' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="storefront-outline" size={24} color={MibuBrand.brown} />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'åº—å®¶ç®¡ç†' : 'Place Management'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'èªé ˜èˆ‡ç®¡ç†åº—å®¶' : 'Claim and manage places'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/merchant/products' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="cube-outline" size={24} color={MibuBrand.brown} />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'å•†å“ç®¡ç†' : 'Product Management'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'å»ºç«‹èˆ‡ç·¨è¼¯å•†å“' : 'Create and edit products'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/merchant/coupons' as any)}
        >
          <View style={[styles.menuIcon, { backgroundColor: MibuBrand.highlight }]}>
            <Ionicons name="pricetag-outline" size={24} color={MibuBrand.warning} />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'å„ªæƒ åˆ¸ç®¡ç†' : 'Coupon Management'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'å‰µå»ºèˆ‡ç®¡ç†å„ªæƒ åˆ¸' : 'Create and manage coupons'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/merchant/profile' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="person-circle-outline" size={24} color={MibuBrand.brown} />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'å•†å®¶è³‡æ–™' : 'Merchant Profile'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'æŸ¥çœ‹å•†å®¶è³‡è¨Š' : 'View merchant info'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>
      </View>

      <View style={styles.topUpSection}>
        <Text style={styles.sectionTitle}>{translations.topUp}</Text>
        <Text style={styles.sectionSubtitle}>{translations.min100}</Text>

        <View style={styles.amountButtons}>
          {[100, 500, 1000].map(amount => (
            <TouchableOpacity
              key={amount}
              style={styles.amountButton}
              onPress={() => handlePurchase('stripe', amount)}
              disabled={purchasing}
            >
              <Text style={styles.amountButtonText}>{amount} {translations.points}</Text>
            </TouchableOpacity>
          ))}
        </View>

        <View style={styles.paymentButtons}>
          <TouchableOpacity
            style={[styles.paymentButton, styles.stripeButton]}
            onPress={() => handlePurchase('stripe', 500)}
            disabled={purchasing}
          >
            {purchasing ? (
              <ActivityIndicator size="small" color="#ffffff" />
            ) : (
              <>
                <Ionicons name="card-outline" size={20} color="#ffffff" />
                <Text style={styles.paymentButtonText}>{translations.useStripe}</Text>
              </>
            )}
          </TouchableOpacity>

          <TouchableOpacity
            style={[styles.paymentButton, styles.recurButton]}
            onPress={() => handlePurchase('recur', 500)}
            disabled={purchasing}
          >
            {purchasing ? (
              <ActivityIndicator size="small" color="#ffffff" />
            ) : (
              <>
                <Ionicons name="repeat-outline" size={20} color="#ffffff" />
                <Text style={styles.paymentButtonText}>{translations.useRecur}</Text>
              </>
            )}
          </TouchableOpacity>
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: MibuBrand.copper,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 24,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  title: {
    fontSize: 28,
    fontWeight: '900',
    color: MibuBrand.brown,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 14,
    backgroundColor: '#fef2f2',
    borderRadius: 12,
  },
  logoutText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#ef4444',
  },
  codeCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 20,
    padding: 24,
    alignItems: 'center',
    marginBottom: 16,
    borderWidth: 2,
    borderColor: MibuBrand.brown,
  },
  cardLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: MibuBrand.copper,
    marginBottom: 12,
  },
  codeText: {
    fontSize: 48,
    fontWeight: '900',
    color: MibuBrand.brown,
    letterSpacing: 8,
    marginBottom: 8,
  },
  expiryText: {
    fontSize: 13,
    color: MibuBrand.copper,
  },
  errorText: {
    fontSize: 16,
    color: MibuBrand.error,
  },
  creditsCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 20,
    padding: 24,
    marginBottom: 24,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  creditsHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    marginBottom: 12,
  },
  creditsAmount: {
    fontSize: 36,
    fontWeight: '800',
    color: MibuBrand.dark,
  },
  creditsUnit: {
    fontSize: 18,
    fontWeight: '600',
    color: MibuBrand.copper,
  },
  menuSection: {
    marginBottom: 24,
    gap: 12,
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    padding: 16,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  menuIcon: {
    width: 44,
    height: 44,
    borderRadius: 12,
    backgroundColor: MibuBrand.highlight,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  menuContent: {
    flex: 1,
  },
  menuTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: MibuBrand.dark,
    marginBottom: 2,
  },
  menuSubtitle: {
    fontSize: 13,
    color: MibuBrand.copper,
  },
  topUpSection: {
    marginTop: 8,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: MibuBrand.dark,
    marginBottom: 4,
  },
  sectionSubtitle: {
    fontSize: 13,
    color: MibuBrand.copper,
    marginBottom: 16,
  },
  amountButtons: {
    flexDirection: 'row',
    gap: 12,
    marginBottom: 16,
  },
  amountButton: {
    flex: 1,
    backgroundColor: MibuBrand.warmWhite,
    paddingVertical: 16,
    borderRadius: 12,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  amountButtonText: {
    fontSize: 14,
    fontWeight: '700',
    color: MibuBrand.dark,
  },
  paymentButtons: {
    gap: 12,
  },
  paymentButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 16,
    borderRadius: 16,
  },
  stripeButton: {
    backgroundColor: MibuBrand.brown,
  },
  recurButton: {
    backgroundColor: MibuBrand.success,
  },
  paymentButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
});

=== File: src/screens/MerchantPlacesScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MerchantPlace, PlaceSearchResult } from '../types';

export function MerchantPlacesScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [places, setPlaces] = useState<MerchantPlace[]>([]);
  const [searchResults, setSearchResults] = useState<PlaceSearchResult[]>([]);
  const [searchQuery, setSearchQuery] = useState('');
  const [loading, setLoading] = useState(true);
  const [searching, setSearching] = useState(false);
  const [claiming, setClaiming] = useState<string | null>(null);
  const [showSearch, setShowSearch] = useState(false);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'åº—å®¶ç®¡ç†' : 'Place Management',
    myPlaces: isZh ? 'æˆ‘çš„åº—å®¶' : 'My Places',
    noPlaces: isZh ? 'å°šæœªèªé ˜ä»»ä½•åº—å®¶' : 'No places claimed yet',
    claimNew: isZh ? 'èªé ˜æ–°åº—å®¶' : 'Claim New Place',
    search: isZh ? 'æœå°‹åº—å®¶åç¨±...' : 'Search place name...',
    searchBtn: isZh ? 'æœå°‹' : 'Search',
    claim: isZh ? 'èªé ˜' : 'Claim',
    claimed: isZh ? 'å·²èªé ˜' : 'Claimed',
    verified: isZh ? 'å·²é©—è­‰' : 'Verified',
    pending: isZh ? 'å¾…é©—è­‰' : 'Pending',
    noResults: isZh ? 'æ‰¾ä¸åˆ°ç¬¦åˆçš„åº—å®¶' : 'No matching places found',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    cancel: isZh ? 'å–æ¶ˆ' : 'Cancel',
    claimSuccess: isZh ? 'èªé ˜æˆåŠŸï¼' : 'Claimed successfully!',
    claimFailed: isZh ? 'èªé ˜å¤±æ•—' : 'Claim failed',
    back: isZh ? 'è¿”å›' : 'Back',
  };

  useEffect(() => {
    loadPlaces();
  }, []);

  const loadPlaces = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;
      const data = await apiService.getMerchantPlaces(token);
      setPlaces(data.places || []);
    } catch (error) {
      console.error('Failed to load places:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    try {
      setSearching(true);
      const token = await getToken();
      if (!token) {
        router.push('/login');
        return;
      }
      const data = await apiService.searchMerchantPlaces(token, searchQuery);
      setSearchResults(data.places || []);
    } catch (error: any) {
      console.error('Search failed:', error);
      if (error.message === 'UNAUTHORIZED') {
        router.push('/login');
        return;
      }
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', isZh ? 'æœå°‹å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Search failed, please try again');
    } finally {
      setSearching(false);
    }
  };

  const handleClaim = async (place: PlaceSearchResult) => {
    try {
      setClaiming(place.placeId);
      const token = await getToken();
      if (!token) return;
      await apiService.claimMerchantPlace(token, {
        placeName: place.placeName,
        district: place.district,
        city: place.city,
        country: 'å°ç£',
        placeCacheId: String(place.id),
        googlePlaceId: place.placeId,
      });
      Alert.alert(isZh ? 'æˆåŠŸ' : 'Success', translations.claimSuccess);
      setShowSearch(false);
      setSearchQuery('');
      setSearchResults([]);
      loadPlaces();
    } catch (error) {
      console.error('Claim failed:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', translations.claimFailed);
    } finally {
      setClaiming(null);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={100}
    >
      <ScrollView contentContainerStyle={styles.content} keyboardShouldPersistTaps="handled">
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
      </View>

      {!showSearch ? (
        <>
          <TouchableOpacity
            style={styles.claimButton}
            onPress={() => setShowSearch(true)}
          >
            <Ionicons name="add-circle-outline" size={24} color="#ffffff" />
            <Text style={styles.claimButtonText}>{translations.claimNew}</Text>
          </TouchableOpacity>

          <Text style={styles.sectionTitle}>{translations.myPlaces}</Text>

          {places.length === 0 ? (
            <View style={styles.emptyCard}>
              <Ionicons name="storefront-outline" size={48} color="#94a3b8" />
              <Text style={styles.emptyText}>{translations.noPlaces}</Text>
            </View>
          ) : (
            <View style={styles.placesList}>
              {places.map(place => (
                <View key={place.id} style={styles.placeCard}>
                  <View style={styles.placeIcon}>
                    <Ionicons name="storefront" size={24} color="#6366f1" />
                  </View>
                  <View style={styles.placeInfo}>
                    <Text style={styles.placeName}>{place.placeName}</Text>
                    <Text style={styles.placeLocation}>
                      {place.district ? `${place.district}, ` : ''}{place.city || ''}
                    </Text>
                  </View>
                  <View style={[
                    styles.statusBadge,
                    place.isVerified ? styles.verifiedBadge : styles.pendingBadge
                  ]}>
                    <Text style={[
                      styles.statusText,
                      place.isVerified ? styles.verifiedText : styles.pendingText
                    ]}>
                      {place.isVerified ? translations.verified : translations.pending}
                    </Text>
                  </View>
                </View>
              ))}
            </View>
          )}
        </>
      ) : (
        <>
          <View style={styles.searchSection}>
            <View style={styles.searchInputContainer}>
              <TextInput
                style={styles.searchInput}
                value={searchQuery}
                onChangeText={setSearchQuery}
                placeholder={translations.search}
                placeholderTextColor="#94a3b8"
                onSubmitEditing={handleSearch}
              />
              <TouchableOpacity
                style={styles.searchButton}
                onPress={handleSearch}
                disabled={searching}
              >
                {searching ? (
                  <ActivityIndicator size="small" color="#ffffff" />
                ) : (
                  <Ionicons name="search" size={20} color="#ffffff" />
                )}
              </TouchableOpacity>
            </View>
            <TouchableOpacity
              style={styles.cancelButton}
              onPress={() => {
                setShowSearch(false);
                setSearchQuery('');
                setSearchResults([]);
              }}
            >
              <Text style={styles.cancelButtonText}>{translations.cancel}</Text>
            </TouchableOpacity>
          </View>

          {searchResults.length === 0 && searchQuery && !searching ? (
            <View style={styles.emptyCard}>
              <Ionicons name="search-outline" size={48} color="#94a3b8" />
              <Text style={styles.emptyText}>{translations.noResults}</Text>
            </View>
          ) : (
            <View style={styles.placesList}>
              {searchResults.map(result => (
                <View key={result.placeId} style={styles.placeCard}>
                  <View style={styles.placeIcon}>
                    <Ionicons name="location" size={24} color="#6366f1" />
                  </View>
                  <View style={styles.placeInfo}>
                    <Text style={styles.placeName}>{result.placeName}</Text>
                    <Text style={styles.placeLocation}>
                      {result.district ? `${result.district}, ` : ''}{result.city || ''}
                    </Text>
                  </View>
                  {result.isClaimed ? (
                    <View style={styles.claimedBadge}>
                      <Text style={styles.claimedText}>{translations.claimed}</Text>
                    </View>
                  ) : (
                    <TouchableOpacity
                      style={styles.claimBadge}
                      onPress={() => handleClaim(result)}
                      disabled={claiming === result.placeId}
                    >
                      {claiming === result.placeId ? (
                        <ActivityIndicator size="small" color="#ffffff" />
                      ) : (
                        <Text style={styles.claimBadgeText}>{translations.claim}</Text>
                      )}
                    </TouchableOpacity>
                  )}
                </View>
              ))}
            </View>
          )}
        </>
      )}
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 24,
    gap: 12,
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  title: {
    fontSize: 24,
    fontWeight: '900',
    color: '#1e293b',
  },
  claimButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: '#6366f1',
    paddingVertical: 16,
    borderRadius: 16,
    marginBottom: 24,
  },
  claimButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 16,
  },
  emptyCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 12,
  },
  placesList: {
    gap: 12,
  },
  placeCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  placeIcon: {
    width: 48,
    height: 48,
    borderRadius: 12,
    backgroundColor: '#eef2ff',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  placeInfo: {
    flex: 1,
  },
  placeName: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  placeLocation: {
    fontSize: 13,
    color: '#64748b',
  },
  statusBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  verifiedBadge: {
    backgroundColor: '#dcfce7',
  },
  pendingBadge: {
    backgroundColor: '#fef3c7',
  },
  statusText: {
    fontSize: 12,
    fontWeight: '600',
  },
  verifiedText: {
    color: '#16a34a',
  },
  pendingText: {
    color: '#d97706',
  },
  searchSection: {
    marginBottom: 20,
    gap: 12,
  },
  searchInputContainer: {
    flexDirection: 'row',
    gap: 12,
  },
  searchInput: {
    flex: 1,
    backgroundColor: '#ffffff',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 16,
    borderWidth: 2,
    borderColor: '#e2e8f0',
    color: '#1e293b',
  },
  searchButton: {
    width: 52,
    backgroundColor: '#6366f1',
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
  },
  cancelButton: {
    alignItems: 'center',
    paddingVertical: 12,
  },
  cancelButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
  },
  claimedBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    backgroundColor: '#f1f5f9',
  },
  claimedText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#64748b',
  },
  claimBadge: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
    backgroundColor: '#6366f1',
  },
  claimBadgeText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#ffffff',
  },
});

=== File: src/screens/MerchantProductsScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  TextInput,
  ActivityIndicator,
  Alert,
  Modal,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MerchantProduct } from '../types';

export function MerchantProductsScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [products, setProducts] = useState<MerchantProduct[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [modalVisible, setModalVisible] = useState(false);
  const [editingProduct, setEditingProduct] = useState<MerchantProduct | null>(null);
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    price: '',
    discountPrice: '',
  });

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å•†å“ç®¡ç†' : 'Product Management',
    myProducts: isZh ? 'æˆ‘çš„å•†å“' : 'My Products',
    noProducts: isZh ? 'å°šæœªå»ºç«‹ä»»ä½•å•†å“' : 'No products yet',
    addNew: isZh ? 'æ–°å¢å•†å“' : 'Add Product',
    edit: isZh ? 'ç·¨è¼¯' : 'Edit',
    delete: isZh ? 'åˆªé™¤' : 'Delete',
    name: isZh ? 'å•†å“åç¨±' : 'Product Name',
    description: isZh ? 'å•†å“æè¿°' : 'Description',
    price: isZh ? 'åŸåƒ¹' : 'Price',
    discountPrice: isZh ? 'å„ªæƒ åƒ¹' : 'Discount Price',
    save: isZh ? 'å„²å­˜' : 'Save',
    cancel: isZh ? 'å–æ¶ˆ' : 'Cancel',
    active: isZh ? 'ä¸Šæ¶ä¸­' : 'Active',
    inactive: isZh ? 'å·²ä¸‹æ¶' : 'Inactive',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    deleteConfirm: isZh ? 'ç¢ºå®šè¦åˆªé™¤æ­¤å•†å“ï¼Ÿ' : 'Delete this product?',
    deleteSuccess: isZh ? 'å·²åˆªé™¤' : 'Deleted',
    saveSuccess: isZh ? 'å·²å„²å­˜' : 'Saved',
    saveFailed: isZh ? 'å„²å­˜å¤±æ•—' : 'Save failed',
  };

  useEffect(() => {
    loadProducts();
  }, []);

  const loadProducts = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;
      const data = await apiService.getMerchantProducts(token);
      setProducts(data.products || []);
    } catch (error) {
      console.error('Failed to load products:', error);
    } finally {
      setLoading(false);
    }
  };

  const openModal = (product?: MerchantProduct) => {
    if (product) {
      setEditingProduct(product);
      setFormData({
        name: product.name,
        description: product.description || '',
        price: product.price?.toString() || '',
        discountPrice: product.discountPrice?.toString() || '',
      });
    } else {
      setEditingProduct(null);
      setFormData({ name: '', description: '', price: '', discountPrice: '' });
    }
    setModalVisible(true);
  };

  const handleSave = async () => {
    if (!formData.name.trim()) return;
    try {
      setSaving(true);
      const token = await getToken();
      if (!token) return;

      const params = {
        name: formData.name,
        description: formData.description || undefined,
        price: formData.price ? parseFloat(formData.price) : undefined,
        discountPrice: formData.discountPrice ? parseFloat(formData.discountPrice) : undefined,
      };

      if (editingProduct) {
        await apiService.updateMerchantProduct(token, editingProduct.id, params);
      } else {
        await apiService.createMerchantProduct(token, params);
      }

      setModalVisible(false);
      loadProducts();
      Alert.alert(isZh ? 'æˆåŠŸ' : 'Success', translations.saveSuccess);
    } catch (error) {
      console.error('Save failed:', error);
      Alert.alert(isZh ? 'éŒ¯èª¤' : 'Error', translations.saveFailed);
    } finally {
      setSaving(false);
    }
  };

  const handleDelete = (product: MerchantProduct) => {
    Alert.alert(
      isZh ? 'ç¢ºèªåˆªé™¤' : 'Confirm Delete',
      translations.deleteConfirm,
      [
        { text: translations.cancel, style: 'cancel' },
        {
          text: translations.delete,
          style: 'destructive',
          onPress: async () => {
            try {
              const token = await getToken();
              if (!token) return;
              await apiService.deleteMerchantProduct(token, product.id);
              loadProducts();
              Alert.alert(isZh ? 'æˆåŠŸ' : 'Success', translations.deleteSuccess);
            } catch (error) {
              console.error('Delete failed:', error);
            }
          },
        },
      ]
    );
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={100}
    >
      <ScrollView contentContainerStyle={styles.content} keyboardShouldPersistTaps="handled">
        <View style={styles.header}>
          <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
            <Ionicons name="arrow-back" size={24} color="#1e293b" />
          </TouchableOpacity>
          <Text style={styles.title}>{translations.title}</Text>
        </View>

        <TouchableOpacity style={styles.addButton} onPress={() => openModal()}>
          <Ionicons name="add-circle-outline" size={24} color="#ffffff" />
          <Text style={styles.addButtonText}>{translations.addNew}</Text>
        </TouchableOpacity>

        <Text style={styles.sectionTitle}>{translations.myProducts}</Text>

        {products.length === 0 ? (
          <View style={styles.emptyCard}>
            <Ionicons name="cube-outline" size={48} color="#94a3b8" />
            <Text style={styles.emptyText}>{translations.noProducts}</Text>
          </View>
        ) : (
          <View style={styles.productsList}>
            {products.map(product => (
              <View key={product.id} style={styles.productCard}>
                <View style={styles.productInfo}>
                  <Text style={styles.productName}>{product.name}</Text>
                  {product.description && (
                    <Text style={styles.productDesc} numberOfLines={2}>
                      {product.description}
                    </Text>
                  )}
                  <View style={styles.priceRow}>
                    {product.discountPrice ? (
                      <>
                        <Text style={styles.discountPrice}>
                          ${product.discountPrice}
                        </Text>
                        <Text style={styles.originalPrice}>
                          ${product.price}
                        </Text>
                      </>
                    ) : product.price ? (
                      <Text style={styles.price}>${product.price}</Text>
                    ) : null}
                    <View style={[
                      styles.statusBadge,
                      product.isActive ? styles.activeBadge : styles.inactiveBadge
                    ]}>
                      <Text style={[
                        styles.statusText,
                        product.isActive ? styles.activeText : styles.inactiveText
                      ]}>
                        {product.isActive ? translations.active : translations.inactive}
                      </Text>
                    </View>
                  </View>
                </View>
                <View style={styles.productActions}>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => openModal(product)}
                  >
                    <Ionicons name="pencil-outline" size={20} color="#6366f1" />
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => handleDelete(product)}
                  >
                    <Ionicons name="trash-outline" size={20} color="#ef4444" />
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
      </ScrollView>

      <Modal visible={modalVisible} animationType="slide" transparent>
        <KeyboardAvoidingView
          style={styles.modalOverlay}
          behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
        >
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              {editingProduct ? translations.edit : translations.addNew}
            </Text>

            <ScrollView keyboardShouldPersistTaps="handled" showsVerticalScrollIndicator={false}>
              <Text style={styles.inputLabel}>{translations.name}</Text>
              <TextInput
                style={styles.input}
                value={formData.name}
                onChangeText={text => setFormData({ ...formData, name: text })}
                placeholder={translations.name}
                placeholderTextColor="#94a3b8"
              />

              <Text style={styles.inputLabel}>{translations.description}</Text>
              <TextInput
                style={[styles.input, styles.textArea]}
                value={formData.description}
                onChangeText={text => setFormData({ ...formData, description: text })}
                placeholder={translations.description}
                placeholderTextColor="#94a3b8"
                multiline
                numberOfLines={3}
              />

              <View style={styles.priceInputRow}>
                <View style={styles.priceInputContainer}>
                  <Text style={styles.inputLabel}>{translations.price}</Text>
                  <TextInput
                    style={styles.input}
                    value={formData.price}
                    onChangeText={text => setFormData({ ...formData, price: text })}
                    placeholder="0"
                    placeholderTextColor="#94a3b8"
                    keyboardType="numeric"
                  />
                </View>
                <View style={styles.priceInputContainer}>
                  <Text style={styles.inputLabel}>{translations.discountPrice}</Text>
                  <TextInput
                    style={styles.input}
                    value={formData.discountPrice}
                    onChangeText={text => setFormData({ ...formData, discountPrice: text })}
                    placeholder="0"
                    placeholderTextColor="#94a3b8"
                    keyboardType="numeric"
                  />
                </View>
              </View>
            </ScrollView>

            <View style={styles.modalButtons}>
              <TouchableOpacity
                style={styles.cancelModalButton}
                onPress={() => setModalVisible(false)}
              >
                <Text style={styles.cancelModalButtonText}>{translations.cancel}</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={styles.saveButton}
                onPress={handleSave}
                disabled={saving}
              >
                {saving ? (
                  <ActivityIndicator size="small" color="#ffffff" />
                ) : (
                  <Text style={styles.saveButtonText}>{translations.save}</Text>
                )}
              </TouchableOpacity>
            </View>
          </View>
        </KeyboardAvoidingView>
      </Modal>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 24,
    gap: 12,
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  title: {
    fontSize: 24,
    fontWeight: '900',
    color: '#1e293b',
  },
  addButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: '#6366f1',
    paddingVertical: 16,
    borderRadius: 16,
    marginBottom: 24,
  },
  addButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 16,
  },
  emptyCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 12,
  },
  productsList: {
    gap: 12,
  },
  productCard: {
    flexDirection: 'row',
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  productInfo: {
    flex: 1,
  },
  productName: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  productDesc: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 8,
  },
  priceRow: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
  },
  price: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
  },
  discountPrice: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ef4444',
  },
  originalPrice: {
    fontSize: 14,
    color: '#94a3b8',
    textDecorationLine: 'line-through',
  },
  statusBadge: {
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  activeBadge: {
    backgroundColor: '#dcfce7',
  },
  inactiveBadge: {
    backgroundColor: '#f1f5f9',
  },
  statusText: {
    fontSize: 11,
    fontWeight: '600',
  },
  activeText: {
    color: '#16a34a',
  },
  inactiveText: {
    color: '#64748b',
  },
  productActions: {
    flexDirection: 'column',
    gap: 8,
  },
  actionButton: {
    width: 36,
    height: 36,
    borderRadius: 10,
    backgroundColor: '#f8fafc',
    alignItems: 'center',
    justifyContent: 'center',
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0,0,0,0.5)',
    justifyContent: 'flex-end',
  },
  modalContent: {
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    padding: 24,
    paddingBottom: 40,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 20,
  },
  inputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f8fafc',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 16,
    borderWidth: 2,
    borderColor: '#e2e8f0',
    color: '#1e293b',
    marginBottom: 16,
  },
  textArea: {
    height: 80,
    textAlignVertical: 'top',
  },
  priceInputRow: {
    flexDirection: 'row',
    gap: 12,
  },
  priceInputContainer: {
    flex: 1,
  },
  modalButtons: {
    flexDirection: 'row',
    gap: 12,
    marginTop: 8,
  },
  cancelModalButton: {
    flex: 1,
    paddingVertical: 16,
    borderRadius: 12,
    backgroundColor: '#f1f5f9',
    alignItems: 'center',
  },
  cancelModalButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#64748b',
  },
  saveButton: {
    flex: 1,
    paddingVertical: 16,
    borderRadius: 12,
    backgroundColor: '#6366f1',
    alignItems: 'center',
  },
  saveButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ffffff',
  },
});

=== File: src/screens/MerchantProfileScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MerchantMe } from '../types';

export function MerchantProfileScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [merchant, setMerchant] = useState<MerchantMe | null>(null);
  const [loading, setLoading] = useState(true);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å•†å®¶è³‡æ–™' : 'Merchant Profile',
    businessName: isZh ? 'å•†å®¶åç¨±' : 'Business Name',
    email: isZh ? 'è¯çµ¡ä¿¡ç®±' : 'Contact Email',
    status: isZh ? 'å¸³è™Ÿç‹€æ…‹' : 'Account Status',
    approved: isZh ? 'å·²æ ¸å‡†' : 'Approved',
    pending: isZh ? 'å¾…å¯©æ ¸' : 'Pending',
    balance: isZh ? 'é»æ•¸é¤˜é¡' : 'Credit Balance',
    plan: isZh ? 'è¨‚é–±æ–¹æ¡ˆ' : 'Subscription Plan',
    free: isZh ? 'å…è²»æ–¹æ¡ˆ' : 'Free Plan',
    partner: isZh ? 'åˆä½œå¤¥ä¼´' : 'Partner',
    premium: isZh ? 'é€²éšæ–¹æ¡ˆ' : 'Premium',
    memberSince: isZh ? 'åŠ å…¥æ™‚é–“' : 'Member Since',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    points: isZh ? 'é»' : 'pts',
  };

  useEffect(() => {
    loadMerchant();
  }, []);

  const loadMerchant = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;
      const data = await apiService.getMerchantMe(token);
      setMerchant(data);
    } catch (error) {
      console.error('Failed to load merchant:', error);
    } finally {
      setLoading(false);
    }
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString(isZh ? 'zh-TW' : 'en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
    });
  };

  const getPlanLabel = (plan?: string) => {
    switch (plan) {
      case 'partner': return translations.partner;
      case 'premium': return translations.premium;
      default: return translations.free;
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
      </View>

      <View style={styles.avatarSection}>
        <View style={styles.avatar}>
          <Ionicons name="storefront" size={48} color="#6366f1" />
        </View>
        <Text style={styles.businessName}>
          {merchant?.businessName || merchant?.name || '-'}
        </Text>
        <View style={[
          styles.statusBadge,
          merchant?.isApproved ? styles.approvedBadge : styles.pendingBadge
        ]}>
          <Text style={[
            styles.statusText,
            merchant?.isApproved ? styles.approvedText : styles.pendingText
          ]}>
            {merchant?.isApproved ? translations.approved : translations.pending}
          </Text>
        </View>
      </View>

      <View style={styles.infoCard}>
        <View style={styles.infoRow}>
          <View style={styles.infoIcon}>
            <Ionicons name="mail-outline" size={20} color="#6366f1" />
          </View>
          <View style={styles.infoContent}>
            <Text style={styles.infoLabel}>{translations.email}</Text>
            <Text style={styles.infoValue}>
              {merchant?.contactEmail || merchant?.email || '-'}
            </Text>
          </View>
        </View>

        <View style={styles.divider} />

        <View style={styles.infoRow}>
          <View style={styles.infoIcon}>
            <Ionicons name="wallet-outline" size={20} color="#6366f1" />
          </View>
          <View style={styles.infoContent}>
            <Text style={styles.infoLabel}>{translations.balance}</Text>
            <Text style={styles.infoValue}>
              {merchant?.creditBalance ?? 0} {translations.points}
            </Text>
          </View>
        </View>

        <View style={styles.divider} />

        <View style={styles.infoRow}>
          <View style={styles.infoIcon}>
            <Ionicons name="ribbon-outline" size={20} color="#6366f1" />
          </View>
          <View style={styles.infoContent}>
            <Text style={styles.infoLabel}>{translations.plan}</Text>
            <Text style={styles.infoValue}>
              {getPlanLabel(merchant?.subscriptionPlan)}
            </Text>
          </View>
        </View>

        <View style={styles.divider} />

        <View style={styles.infoRow}>
          <View style={styles.infoIcon}>
            <Ionicons name="calendar-outline" size={20} color="#6366f1" />
          </View>
          <View style={styles.infoContent}>
            <Text style={styles.infoLabel}>{translations.memberSince}</Text>
            <Text style={styles.infoValue}>
              {merchant?.createdAt ? formatDate(merchant.createdAt) : '-'}
            </Text>
          </View>
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 24,
    gap: 12,
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  title: {
    fontSize: 24,
    fontWeight: '900',
    color: '#1e293b',
  },
  avatarSection: {
    alignItems: 'center',
    marginBottom: 32,
  },
  avatar: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: '#eef2ff',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
    borderWidth: 3,
    borderColor: '#c7d2fe',
  },
  businessName: {
    fontSize: 24,
    fontWeight: '800',
    color: '#1e293b',
    marginBottom: 12,
  },
  statusBadge: {
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
  },
  approvedBadge: {
    backgroundColor: '#dcfce7',
  },
  pendingBadge: {
    backgroundColor: '#fef3c7',
  },
  statusText: {
    fontSize: 14,
    fontWeight: '600',
  },
  approvedText: {
    color: '#16a34a',
  },
  pendingText: {
    color: '#d97706',
  },
  infoCard: {
    backgroundColor: '#ffffff',
    borderRadius: 20,
    padding: 20,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
  },
  infoIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: '#eef2ff',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 16,
  },
  infoContent: {
    flex: 1,
  },
  infoLabel: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 4,
  },
  infoValue: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1e293b',
  },
  divider: {
    height: 1,
    backgroundColor: '#e2e8f0',
    marginVertical: 4,
  },
});

=== File: src/screens/MerchantTransactionsScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  RefreshControl,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { MerchantTransaction } from '../types';

export function MerchantTransactionsScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [transactions, setTransactions] = useState<MerchantTransaction[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'äº¤æ˜“è¨˜éŒ„' : 'Transaction History',
    noTransactions: isZh ? 'æš«ç„¡äº¤æ˜“è¨˜éŒ„' : 'No transactions yet',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    purchase: isZh ? 'è³¼è²·é»æ•¸' : 'Purchase',
    usage: isZh ? 'ä½¿ç”¨é»æ•¸' : 'Usage',
    refund: isZh ? 'é€€æ¬¾' : 'Refund',
    back: isZh ? 'è¿”å›' : 'Back',
  };

  useEffect(() => {
    loadTransactions();
  }, []);

  const loadTransactions = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;

      const response = await apiService.getMerchantTransactions(token);
      setTransactions(response.transactions || []);
    } catch (error) {
      console.error('Failed to load transactions:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadTransactions();
    setRefreshing(false);
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleString(isZh ? 'zh-TW' : 'en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const getTypeLabel = (type: string) => {
    switch (type) {
      case 'purchase': return translations.purchase;
      case 'usage': return translations.usage;
      case 'refund': return translations.refund;
      default: return type;
    }
  };

  const getTypeColor = (type: string) => {
    switch (type) {
      case 'purchase': return '#22c55e';
      case 'usage': return '#ef4444';
      case 'refund': return '#f59e0b';
      default: return '#64748b';
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
        }
      >
        {transactions.length === 0 ? (
          <View style={styles.emptyCard}>
            <Ionicons name="receipt-outline" size={48} color="#94a3b8" />
            <Text style={styles.emptyText}>{translations.noTransactions}</Text>
          </View>
        ) : (
          <View style={styles.transactionsList}>
            {transactions.map(tx => (
              <View key={tx.id} style={styles.transactionCard}>
                <View style={styles.transactionIcon}>
                  <Ionicons
                    name={tx.type === 'purchase' ? 'add-circle' : tx.type === 'refund' ? 'refresh-circle' : 'remove-circle'}
                    size={32}
                    color={getTypeColor(tx.type)}
                  />
                </View>
                <View style={styles.transactionInfo}>
                  <Text style={styles.transactionType}>{getTypeLabel(tx.type)}</Text>
                  <Text style={styles.transactionDate}>{formatDate(tx.createdAt)}</Text>
                  {tx.description && (
                    <Text style={styles.transactionDesc}>{tx.description}</Text>
                  )}
                </View>
                <Text style={[styles.transactionAmount, { color: getTypeColor(tx.type) }]}>
                  {tx.type === 'usage' ? '-' : '+'}{tx.amount}
                </Text>
              </View>
            ))}
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    marginRight: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '800',
    color: '#1e293b',
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: 20,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  emptyCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 12,
  },
  transactionsList: {
    gap: 12,
  },
  transactionCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  transactionIcon: {
    marginRight: 12,
  },
  transactionInfo: {
    flex: 1,
  },
  transactionType: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  transactionDate: {
    fontSize: 13,
    color: '#64748b',
  },
  transactionDesc: {
    fontSize: 12,
    color: '#94a3b8',
    marginTop: 4,
  },
  transactionAmount: {
    fontSize: 18,
    fontWeight: '800',
  },
});

=== File: src/screens/MerchantVerifyScreen.tsx ===

import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  TextInput,
  ActivityIndicator,
  Alert,
  KeyboardAvoidingView,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';

export function MerchantVerifyScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [code, setCode] = useState('');
  const [merchantId, setMerchantId] = useState('');
  const [loading, setLoading] = useState(false);
  const [result, setResult] = useState<{ valid: boolean; message?: string } | null>(null);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'é©—è­‰æ ¸éŠ·ç¢¼' : 'Verify Code',
    merchantIdLabel: isZh ? 'å•†å®¶ ID' : 'Merchant ID',
    merchantIdPlaceholder: isZh ? 'è¼¸å…¥å•†å®¶ ID' : 'Enter Merchant ID',
    codeLabel: isZh ? 'æ ¸éŠ·ç¢¼' : 'Verification Code',
    codePlaceholder: isZh ? 'è¼¸å…¥æ ¸éŠ·ç¢¼' : 'Enter code',
    verify: isZh ? 'é©—è­‰' : 'Verify',
    verifying: isZh ? 'é©—è­‰ä¸­...' : 'Verifying...',
    valid: isZh ? 'é©—è­‰æˆåŠŸ' : 'Valid',
    invalid: isZh ? 'é©—è­‰å¤±æ•—' : 'Invalid',
    errorEmpty: isZh ? 'è«‹è¼¸å…¥å•†å®¶ ID å’Œæ ¸éŠ·ç¢¼' : 'Please enter merchant ID and code',
    back: isZh ? 'è¿”å›' : 'Back',
    tryAgain: isZh ? 'å†è©¦ä¸€æ¬¡' : 'Try Again',
  };

  const handleVerify = async () => {
    if (!code.trim() || !merchantId.trim()) {
      Alert.alert('', translations.errorEmpty);
      return;
    }

    const merchantIdNum = parseInt(merchantId.trim(), 10);
    if (isNaN(merchantIdNum)) {
      Alert.alert('', isZh ? 'å•†å®¶ ID å¿…é ˆæ˜¯æ•¸å­—' : 'Merchant ID must be a number');
      return;
    }

    try {
      setLoading(true);
      setResult(null);
      const token = await getToken();
      if (!token) return;

      const response = await apiService.verifyMerchantCode(token, merchantIdNum, code.trim());
      setResult({ 
        valid: response.valid, 
        message: response.valid 
          ? (isZh ? 'æ ¸éŠ·ç¢¼æœ‰æ•ˆ' : 'Code is valid')
          : (response.error || (isZh ? 'æ ¸éŠ·ç¢¼ç„¡æ•ˆ' : 'Code is invalid'))
      });
    } catch (error) {
      console.error('Verify failed:', error);
      setResult({ valid: false, message: isZh ? 'é©—è­‰å¤±æ•—' : 'Verification failed' });
    } finally {
      setLoading(false);
    }
  };

  const handleReset = () => {
    setCode('');
    setMerchantId('');
    setResult(null);
  };

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
    >
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
      </View>

      <View style={styles.content}>
        {result ? (
          <View style={styles.resultCard}>
            <View style={[styles.resultIcon, result.valid ? styles.resultValid : styles.resultInvalid]}>
              <Ionicons
                name={result.valid ? 'checkmark-circle' : 'close-circle'}
                size={64}
                color="#ffffff"
              />
            </View>
            <Text style={styles.resultTitle}>
              {result.valid ? translations.valid : translations.invalid}
            </Text>
            {result.message && (
              <Text style={styles.resultMessage}>{result.message}</Text>
            )}
            <TouchableOpacity style={styles.resetButton} onPress={handleReset}>
              <Text style={styles.resetButtonText}>{translations.tryAgain}</Text>
            </TouchableOpacity>
          </View>
        ) : (
          <View style={styles.formCard}>
            <View style={styles.inputGroup}>
              <Text style={styles.inputLabel}>{translations.merchantIdLabel}</Text>
              <TextInput
                style={styles.input}
                value={merchantId}
                onChangeText={setMerchantId}
                placeholder={translations.merchantIdPlaceholder}
                placeholderTextColor="#94a3b8"
                keyboardType="number-pad"
              />
            </View>

            <View style={styles.inputGroup}>
              <Text style={styles.inputLabel}>{translations.codeLabel}</Text>
              <TextInput
                style={[styles.input, styles.codeInput]}
                value={code}
                onChangeText={(text) => setCode(text.toUpperCase())}
                placeholder={translations.codePlaceholder}
                placeholderTextColor="#94a3b8"
                autoCapitalize="characters"
                maxLength={6}
              />
            </View>

            <TouchableOpacity
              style={[styles.verifyButton, loading && styles.verifyButtonDisabled]}
              onPress={handleVerify}
              disabled={loading}
            >
              {loading ? (
                <ActivityIndicator size="small" color="#ffffff" />
              ) : (
                <>
                  <Ionicons name="shield-checkmark" size={20} color="#ffffff" />
                  <Text style={styles.verifyButtonText}>{translations.verify}</Text>
                </>
              )}
            </TouchableOpacity>
          </View>
        )}
      </View>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    marginRight: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '800',
    color: '#1e293b',
  },
  content: {
    flex: 1,
    padding: 20,
    justifyContent: 'center',
  },
  formCard: {
    backgroundColor: '#ffffff',
    borderRadius: 20,
    padding: 24,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  inputGroup: {
    marginBottom: 20,
  },
  inputLabel: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 8,
  },
  input: {
    backgroundColor: '#f8fafc',
    borderWidth: 2,
    borderColor: '#e2e8f0',
    borderRadius: 12,
    paddingHorizontal: 16,
    paddingVertical: 14,
    fontSize: 16,
    color: '#1e293b',
  },
  codeInput: {
    fontSize: 24,
    fontWeight: '800',
    textAlign: 'center',
    letterSpacing: 8,
  },
  verifyButton: {
    backgroundColor: '#6366f1',
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 16,
    borderRadius: 16,
    marginTop: 12,
  },
  verifyButtonDisabled: {
    backgroundColor: '#a5b4fc',
  },
  verifyButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
  resultCard: {
    backgroundColor: '#ffffff',
    borderRadius: 20,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  resultIcon: {
    width: 100,
    height: 100,
    borderRadius: 50,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 20,
  },
  resultValid: {
    backgroundColor: '#22c55e',
  },
  resultInvalid: {
    backgroundColor: '#ef4444',
  },
  resultTitle: {
    fontSize: 24,
    fontWeight: '800',
    color: '#1e293b',
    marginBottom: 8,
  },
  resultMessage: {
    fontSize: 16,
    color: '#64748b',
    textAlign: 'center',
    marginBottom: 24,
  },
  resetButton: {
    paddingHorizontal: 24,
    paddingVertical: 12,
    backgroundColor: '#f1f5f9',
    borderRadius: 12,
  },
  resetButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#6366f1',
  },
});

=== File: src/screens/PendingApprovalScreen.tsx ===

import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';

export function PendingApprovalScreen() {
  const { state, setUser } = useApp();
  const router = useRouter();

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'ç­‰å¾…å¯©æ ¸' : 'Pending Approval',
    subtitle: isZh 
      ? 'æ‚¨çš„å¸³è™Ÿæ­£åœ¨ç­‰å¾…ç®¡ç†å“¡å¯©æ ¸' 
      : 'Your account is pending admin approval',
    description: isZh
      ? 'å•†å®¶å’Œå°ˆå“¡å¸³è™Ÿéœ€ç¶“éå¯©æ ¸æ‰èƒ½ä½¿ç”¨å®Œæ•´åŠŸèƒ½ã€‚å¯©æ ¸é€šéå¾Œæœƒé€šçŸ¥æ‚¨ã€‚'
      : 'Merchant and Specialist accounts require approval for full access. You will be notified once approved.',
    role: isZh ? 'ç”³è«‹èº«ä»½' : 'Applied Role',
    logout: isZh ? 'ç™»å‡º' : 'Logout',
    roleLabels: {
      merchant: isZh ? 'å•†å®¶' : 'Merchant',
      specialist: isZh ? 'å°ˆå“¡' : 'Specialist',
    } as Record<string, string>,
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem('token');
    setUser(null);
    router.replace('/login');
  };

  const roleLabel = translations.roleLabels[state.user?.role || ''] || state.user?.role;

  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <Ionicons name="hourglass-outline" size={80} color="#f59e0b" />
      </View>

      <Text style={styles.title}>{translations.title}</Text>
      <Text style={styles.subtitle}>{translations.subtitle}</Text>
      <Text style={styles.description}>{translations.description}</Text>

      <View style={styles.roleCard}>
        <Text style={styles.roleLabel}>{translations.role}</Text>
        <Text style={styles.roleValue}>{roleLabel}</Text>
      </View>

      <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
        <Ionicons name="log-out-outline" size={20} color="#ef4444" />
        <Text style={styles.logoutText}>{translations.logout}</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 32,
  },
  iconContainer: {
    width: 140,
    height: 140,
    borderRadius: 70,
    backgroundColor: '#fef3c7',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 32,
  },
  title: {
    fontSize: 28,
    fontWeight: '900',
    color: '#1e293b',
    marginBottom: 12,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: 16,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 16,
    textAlign: 'center',
  },
  description: {
    fontSize: 14,
    color: '#94a3b8',
    textAlign: 'center',
    lineHeight: 22,
    marginBottom: 32,
  },
  roleCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 20,
    width: '100%',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#fbbf24',
    marginBottom: 32,
  },
  roleLabel: {
    fontSize: 14,
    color: '#64748b',
    marginBottom: 8,
  },
  roleValue: {
    fontSize: 24,
    fontWeight: '800',
    color: '#f59e0b',
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingVertical: 14,
    paddingHorizontal: 24,
    backgroundColor: '#fef2f2',
    borderRadius: 12,
  },
  logoutText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#ef4444',
  },
});

=== File: src/screens/PlannerScreen.tsx ===

import React from 'react';
import { View, Text, StyleSheet, ScrollView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useApp } from '../context/AppContext';

export function PlannerScreen() {
  const { t, state } = useApp();

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <Text style={styles.title}>{t.navPlannerModule}</Text>

      <View style={styles.comingSoon}>
        <View style={styles.iconContainer}>
          <Ionicons name="construct" size={48} color="#6366f1" />
        </View>
        <Text style={styles.comingSoonTitle}>
          {state.language === 'zh-TW' ? 'å³å°‡æ¨å‡º' : 'Coming Soon'}
        </Text>
        <Text style={styles.comingSoonDesc}>
          {state.language === 'zh-TW'
            ? 'æ—…ç¨‹ç­–åŠƒåŠŸèƒ½æ­£åœ¨é–‹ç™¼ä¸­ï¼Œæ•¬è«‹æœŸå¾…ï¼'
            : 'Trip planner is under development. Stay tuned!'}
        </Text>
      </View>

      <View style={styles.featureList}>
        <View style={styles.featureItem}>
          <Ionicons name="location" size={24} color="#22c55e" />
          <View style={styles.featureText}>
            <Text style={styles.featureTitle}>{t.navLocation}</Text>
            <Text style={styles.featureDesc}>
              {state.language === 'zh-TW' ? 'å®šä½ä¸¦æ¢ç´¢é™„è¿‘æ™¯é»' : 'Locate and explore nearby'}
            </Text>
          </View>
        </View>

        <View style={styles.featureItem}>
          <Ionicons name="calendar" size={24} color="#f59e0b" />
          <View style={styles.featureText}>
            <Text style={styles.featureTitle}>{t.navItinerary}</Text>
            <Text style={styles.featureDesc}>
              {state.language === 'zh-TW' ? 'è¦åŠƒä½ çš„å®Œç¾è¡Œç¨‹' : 'Plan your perfect trip'}
            </Text>
          </View>
        </View>

        <View style={styles.featureItem}>
          <Ionicons name="chatbubbles" size={24} color="#6366f1" />
          <View style={styles.featureText}>
            <Text style={styles.featureTitle}>{t.navChat}</Text>
            <Text style={styles.featureDesc}>
              {state.language === 'zh-TW' ? 'èˆ‡ç­–åŠƒå¸«å³æ™‚èŠå¤©' : 'Chat with planners'}
            </Text>
          </View>
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  title: {
    fontSize: 28,
    fontWeight: '900',
    color: '#1e293b',
    marginBottom: 24,
  },
  comingSoon: {
    backgroundColor: '#ffffff',
    borderRadius: 24,
    padding: 32,
    alignItems: 'center',
    marginBottom: 24,
    borderWidth: 2,
    borderColor: '#f1f5f9',
  },
  iconContainer: {
    width: 80,
    height: 80,
    backgroundColor: '#eef2ff',
    borderRadius: 40,
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
  },
  comingSoonTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 8,
  },
  comingSoonDesc: {
    fontSize: 14,
    color: '#64748b',
    textAlign: 'center',
  },
  featureList: {
    gap: 12,
  },
  featureItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    padding: 16,
    borderRadius: 16,
    gap: 16,
    borderWidth: 2,
    borderColor: '#f1f5f9',
  },
  featureText: {
    flex: 1,
  },
  featureTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 2,
  },
  featureDesc: {
    fontSize: 14,
    color: '#64748b',
  },
});

=== File: src/screens/ProfileScreen.tsx ===

import React, { useState, useEffect } from 'react';
import { View, Text, StyleSheet, ScrollView, TextInput, TouchableOpacity, Alert, ActivityIndicator, Platform, KeyboardAvoidingView } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { TagInput } from '../components/TagInput';
import { UserProfile, Gender } from '../types';

const GENDER_OPTIONS: { value: Gender; labelZh: string; labelEn: string }[] = [
  { value: 'male', labelZh: 'ç”·', labelEn: 'Male' },
  { value: 'female', labelZh: 'å¥³', labelEn: 'Female' },
  { value: 'other', labelZh: 'å…¶ä»–', labelEn: 'Other' },
];

const RELATION_OPTIONS = [
  { value: 'spouse', labelZh: 'é…å¶', labelEn: 'Spouse' },
  { value: 'parent', labelZh: 'çˆ¶æ¯', labelEn: 'Parent' },
  { value: 'sibling', labelZh: 'å…„å¼Ÿå§Šå¦¹', labelEn: 'Sibling' },
  { value: 'friend', labelZh: 'æœ‹å‹', labelEn: 'Friend' },
  { value: 'other', labelZh: 'å…¶ä»–', labelEn: 'Other' },
];

export function ProfileScreen() {
  const { state } = useApp();
  const router = useRouter();
  const isZh = state.language === 'zh-TW';

  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const [profile, setProfile] = useState<UserProfile | null>(null);

  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [gender, setGender] = useState<Gender | null>(null);
  const [birthDate, setBirthDate] = useState('');
  const [phone, setPhone] = useState('');
  const [dietaryRestrictions, setDietaryRestrictions] = useState<string[]>([]);
  const [medicalHistory, setMedicalHistory] = useState<string[]>([]);
  const [emergencyContactName, setEmergencyContactName] = useState('');
  const [emergencyContactPhone, setEmergencyContactPhone] = useState('');
  const [emergencyContactRelation, setEmergencyContactRelation] = useState('');
  const [showGenderPicker, setShowGenderPicker] = useState(false);
  const [showRelationPicker, setShowRelationPicker] = useState(false);

  useEffect(() => {
    loadProfile();
  }, []);

  const loadProfile = async () => {
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) {
        router.back();
        return;
      }

      const data = await apiService.getProfile(token);
      setProfile(data);
      setFirstName(data.firstName || '');
      setLastName(data.lastName || '');
      setGender(data.gender);
      setBirthDate(data.birthDate || '');
      setPhone(data.phone || '');
      setDietaryRestrictions(data.dietaryRestrictions || []);
      setMedicalHistory(data.medicalHistory || []);
      setEmergencyContactName(data.emergencyContactName || '');
      setEmergencyContactPhone(data.emergencyContactPhone || '');
      setEmergencyContactRelation(data.emergencyContactRelation || '');
    } catch (error) {
      console.error('Failed to load profile:', error);
      Alert.alert(
        isZh ? 'éŒ¯èª¤' : 'Error',
        isZh ? 'ç„¡æ³•è¼‰å…¥å€‹äººè³‡æ–™' : 'Failed to load profile'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleSave = async () => {
    setSaving(true);
    try {
      const token = await AsyncStorage.getItem('@mibu_token');
      if (!token) return;

      await apiService.updateProfile(token, {
        firstName: firstName || undefined,
        lastName: lastName || undefined,
        gender: gender || undefined,
        birthDate: birthDate || undefined,
        phone: phone || undefined,
        dietaryRestrictions,
        medicalHistory,
        emergencyContactName: emergencyContactName || undefined,
        emergencyContactPhone: emergencyContactPhone || undefined,
        emergencyContactRelation: emergencyContactRelation || undefined,
      });

      Alert.alert(
        isZh ? 'æˆåŠŸ' : 'Success',
        isZh ? 'å€‹äººè³‡æ–™å·²æ›´æ–°' : 'Profile updated successfully'
      );
    } catch (error) {
      console.error('Failed to save profile:', error);
      Alert.alert(
        isZh ? 'éŒ¯èª¤' : 'Error',
        isZh ? 'å„²å­˜å¤±æ•—' : 'Failed to save'
      );
    } finally {
      setSaving(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
      </View>
    );
  }

  return (
    <KeyboardAvoidingView 
      style={styles.container}
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={100}
    >
      <View style={styles.header}>
        <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{isZh ? 'å€‹äººè³‡æ–™' : 'Profile'}</Text>
        <TouchableOpacity onPress={handleSave} disabled={saving} style={styles.saveButton}>
          {saving ? (
            <ActivityIndicator size="small" color="#6366f1" />
          ) : (
            <Text style={styles.saveButtonText}>{isZh ? 'å„²å­˜' : 'Save'}</Text>
          )}
        </TouchableOpacity>
      </View>

      <ScrollView style={styles.content} showsVerticalScrollIndicator={false} keyboardShouldPersistTaps="handled">
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'ç”¨æˆ¶ ID' : 'User ID'}</Text>
          <View style={styles.readOnlyField}>
            <Text style={styles.readOnlyText}>{profile?.id || '-'}</Text>
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Email</Text>
          <View style={styles.readOnlyField}>
            <Text style={styles.readOnlyText}>{profile?.email || '-'}</Text>
          </View>
        </View>

        <View style={styles.row}>
          <View style={[styles.section, { flex: 1 }]}>
            <Text style={styles.sectionTitle}>{isZh ? 'å§“' : 'Last Name'}</Text>
            <TextInput
              style={styles.input}
              value={lastName}
              onChangeText={setLastName}
              placeholder={isZh ? 'è«‹è¼¸å…¥å§“æ°' : 'Enter last name'}
              placeholderTextColor="#94a3b8"
            />
          </View>
          <View style={[styles.section, { flex: 1, marginLeft: 12 }]}>
            <Text style={styles.sectionTitle}>{isZh ? 'å' : 'First Name'}</Text>
            <TextInput
              style={styles.input}
              value={firstName}
              onChangeText={setFirstName}
              placeholder={isZh ? 'è«‹è¼¸å…¥åå­—' : 'Enter first name'}
              placeholderTextColor="#94a3b8"
            />
          </View>
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'æ€§åˆ¥' : 'Gender'}</Text>
          <TouchableOpacity 
            style={styles.pickerButton}
            onPress={() => setShowGenderPicker(!showGenderPicker)}
          >
            <Text style={gender ? styles.pickerText : styles.pickerPlaceholder}>
              {gender 
                ? GENDER_OPTIONS.find(g => g.value === gender)?.[isZh ? 'labelZh' : 'labelEn'] || gender
                : isZh ? 'è«‹é¸æ“‡' : 'Select'}
            </Text>
            <Ionicons name="chevron-down" size={20} color="#64748b" />
          </TouchableOpacity>
          {showGenderPicker && (
            <View style={styles.pickerOptions}>
              {GENDER_OPTIONS.map(option => (
                <TouchableOpacity
                  key={option.value}
                  style={[styles.pickerOption, gender === option.value && styles.pickerOptionActive]}
                  onPress={() => {
                    setGender(option.value);
                    setShowGenderPicker(false);
                  }}
                >
                  <Text style={[styles.pickerOptionText, gender === option.value && styles.pickerOptionTextActive]}>
                    {isZh ? option.labelZh : option.labelEn}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          )}
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'å‡ºç”Ÿå¹´æœˆæ—¥' : 'Birth Date'}</Text>
          <TextInput
            style={styles.input}
            value={birthDate}
            onChangeText={setBirthDate}
            placeholder="YYYY-MM-DD"
            placeholderTextColor="#94a3b8"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'æ‰‹æ©Ÿ' : 'Phone'}</Text>
          <TextInput
            style={styles.input}
            value={phone}
            onChangeText={setPhone}
            placeholder={isZh ? 'è«‹è¼¸å…¥æ‰‹æ©Ÿè™Ÿç¢¼' : 'Enter phone number'}
            placeholderTextColor="#94a3b8"
            keyboardType="phone-pad"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'é£²é£Ÿç¦å¿Œ' : 'Dietary Restrictions'}</Text>
          <TagInput
            value={dietaryRestrictions}
            onChange={setDietaryRestrictions}
            placeholder={isZh ? 'è¼¸å…¥é£²é£Ÿç¦å¿Œï¼Œå¦‚ï¼šç´ é£Ÿã€æµ·é®®éæ•' : 'e.g., Vegetarian, Seafood allergy'}
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'ç–¾ç—…å²' : 'Medical History'}</Text>
          <TagInput
            value={medicalHistory}
            onChange={setMedicalHistory}
            placeholder={isZh ? 'è¼¸å…¥ç–¾ç—…å²ï¼Œå¦‚ï¼šç³–å°¿ç—…ã€é«˜è¡€å£“' : 'e.g., Diabetes, Hypertension'}
          />
        </View>

        <View style={styles.divider} />

        <Text style={styles.groupTitle}>{isZh ? 'ç·Šæ€¥è¯çµ¡äºº' : 'Emergency Contact'}</Text>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'å§“å' : 'Name'}</Text>
          <TextInput
            style={styles.input}
            value={emergencyContactName}
            onChangeText={setEmergencyContactName}
            placeholder={isZh ? 'è«‹è¼¸å…¥å§“å' : 'Enter name'}
            placeholderTextColor="#94a3b8"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'é›»è©±' : 'Phone'}</Text>
          <TextInput
            style={styles.input}
            value={emergencyContactPhone}
            onChangeText={setEmergencyContactPhone}
            placeholder={isZh ? 'è«‹è¼¸å…¥é›»è©±' : 'Enter phone'}
            placeholderTextColor="#94a3b8"
            keyboardType="phone-pad"
          />
        </View>

        <View style={styles.section}>
          <Text style={styles.sectionTitle}>{isZh ? 'é—œä¿‚' : 'Relationship'}</Text>
          <TouchableOpacity 
            style={styles.pickerButton}
            onPress={() => setShowRelationPicker(!showRelationPicker)}
          >
            <Text style={emergencyContactRelation ? styles.pickerText : styles.pickerPlaceholder}>
              {emergencyContactRelation 
                ? RELATION_OPTIONS.find(r => r.value === emergencyContactRelation)?.[isZh ? 'labelZh' : 'labelEn'] || emergencyContactRelation
                : isZh ? 'è«‹é¸æ“‡' : 'Select'}
            </Text>
            <Ionicons name="chevron-down" size={20} color="#64748b" />
          </TouchableOpacity>
          {showRelationPicker && (
            <View style={styles.pickerOptions}>
              {RELATION_OPTIONS.map(option => (
                <TouchableOpacity
                  key={option.value}
                  style={[styles.pickerOption, emergencyContactRelation === option.value && styles.pickerOptionActive]}
                  onPress={() => {
                    setEmergencyContactRelation(option.value);
                    setShowRelationPicker(false);
                  }}
                >
                  <Text style={[styles.pickerOptionText, emergencyContactRelation === option.value && styles.pickerOptionTextActive]}>
                    {isZh ? option.labelZh : option.labelEn}
                  </Text>
                </TouchableOpacity>
              ))}
            </View>
          )}
        </View>

        <View style={{ height: 100 }} />
      </ScrollView>
    </KeyboardAvoidingView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: Platform.OS === 'ios' ? 60 : 40,
    paddingHorizontal: 16,
    paddingBottom: 16,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  saveButton: {
    paddingHorizontal: 16,
    paddingVertical: 8,
  },
  saveButtonText: {
    fontSize: 16,
    fontWeight: '600',
    color: '#6366f1',
  },
  content: {
    flex: 1,
    padding: 20,
  },
  section: {
    marginBottom: 20,
  },
  sectionTitle: {
    fontSize: 13,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 8,
    textTransform: 'uppercase',
  },
  input: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 14,
    fontSize: 16,
    color: '#1e293b',
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  readOnlyField: {
    backgroundColor: '#f1f5f9',
    borderRadius: 12,
    padding: 14,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  readOnlyText: {
    fontSize: 16,
    color: '#64748b',
  },
  row: {
    flexDirection: 'row',
  },
  pickerButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 14,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  pickerText: {
    fontSize: 16,
    color: '#1e293b',
  },
  pickerPlaceholder: {
    fontSize: 16,
    color: '#94a3b8',
  },
  pickerOptions: {
    marginTop: 8,
    backgroundColor: '#ffffff',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
    overflow: 'hidden',
  },
  pickerOption: {
    padding: 14,
    borderBottomWidth: 1,
    borderBottomColor: '#f1f5f9',
  },
  pickerOptionActive: {
    backgroundColor: '#eef2ff',
  },
  pickerOptionText: {
    fontSize: 16,
    color: '#334155',
  },
  pickerOptionTextActive: {
    color: '#6366f1',
    fontWeight: '600',
  },
  divider: {
    height: 1,
    backgroundColor: '#e2e8f0',
    marginVertical: 24,
  },
  groupTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 16,
  },
});

=== File: src/screens/SettingsScreen.tsx ===

import React, { useState } from 'react';
import { View, Text, StyleSheet, ScrollView, TouchableOpacity, Alert, Modal, Linking } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { Language } from '../types';
import { AuthScreen } from './AuthScreen';
import { apiService } from '../services/api';
import { MibuBrand } from '../../constants/Colors';

const LANGUAGE_OPTIONS: { code: Language; label: string; flag: string }[] = [
  { code: 'zh-TW', label: 'ç¹é«”ä¸­æ–‡', flag: 'ğŸ‡¹ğŸ‡¼' },
  { code: 'en', label: 'English', flag: 'ğŸ‡ºğŸ‡¸' },
  { code: 'ja', label: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ' },
  { code: 'ko', label: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·' },
];

export function SettingsScreen() {
  const { state, t, setLanguage, setUser } = useApp();
  const [showAuthModal, setShowAuthModal] = useState(false);
  const [showLanguageDropdown, setShowLanguageDropdown] = useState(false);
  const router = useRouter();
  const isZh = state.language === 'zh-TW';

  const currentLang = LANGUAGE_OPTIONS.find(l => l.code === state.language) || LANGUAGE_OPTIONS[0];

  const handleLogout = async () => {
    Alert.alert(
      isZh ? 'ç¢ºèªç™»å‡º' : 'Confirm Logout',
      isZh ? 'ç¢ºå®šè¦ç™»å‡ºå—ï¼Ÿ' : 'Are you sure you want to logout?',
      [
        { text: isZh ? 'å–æ¶ˆ' : 'Cancel', style: 'cancel' },
        {
          text: isZh ? 'ç™»å‡º' : 'Logout',
          style: 'destructive',
          onPress: async () => {
            try {
              const token = await AsyncStorage.getItem('@mibu_token');
              if (token) {
                await apiService.logout(token).catch(() => {});
              }
            } catch {}
            
            await AsyncStorage.multiRemove(['@mibu_token', 'token']);
            setUser(null);
            router.replace('/login');
          },
        },
      ]
    );
  };

  const handleDeleteAccount = () => {
    Alert.alert(
      isZh ? 'åˆªé™¤å¸³è™Ÿ' : 'Delete Account',
      isZh ? 'ç¢ºå®šè¦åˆªé™¤æ‚¨çš„å¸³è™Ÿå—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚' : 'Are you sure you want to delete your account? This action cannot be undone.',
      [
        { text: isZh ? 'å–æ¶ˆ' : 'Cancel', style: 'cancel' },
        {
          text: isZh ? 'åˆªé™¤' : 'Delete',
          style: 'destructive',
          onPress: async () => {
            try {
              const token = await AsyncStorage.getItem('@mibu_token');
              if (token) {
                const response = await apiService.deleteAccount(token);
                if (response.success) {
                  await AsyncStorage.multiRemove(['@mibu_token', 'token']);
                  setUser(null);
                  router.replace('/');
                } else {
                  let errorMsg = response.message || response.error;
                  if (response.code === 'MERCHANT_ACCOUNT_EXISTS') {
                    errorMsg = isZh ? 'è«‹å…ˆè§£é™¤å•†å®¶å¸³è™Ÿ' : 'Please deactivate merchant account first';
                  }
                  Alert.alert(
                    isZh ? 'ç„¡æ³•åˆªé™¤' : 'Cannot Delete',
                    errorMsg || (isZh ? 'åˆªé™¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Delete failed, please try again')
                  );
                }
              }
            } catch {
              Alert.alert(
                isZh ? 'éŒ¯èª¤' : 'Error',
                isZh ? 'åˆªé™¤å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦' : 'Delete failed, please try again'
              );
            }
          },
        },
      ]
    );
  };

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <Text style={styles.title}>{t.navSettings}</Text>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>
          {isZh ? 'èªè¨€' : 'Language'}
        </Text>
        <TouchableOpacity 
          style={styles.dropdownButton}
          onPress={() => setShowLanguageDropdown(true)}
        >
          <View style={styles.dropdownLeft}>
            <Text style={styles.dropdownFlag}>{currentLang.flag}</Text>
            <Text style={styles.dropdownLabel}>{currentLang.label}</Text>
          </View>
          <Ionicons name="chevron-down" size={20} color={MibuBrand.copper} />
        </TouchableOpacity>
      </View>

      {state.isAuthenticated && (
        <>
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>
              {isZh ? 'å€‹äººè³‡æ–™' : 'Profile'}
            </Text>
            <TouchableOpacity 
              style={styles.menuCard} 
              onPress={() => router.push('/profile' as any)}
            >
              <View style={styles.menuIconContainer}>
                <Ionicons name="person-outline" size={24} color={MibuBrand.brown} />
              </View>
              <View style={styles.menuInfo}>
                <Text style={styles.menuTitle}>
                  {state.user?.firstName || state.user?.name || 'User'}
                </Text>
                <Text style={styles.menuSubtitle}>
                  {isZh ? 'ç·¨è¼¯å€‹äººè³‡æ–™' : 'Edit profile'}
                </Text>
              </View>
              <Ionicons name="chevron-forward" size={20} color="#94a3b8" />
            </TouchableOpacity>
          </View>

          <View style={styles.section}>
            <Text style={styles.sectionTitle}>
              {isZh ? 'å¸³è™Ÿ' : 'Account'}
            </Text>
            <View style={styles.accountCard}>
              <View style={styles.accountInfo}>
                <View style={styles.avatar}>
                  <Text style={styles.avatarText}>
                    {state.user?.firstName?.charAt(0) || state.user?.name?.charAt(0) || '?'}
                  </Text>
                </View>
                <View style={styles.profileTextContainer}>
                  <Text style={styles.accountName}>
                    {state.user?.firstName || state.user?.name || 'User'}
                  </Text>
                  <Text style={styles.accountEmail}>
                    {state.user?.email || ''}
                  </Text>
                </View>
              </View>
              
              <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
                <Ionicons name="log-out-outline" size={20} color="#ef4444" />
                <Text style={styles.logoutText}>
                  {isZh ? 'ç™»å‡º' : 'Logout'}
                </Text>
              </TouchableOpacity>

              <TouchableOpacity style={styles.deleteButton} onPress={handleDeleteAccount}>
                <Ionicons name="trash-outline" size={18} color="#dc2626" />
                <Text style={styles.deleteText}>
                  {isZh ? 'åˆªé™¤å¸³è™Ÿ' : 'Delete Account'}
                </Text>
              </TouchableOpacity>
            </View>
          </View>
        </>
      )}

      {!state.isAuthenticated && (
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            {isZh ? 'å¸³è™Ÿ' : 'Account'}
          </Text>
          <TouchableOpacity style={styles.loginButton} onPress={() => setShowAuthModal(true)}>
            <Ionicons name="log-in-outline" size={20} color="#ffffff" />
            <Text style={styles.loginButtonText}>{t.login}</Text>
          </TouchableOpacity>
        </View>
      )}

      <AuthScreen 
        visible={showAuthModal} 
        onClose={() => setShowAuthModal(false)} 
      />

      {state.user?.role === 'admin' && !state.user?.isSuperAdmin && (
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>
            {isZh ? 'ç®¡ç†å“¡' : 'Admin'}
          </Text>
          <TouchableOpacity style={styles.adminCard} onPress={() => router.push('/admin-exclusions')}>
            <View style={styles.adminIconContainer}>
              <Ionicons name="ban-outline" size={24} color="#6366f1" />
            </View>
            <View style={styles.adminInfo}>
              <Text style={styles.adminTitle}>
                {isZh ? 'å…¨åŸŸæ’é™¤ç®¡ç†' : 'Global Exclusions'}
              </Text>
              <Text style={styles.adminSubtitle}>
                {isZh ? 'ç®¡ç†æ‰€æœ‰ä½¿ç”¨è€…ä¸æœƒæŠ½åˆ°çš„åœ°é»' : 'Manage places excluded for all users'}
              </Text>
            </View>
            <Ionicons name="chevron-forward" size={20} color="#94a3b8" />
          </TouchableOpacity>
        </View>
      )}

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>
          {isZh ? 'æ³•å¾‹èˆ‡æ”¯æ´' : 'Legal & Support'}
        </Text>
        <View style={styles.legalCard}>
          <TouchableOpacity 
            style={styles.legalItem}
            onPress={() => Linking.openURL('https://mibu-pages--s8869420.replit.app/privacy')}
          >
            <Ionicons name="shield-checkmark-outline" size={20} color={MibuBrand.copper} />
            <Text style={styles.legalText}>
              {isZh ? 'éš±ç§æ¬Šæ”¿ç­–' : 'Privacy Policy'}
            </Text>
            <Ionicons name="open-outline" size={16} color="#94a3b8" />
          </TouchableOpacity>
          <View style={styles.legalDivider} />
          <TouchableOpacity 
            style={styles.legalItem}
            onPress={() => Linking.openURL('https://mibu-pages--s8869420.replit.app/terms')}
          >
            <Ionicons name="document-text-outline" size={20} color={MibuBrand.copper} />
            <Text style={styles.legalText}>
              {isZh ? 'ä½¿ç”¨æ¢æ¬¾' : 'Terms of Service'}
            </Text>
            <Ionicons name="open-outline" size={16} color="#94a3b8" />
          </TouchableOpacity>
          <View style={styles.legalDivider} />
          <TouchableOpacity 
            style={styles.legalItem}
            onPress={() => Linking.openURL('https://mibu-pages--s8869420.replit.app/support')}
          >
            <Ionicons name="help-circle-outline" size={20} color={MibuBrand.copper} />
            <Text style={styles.legalText}>
              {isZh ? 'æŠ€è¡“æ”¯æ´' : 'Support'}
            </Text>
            <Ionicons name="open-outline" size={16} color="#94a3b8" />
          </TouchableOpacity>
        </View>
      </View>

      <View style={styles.section}>
        <Text style={styles.sectionTitle}>
          {isZh ? 'é—œæ–¼' : 'About'}
        </Text>
        <View style={styles.aboutCard}>
          <Text style={styles.appName}>Mibu æ—…è¡Œæ‰­è›‹</Text>
          <Text style={styles.version}>Version 1.0.0</Text>
          <Text style={styles.copyright}>Â© 2025 æŸ¥çˆ¾æ–¯æœ‰é™å…¬å¸</Text>
        </View>
      </View>

      <Modal
        visible={showLanguageDropdown}
        transparent={true}
        animationType="fade"
        onRequestClose={() => setShowLanguageDropdown(false)}
      >
        <TouchableOpacity 
          style={styles.modalOverlay} 
          activeOpacity={1}
          onPress={() => setShowLanguageDropdown(false)}
        >
          <View style={styles.modalContent}>
            <Text style={styles.modalTitle}>
              {isZh ? 'é¸æ“‡èªè¨€' : 'Select Language'}
            </Text>
            {LANGUAGE_OPTIONS.map(lang => (
              <TouchableOpacity
                key={lang.code}
                style={[
                  styles.languageOption,
                  state.language === lang.code && styles.languageOptionActive,
                ]}
                onPress={() => {
                  setLanguage(lang.code);
                  setShowLanguageDropdown(false);
                }}
              >
                <Text style={styles.languageOptionFlag}>{lang.flag}</Text>
                <Text style={[
                  styles.languageOptionLabel,
                  state.language === lang.code && styles.languageOptionLabelActive,
                ]}>
                  {lang.label}
                </Text>
                {state.language === lang.code && (
                  <Ionicons name="checkmark" size={20} color={MibuBrand.brown} />
                )}
              </TouchableOpacity>
            ))}
          </View>
        </TouchableOpacity>
      </Modal>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  title: {
    fontSize: 28,
    fontWeight: '900',
    color: MibuBrand.brownDark,
    marginBottom: 24,
  },
  section: {
    marginBottom: 28,
  },
  sectionTitle: {
    fontSize: 14,
    fontWeight: '700',
    color: MibuBrand.copper,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
    marginBottom: 12,
  },
  dropdownButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: MibuBrand.warmWhite,
    padding: 16,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  dropdownLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  dropdownFlag: {
    fontSize: 24,
  },
  dropdownLabel: {
    fontSize: 16,
    fontWeight: '600',
    color: MibuBrand.brownDark,
  },
  menuCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: MibuBrand.warmWhite,
    padding: 16,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
    gap: 12,
  },
  menuIconContainer: {
    width: 44,
    height: 44,
    backgroundColor: MibuBrand.highlight,
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
  },
  menuInfo: {
    flex: 1,
  },
  menuTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: MibuBrand.brownDark,
    marginBottom: 2,
  },
  menuSubtitle: {
    fontSize: 13,
    color: MibuBrand.copper,
  },
  accountCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    padding: 16,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  accountInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
    marginBottom: 16,
  },
  avatar: {
    width: 48,
    height: 48,
    backgroundColor: MibuBrand.brown,
    borderRadius: 24,
    alignItems: 'center',
    justifyContent: 'center',
  },
  avatarText: {
    color: '#ffffff',
    fontSize: 20,
    fontWeight: '700',
  },
  profileTextContainer: {
    flex: 1,
  },
  accountName: {
    fontSize: 16,
    fontWeight: '700',
    color: MibuBrand.brownDark,
  },
  accountEmail: {
    fontSize: 14,
    color: MibuBrand.copper,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    paddingVertical: 12,
    borderRadius: 12,
    backgroundColor: '#fef2f2',
    marginBottom: 8,
  },
  logoutText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#ef4444',
  },
  deleteButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 6,
    paddingVertical: 12,
    borderRadius: 12,
    backgroundColor: '#fef2f2',
    borderWidth: 1,
    borderColor: '#fecaca',
  },
  deleteText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#dc2626',
  },
  loginButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: 8,
    backgroundColor: MibuBrand.brown,
    paddingVertical: 16,
    borderRadius: 16,
  },
  loginButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
  aboutCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    padding: 20,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  appName: {
    fontSize: 18,
    fontWeight: '700',
    color: MibuBrand.brownDark,
    marginBottom: 4,
  },
  version: {
    fontSize: 14,
    color: MibuBrand.copper,
    marginBottom: 8,
  },
  copyright: {
    fontSize: 12,
    color: MibuBrand.tan,
  },
  legalCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
    overflow: 'hidden',
  },
  legalItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    gap: 12,
  },
  legalText: {
    flex: 1,
    fontSize: 15,
    fontWeight: '500',
    color: MibuBrand.brownDark,
  },
  legalDivider: {
    height: 1,
    backgroundColor: MibuBrand.tanLight,
    marginHorizontal: 16,
  },
  adminCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: MibuBrand.warmWhite,
    padding: 16,
    borderRadius: 16,
    borderWidth: 2,
    borderColor: '#c7d2fe',
    gap: 12,
  },
  adminIconContainer: {
    width: 44,
    height: 44,
    backgroundColor: '#eef2ff',
    borderRadius: 22,
    justifyContent: 'center',
    alignItems: 'center',
  },
  adminInfo: {
    flex: 1,
  },
  adminTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: MibuBrand.brownDark,
    marginBottom: 2,
  },
  adminSubtitle: {
    fontSize: 13,
    color: MibuBrand.copper,
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: 'rgba(0, 0, 0, 0.4)',
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  modalContent: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 20,
    padding: 20,
    width: '100%',
    maxWidth: 320,
  },
  modalTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: MibuBrand.brownDark,
    textAlign: 'center',
    marginBottom: 16,
  },
  languageOption: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 14,
    borderRadius: 12,
    gap: 12,
  },
  languageOptionActive: {
    backgroundColor: MibuBrand.highlight,
  },
  languageOptionFlag: {
    fontSize: 24,
  },
  languageOptionLabel: {
    flex: 1,
    fontSize: 16,
    fontWeight: '500',
    color: MibuBrand.brownDark,
  },
  languageOptionLabelActive: {
    fontWeight: '700',
    color: MibuBrand.brown,
  },
});

=== File: src/screens/SOSScreen.tsx ===

import React, { useState, useEffect, useCallback, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  ActivityIndicator,
  Alert,
  Platform,
  Animated,
} from 'react-native';
import * as Clipboard from 'expo-clipboard';
import * as Location from 'expo-location';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { API_BASE_URL } from '../constants/translations';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { SosAlert, SosAlertStatus } from '../types';

const AUTH_TOKEN_KEY = '@mibu_token';

const STATUS_COLORS: Record<SosAlertStatus, { bg: string; text: string; label: string; labelEn: string }> = {
  pending: { bg: '#fef3c7', text: '#d97706', label: 'ç­‰å¾…è™•ç†', labelEn: 'Pending' },
  acknowledged: { bg: '#dbeafe', text: '#2563eb', label: 'å·²ç¢ºèª', labelEn: 'Acknowledged' },
  resolved: { bg: '#dcfce7', text: '#16a34a', label: 'å·²è§£æ±º', labelEn: 'Resolved' },
  cancelled: { bg: '#f1f5f9', text: '#64748b', label: 'å·²å–æ¶ˆ', labelEn: 'Cancelled' },
};

export function SOSScreen() {
  const { t, state } = useApp();
  const router = useRouter();
  const isZh = state.language === 'zh-TW';
  
  const [webhookUrl, setWebhookUrl] = useState<string | null>(null);
  const [sosKey, setSosKey] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [sending, setSending] = useState(false);
  const [copied, setCopied] = useState(false);
  const [eligible, setEligible] = useState(true);
  const [eligibilityReason, setEligibilityReason] = useState<string | null>(null);
  const [alerts, setAlerts] = useState<SosAlert[]>([]);
  const progressAnim = useRef(new Animated.Value(0)).current;
  const holdTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const fetchData = useCallback(async () => {
    const userToken = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
    if (!userToken) {
      setLoading(false);
      return;
    }
    
    try {
      setLoading(true);
      
      const [eligibilityData, alertsData] = await Promise.allSettled([
        apiService.getSosEligibility(userToken),
        apiService.getSosAlerts(userToken),
      ]);
      
      if (eligibilityData.status === 'fulfilled') {
        setEligible(eligibilityData.value.eligible);
        setEligibilityReason(eligibilityData.value.reason);
      }
      
      if (alertsData.status === 'fulfilled') {
        setAlerts(alertsData.value.alerts || []);
      }
      
      const fullUrl = `${API_BASE_URL}/api/user/sos-link`;
      const response = await fetch(fullUrl, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${userToken}`,
        },
      });
      
      if (response.ok) {
        const data = await response.json();
        const url = data.webhookUrl || data.url;
        const key = data.key || data.sosKey;
        
        if (url) {
          setWebhookUrl(url);
          if (key) {
            setSosKey(key);
          } else {
            try {
              const urlObj = new URL(url);
              const keyFromUrl = urlObj.searchParams.get('key');
              if (keyFromUrl) {
                setSosKey(keyFromUrl);
              }
            } catch {}
          }
        }
      }
    } catch (error: any) {
      console.error('Failed to fetch SOS data:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchData();
  }, [fetchData]);

  const copyToClipboard = async () => {
    if (webhookUrl) {
      await Clipboard.setStringAsync(webhookUrl);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const handlePressIn = () => {
    if (!eligible || sending) return;

    progressAnim.setValue(0);
    Animated.timing(progressAnim, {
      toValue: 1,
      duration: 3000,
      useNativeDriver: false,
    }).start();

    holdTimerRef.current = setTimeout(() => {
      triggerSOS();
    }, 3000);
  };

  const handlePressOut = () => {
    if (holdTimerRef.current) {
      clearTimeout(holdTimerRef.current);
      holdTimerRef.current = null;
    }
    progressAnim.stopAnimation();
    progressAnim.setValue(0);
  };

  const triggerSOS = async () => {
    setSending(true);
    try {
      const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
      if (!token) return;

      let locationData: { location?: string; locationAddress?: string } = {};

      try {
        const { status } = await Location.requestForegroundPermissionsAsync();
        if (status === 'granted') {
          const position = await Location.getCurrentPositionAsync({});
          locationData.location = `${position.coords.latitude},${position.coords.longitude}`;

          try {
            const [address] = await Location.reverseGeocodeAsync({
              latitude: position.coords.latitude,
              longitude: position.coords.longitude,
            });
            if (address) {
              locationData.locationAddress = [
                address.street,
                address.district,
                address.city,
                address.region,
                address.country,
              ].filter(Boolean).join(', ');
            }
          } catch {}
        }
      } catch {}

      const response = await apiService.sendSosAlert(token, locationData);

      if (response.success) {
        Alert.alert(
          isZh ? 'æ±‚æ•‘è¨Šè™Ÿå·²ç™¼é€' : 'SOS Alert Sent',
          response.message || (isZh ? 'æˆ‘å€‘æœƒç›¡å¿«è¯ç¹«æ‚¨' : 'We will contact you as soon as possible'),
          [{ text: 'OK', onPress: fetchData }]
        );
      }
    } catch (error: any) {
      if (sosKey) {
        const triggerUrl = `${API_BASE_URL}/api/sos/trigger?key=${sosKey}`;
        try {
          const response = await fetch(triggerUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
          });
          
          if (response.ok) {
            Alert.alert(t.sent, t.sosSuccess);
            fetchData();
            return;
          }
        } catch {}
      }
      
      Alert.alert(
        isZh ? 'ç™¼é€å¤±æ•—' : 'Failed to Send',
        isZh ? 'è«‹ç¨å¾Œå†è©¦' : 'Please try again later'
      );
    } finally {
      setSending(false);
    }
  };

  const handleCancelAlert = async (alertId: number) => {
    Alert.alert(
      isZh ? 'ç¢ºèªå–æ¶ˆ' : 'Confirm Cancel',
      isZh ? 'ç¢ºå®šè¦å–æ¶ˆé€™å€‹æ±‚æ•‘è¨Šè™Ÿå—ï¼Ÿ' : 'Are you sure you want to cancel this alert?',
      [
        { text: isZh ? 'å¦' : 'No', style: 'cancel' },
        {
          text: isZh ? 'æ˜¯' : 'Yes',
          style: 'destructive',
          onPress: async () => {
            try {
              const token = await AsyncStorage.getItem(AUTH_TOKEN_KEY);
              if (!token) return;

              await apiService.cancelSosAlert(token, alertId);
              fetchData();
            } catch (error) {
              Alert.alert(
                isZh ? 'éŒ¯èª¤' : 'Error',
                isZh ? 'å–æ¶ˆå¤±æ•—' : 'Failed to cancel'
              );
            }
          },
        },
      ]
    );
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleString(isZh ? 'zh-TW' : 'en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#ef4444" />
        <Text style={styles.loadingText}>{t.loading}</Text>
      </View>
    );
  }

  const progressWidth = progressAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0%', '100%'],
  });

  return (
    <View style={styles.container}>
      <View style={styles.headerBar}>
        <TouchableOpacity onPress={() => router.back()} style={styles.backButton}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>{isZh ? 'å®‰å…¨ä¸­å¿ƒ' : 'Safety Center'}</Text>
        <View style={{ width: 40 }} />
      </View>

      <ScrollView style={styles.scrollView} contentContainerStyle={styles.contentContainer}>
        {!eligible ? (
          <View style={styles.lockedCard}>
            <View style={styles.lockIcon}>
              <Ionicons name="lock-closed" size={48} color="#94a3b8" />
            </View>
            <Text style={styles.lockedTitle}>
              {isZh ? 'SOS åŠŸèƒ½å·²é–å®š' : 'SOS Feature Locked'}
            </Text>
            <Text style={styles.lockedText}>
              {eligibilityReason || (isZh ? 'éœ€è³¼è²·æ—…ç¨‹æœå‹™æ‰èƒ½ä½¿ç”¨å®‰å…¨ä¸­å¿ƒåŠŸèƒ½' : 'Purchase travel service to unlock Safety Center')}
            </Text>
            <TouchableOpacity 
              style={styles.purchaseButton}
              onPress={() => router.push('/purchase-service' as any)}
            >
              <Text style={styles.purchaseButtonText}>
                {isZh ? 'è³¼è²·æœå‹™' : 'Purchase Service'}
              </Text>
            </TouchableOpacity>
          </View>
        ) : (
          <>
            <View style={styles.header}>
              <View style={styles.iconContainer}>
                <Ionicons name="shield-checkmark" size={48} color="#ef4444" />
              </View>
              <Text style={styles.title}>{t.safetyCenter}</Text>
              <Text style={styles.subtitle}>{t.safetyCenterDesc}</Text>
            </View>

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>{isZh ? 'ç·Šæ€¥æ±‚æ•‘' : 'Emergency SOS'}</Text>
              <Text style={styles.sectionDescription}>
                {isZh 
                  ? 'é•·æŒ‰ä¸‹æ–¹æŒ‰éˆ• 3 ç§’ç™¼é€æ±‚æ•‘è¨Šè™Ÿï¼Œæˆ‘å€‘æœƒç«‹å³é€šçŸ¥æ‚¨çš„æ—…ç¨‹ç­–ç•«å¸«'
                  : 'Press and hold the button for 3 seconds to send an SOS alert'}
              </Text>
              
              <TouchableOpacity
                style={[styles.sosButton, sending && styles.sosButtonDisabled]}
                onPressIn={handlePressIn}
                onPressOut={handlePressOut}
                disabled={sending}
                activeOpacity={0.9}
              >
                <Animated.View 
                  style={[
                    styles.sosButtonProgress,
                    { width: progressWidth }
                  ]} 
                />
                <View style={styles.sosButtonContent}>
                  {sending ? (
                    <ActivityIndicator color="#ffffff" size="large" />
                  ) : (
                    <>
                      <Ionicons name="warning" size={40} color="#ffffff" />
                      <Text style={styles.sosButtonText}>SOS</Text>
                      <Text style={styles.sosButtonHint}>
                        {isZh ? 'é•·æŒ‰ 3 ç§’' : 'Hold 3 sec'}
                      </Text>
                    </>
                  )}
                </View>
              </TouchableOpacity>
            </View>

            {alerts.length > 0 && (
              <View style={styles.section}>
                <Text style={styles.sectionTitle}>{isZh ? 'æ±‚æ•‘è¨˜éŒ„' : 'Alert History'}</Text>
                {alerts.map(alert => {
                  const statusInfo = STATUS_COLORS[alert.status];
                  return (
                    <View key={alert.id} style={styles.alertCard}>
                      <View style={styles.alertHeader}>
                        <View style={[styles.statusBadge, { backgroundColor: statusInfo.bg }]}>
                          <Text style={[styles.statusText, { color: statusInfo.text }]}>
                            {isZh ? statusInfo.label : statusInfo.labelEn}
                          </Text>
                        </View>
                        <Text style={styles.alertDate}>
                          {formatDate(alert.createdAt)}
                        </Text>
                      </View>

                      {alert.locationAddress && (
                        <View style={styles.alertRow}>
                          <Ionicons name="location" size={16} color="#64748b" />
                          <Text style={styles.alertRowText}>{alert.locationAddress}</Text>
                        </View>
                      )}

                      {alert.status === 'pending' && (
                        <TouchableOpacity
                          style={styles.cancelAlertButton}
                          onPress={() => handleCancelAlert(alert.id)}
                        >
                          <Text style={styles.cancelAlertButtonText}>
                            {isZh ? 'å–æ¶ˆæ±‚æ•‘' : 'Cancel Alert'}
                          </Text>
                        </TouchableOpacity>
                      )}
                    </View>
                  );
                })}
              </View>
            )}

            <View style={styles.section}>
              <Text style={styles.sectionTitle}>{t.iosShortcutsIntegration}</Text>
              <Text style={styles.sectionDescription}>
                {t.iosShortcutsDesc}
              </Text>
              
              <View style={styles.webhookBox}>
                <Text style={styles.webhookLabel}>{t.webhookUrl}</Text>
                <View style={styles.webhookContent}>
                  <Text style={styles.webhookUrl} numberOfLines={2} ellipsizeMode="middle">
                    {webhookUrl || t.notAvailable}
                  </Text>
                </View>
                
                <TouchableOpacity
                  style={[styles.copyButton, copied && styles.copyButtonSuccess]}
                  onPress={copyToClipboard}
                  disabled={!webhookUrl}
                >
                  <Ionicons 
                    name={copied ? "checkmark" : "copy-outline"} 
                    size={20} 
                    color="#ffffff" 
                  />
                  <Text style={styles.copyButtonText}>
                    {copied ? t.copied : t.copyLink}
                  </Text>
                </TouchableOpacity>
              </View>

              <View style={styles.instructionBox}>
                <Text style={styles.instructionTitle}>{t.setupSteps}</Text>
                <Text style={styles.instructionStep}>{t.step1}</Text>
                <Text style={styles.instructionStep}>{t.step2}</Text>
                <Text style={styles.instructionStep}>{t.step3}</Text>
                <Text style={styles.instructionStep}>{t.step4}</Text>
                <Text style={styles.instructionStep}>{t.step5}</Text>
              </View>
            </View>
          </>
        )}

        <View style={{ height: 100 }} />
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  scrollView: {
    flex: 1,
  },
  contentContainer: {
    padding: 20,
  },
  headerBar: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    paddingTop: Platform.OS === 'ios' ? 60 : 40,
    paddingHorizontal: 16,
    paddingBottom: 16,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    width: 40,
    height: 40,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f8fafc',
  },
  loadingText: {
    marginTop: 12,
    fontSize: 16,
    color: '#64748b',
  },
  lockedCard: {
    backgroundColor: '#ffffff',
    borderRadius: 20,
    padding: 32,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  lockIcon: {
    width: 80,
    height: 80,
    backgroundColor: '#f1f5f9',
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  lockedTitle: {
    fontSize: 20,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 12,
  },
  lockedText: {
    fontSize: 14,
    color: '#64748b',
    textAlign: 'center',
    lineHeight: 22,
    marginBottom: 24,
  },
  purchaseButton: {
    backgroundColor: '#6366f1',
    paddingHorizontal: 32,
    paddingVertical: 14,
    borderRadius: 12,
  },
  purchaseButtonText: {
    fontSize: 16,
    fontWeight: '700',
    color: '#ffffff',
  },
  header: {
    alignItems: 'center',
    marginBottom: 32,
  },
  iconContainer: {
    width: 80,
    height: 80,
    backgroundColor: '#fef2f2',
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 16,
  },
  title: {
    fontSize: 28,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 8,
  },
  subtitle: {
    fontSize: 16,
    color: '#64748b',
    textAlign: 'center',
  },
  section: {
    marginBottom: 28,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '600',
    color: '#1e293b',
    marginBottom: 8,
  },
  sectionDescription: {
    fontSize: 14,
    color: '#64748b',
    marginBottom: 16,
    lineHeight: 20,
  },
  sosButton: {
    height: 140,
    backgroundColor: '#ef4444',
    borderRadius: 20,
    overflow: 'hidden',
    shadowColor: '#ef4444',
    shadowOffset: { width: 0, height: 8 },
    shadowOpacity: 0.4,
    shadowRadius: 16,
    elevation: 8,
  },
  sosButtonDisabled: {
    opacity: 0.7,
  },
  sosButtonProgress: {
    position: 'absolute',
    left: 0,
    top: 0,
    bottom: 0,
    backgroundColor: '#dc2626',
  },
  sosButtonContent: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  sosButtonText: {
    fontSize: 28,
    fontWeight: '900',
    color: '#ffffff',
    marginTop: 4,
  },
  sosButtonHint: {
    fontSize: 12,
    color: 'rgba(255,255,255,0.8)',
    marginTop: 2,
  },
  alertCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    marginBottom: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  alertHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 12,
  },
  statusBadge: {
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 8,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '600',
  },
  alertDate: {
    fontSize: 12,
    color: '#94a3b8',
  },
  alertRow: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    gap: 8,
    marginBottom: 8,
  },
  alertRowText: {
    flex: 1,
    fontSize: 14,
    color: '#334155',
  },
  cancelAlertButton: {
    marginTop: 8,
    paddingVertical: 10,
    backgroundColor: '#fef2f2',
    borderRadius: 8,
    alignItems: 'center',
  },
  cancelAlertButtonText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#ef4444',
  },
  webhookBox: {
    backgroundColor: '#ffffff',
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.05,
    shadowRadius: 2,
    elevation: 1,
  },
  webhookLabel: {
    fontSize: 12,
    fontWeight: '600',
    color: '#64748b',
    marginBottom: 8,
    textTransform: 'uppercase',
    letterSpacing: 0.5,
  },
  webhookContent: {
    backgroundColor: '#f1f5f9',
    borderRadius: 8,
    padding: 12,
    marginBottom: 12,
  },
  webhookUrl: {
    fontSize: 13,
    color: '#334155',
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
  },
  copyButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: '#3b82f6',
    borderRadius: 8,
    paddingVertical: 12,
    gap: 8,
  },
  copyButtonSuccess: {
    backgroundColor: '#22c55e',
  },
  copyButtonText: {
    color: '#ffffff',
    fontSize: 15,
    fontWeight: '600',
  },
  instructionBox: {
    backgroundColor: '#fffbeb',
    borderRadius: 12,
    padding: 16,
    borderWidth: 1,
    borderColor: '#fde68a',
  },
  instructionTitle: {
    fontSize: 14,
    fontWeight: '600',
    color: '#92400e',
    marginBottom: 12,
  },
  instructionStep: {
    fontSize: 14,
    color: '#78350f',
    marginBottom: 6,
    lineHeight: 20,
  },
});

=== File: src/screens/SpecialistDashboardScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Switch,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { SpecialistInfo, ServiceRelation } from '../types';
import { RoleSwitcher } from '../components/RoleSwitcher';
import { MibuBrand } from '../../constants/Colors';

export function SpecialistDashboardScreen() {
  const { state, getToken, setUser } = useApp();
  const router = useRouter();
  const [specialist, setSpecialist] = useState<SpecialistInfo | null>(null);
  const [services, setServices] = useState<ServiceRelation[]>([]);
  const [loading, setLoading] = useState(true);
  const [toggling, setToggling] = useState(false);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å°ˆå“¡å¾Œå°' : 'Specialist Dashboard',
    online: isZh ? 'ä¸Šç·šä¸­' : 'Online',
    offline: isZh ? 'é›¢ç·š' : 'Offline',
    toggleOnline: isZh ? 'ä¸Šç·šç‹€æ…‹' : 'Online Status',
    activeServices: isZh ? 'æœå‹™ä¸­æ—…å®¢' : 'Active Services',
    noServices: isZh ? 'ç›®å‰ç„¡æœå‹™ä¸­æ—…å®¢' : 'No active services',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    since: isZh ? 'é–‹å§‹æ–¼' : 'Since',
    region: isZh ? 'åœ°å€' : 'Region',
    logout: isZh ? 'ç™»å‡º' : 'Logout',
  };

  const handleLogout = async () => {
    await AsyncStorage.removeItem('@mibu_token');
    await AsyncStorage.removeItem('@mibu_user');
    setUser(null);
    router.replace('/login');
  };

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;

      const [specialistData, servicesData] = await Promise.all([
        apiService.getSpecialistMe(token).catch(() => null),
        apiService.getSpecialistServices(token).catch(() => ({ relations: [] })),
      ]);

      setSpecialist(specialistData);
      setServices(servicesData.relations || []);
    } catch (error) {
      console.error('Failed to load specialist data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleToggleOnline = async () => {
    try {
      setToggling(true);
      const token = await getToken();
      if (!token) return;

      const response = await apiService.toggleSpecialistOnline(token);
      setSpecialist(response.specialist);
    } catch (error) {
      console.error('Failed to toggle online:', error);
    } finally {
      setToggling(false);
    }
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleString(isZh ? 'zh-TW' : 'en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={MibuBrand.brown} />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <View style={styles.header}>
        <View style={styles.headerLeft}>
          <Text style={styles.title}>{translations.title}</Text>
          {state.user?.isSuperAdmin && <RoleSwitcher compact />}
        </View>
        <TouchableOpacity style={styles.logoutButton} onPress={handleLogout}>
          <Ionicons name="log-out-outline" size={20} color="#ef4444" />
          <Text style={styles.logoutText}>{translations.logout}</Text>
        </TouchableOpacity>
      </View>

      <View style={styles.statusCard}>
        <View style={styles.statusHeader}>
          <View style={styles.statusInfo}>
            <View style={[
              styles.statusIndicator,
              specialist?.isOnline ? styles.statusOnline : styles.statusOffline,
            ]} />
            <Text style={styles.statusText}>
              {specialist?.isOnline ? translations.online : translations.offline}
            </Text>
          </View>
          <View style={styles.toggleContainer}>
            {toggling ? (
              <ActivityIndicator size="small" color="#6366f1" />
            ) : (
              <Switch
                value={specialist?.isOnline || false}
                onValueChange={handleToggleOnline}
                trackColor={{ false: '#e2e8f0', true: '#c7d2fe' }}
                thumbColor={specialist?.isOnline ? '#6366f1' : '#94a3b8'}
              />
            )}
          </View>
        </View>
        <Text style={styles.toggleLabel}>{translations.toggleOnline}</Text>
        {specialist?.serviceRegion && (
          <Text style={styles.regionText}>
            {translations.region}: {specialist.serviceRegion}
          </Text>
        )}
      </View>

      <View style={styles.menuSection}>
        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/specialist/travelers' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="people-outline" size={24} color="#6366f1" />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'æœå‹™ä¸­æ—…å®¢' : 'Active Travelers'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'æŸ¥çœ‹æœå‹™ä¸­çš„æ—…å®¢' : 'View travelers being served'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#94a3b8" />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/specialist/tracking' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="map-outline" size={24} color="#6366f1" />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'å³æ™‚ä½ç½®è¿½è¹¤' : 'Live Tracking'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'åœ¨åœ°åœ–ä¸ŠæŸ¥çœ‹æ—…å®¢ä½ç½®' : 'View travelers on map'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#94a3b8" />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/specialist/history' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="time-outline" size={24} color="#6366f1" />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'æœå‹™æ­·å²' : 'Service History'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'æŸ¥çœ‹éå¾€æœå‹™è¨˜éŒ„' : 'View past service records'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#94a3b8" />
        </TouchableOpacity>

        <TouchableOpacity
          style={styles.menuItem}
          onPress={() => router.push('/specialist/profile' as any)}
        >
          <View style={styles.menuIcon}>
            <Ionicons name="person-circle-outline" size={24} color="#6366f1" />
          </View>
          <View style={styles.menuContent}>
            <Text style={styles.menuTitle}>{isZh ? 'å°ˆå“¡è³‡æ–™' : 'Specialist Profile'}</Text>
            <Text style={styles.menuSubtitle}>{isZh ? 'æŸ¥çœ‹èˆ‡ç·¨è¼¯å€‹äººè³‡æ–™' : 'View and edit profile'}</Text>
          </View>
          <Ionicons name="chevron-forward" size={20} color="#94a3b8" />
        </TouchableOpacity>
      </View>

      <Text style={styles.sectionTitle}>{translations.activeServices}</Text>

      {services.length === 0 ? (
        <View style={styles.emptyCard}>
          <Ionicons name="people-outline" size={48} color="#94a3b8" />
          <Text style={styles.emptyText}>{translations.noServices}</Text>
        </View>
      ) : (
        <View style={styles.servicesList}>
          {services.map(service => (
            <View key={service.id} style={styles.serviceCard}>
              <View style={styles.serviceAvatar}>
                <Ionicons name="person" size={24} color="#ffffff" />
              </View>
              <View style={styles.serviceInfo}>
                <Text style={styles.serviceName}>
                  {service.traveler?.name || `Traveler #${service.travelerId}`}
                </Text>
                <Text style={styles.serviceDate}>
                  {translations.since}: {formatDate(service.createdAt)}
                </Text>
              </View>
              <View style={[
                styles.serviceStatus,
                service.status === 'active' && styles.serviceStatusActive,
              ]}>
                <Text style={styles.serviceStatusText}>{service.status}</Text>
              </View>
            </View>
          ))}
        </View>
      )}
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: MibuBrand.creamLight,
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: MibuBrand.copper,
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 24,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  title: {
    fontSize: 28,
    fontWeight: '900',
    color: MibuBrand.brown,
  },
  logoutButton: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingVertical: 10,
    paddingHorizontal: 14,
    backgroundColor: '#fef2f2',
    borderRadius: 12,
  },
  logoutText: {
    fontSize: 14,
    fontWeight: '600',
    color: MibuBrand.error,
  },
  statusCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 20,
    padding: 20,
    marginBottom: 24,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  statusHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    marginBottom: 12,
  },
  statusInfo: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 12,
  },
  statusIndicator: {
    width: 12,
    height: 12,
    borderRadius: 6,
  },
  statusOnline: {
    backgroundColor: '#22c55e',
  },
  statusOffline: {
    backgroundColor: '#94a3b8',
  },
  statusText: {
    fontSize: 18,
    fontWeight: '700',
    color: MibuBrand.dark,
  },
  toggleContainer: {
    width: 60,
    alignItems: 'flex-end',
  },
  toggleLabel: {
    fontSize: 14,
    color: MibuBrand.copper,
  },
  regionText: {
    fontSize: 14,
    color: MibuBrand.brown,
    marginTop: 8,
  },
  menuSection: {
    marginBottom: 24,
    gap: 12,
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    padding: 16,
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  menuIcon: {
    width: 44,
    height: 44,
    borderRadius: 12,
    backgroundColor: MibuBrand.highlight,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  menuContent: {
    flex: 1,
  },
  menuTitle: {
    fontSize: 16,
    fontWeight: '700',
    color: MibuBrand.dark,
    marginBottom: 2,
  },
  menuSubtitle: {
    fontSize: 13,
    color: MibuBrand.copper,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: MibuBrand.dark,
    marginBottom: 16,
  },
  emptyCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  emptyText: {
    fontSize: 16,
    color: MibuBrand.copper,
    marginTop: 12,
  },
  servicesList: {
    gap: 12,
  },
  serviceCard: {
    backgroundColor: MibuBrand.warmWhite,
    borderRadius: 16,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: MibuBrand.tanLight,
  },
  serviceAvatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: MibuBrand.brown,
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  serviceInfo: {
    flex: 1,
  },
  serviceName: {
    fontSize: 16,
    fontWeight: '700',
    color: MibuBrand.dark,
    marginBottom: 4,
  },
  serviceDate: {
    fontSize: 13,
    color: MibuBrand.copper,
  },
  serviceStatus: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
    backgroundColor: MibuBrand.highlight,
  },
  serviceStatusActive: {
    backgroundColor: '#dcfce7',
  },
  serviceStatusText: {
    fontSize: 12,
    fontWeight: '600',
    color: MibuBrand.copper,
  },
});

=== File: src/screens/SpecialistHistoryScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { ServiceRelation } from '../types';

export function SpecialistHistoryScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [services, setServices] = useState<ServiceRelation[]>([]);
  const [loading, setLoading] = useState(true);
  const [filter, setFilter] = useState<'all' | 'active' | 'completed'>('all');

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'æœå‹™æ­·å²' : 'Service History',
    all: isZh ? 'å…¨éƒ¨' : 'All',
    active: isZh ? 'é€²è¡Œä¸­' : 'Active',
    completed: isZh ? 'å·²å®Œæˆ' : 'Completed',
    cancelled: isZh ? 'å·²å–æ¶ˆ' : 'Cancelled',
    noServices: isZh ? 'å°šç„¡æœå‹™è¨˜éŒ„' : 'No service history',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    since: isZh ? 'é–‹å§‹æ–¼' : 'Started',
    traveler: isZh ? 'æ—…å®¢' : 'Traveler',
    status: isZh ? 'ç‹€æ…‹' : 'Status',
  };

  useEffect(() => {
    loadServices();
  }, []);

  const loadServices = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;
      const data = await apiService.getSpecialistServices(token);
      setServices(data.relations || []);
    } catch (error) {
      console.error('Failed to load services:', error);
    } finally {
      setLoading(false);
    }
  };

  const filteredServices = services.filter(service => {
    if (filter === 'all') return true;
    if (filter === 'active') return service.status === 'active';
    if (filter === 'completed') return service.status === 'completed';
    return true;
  });

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleDateString(isZh ? 'zh-TW' : 'en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'active': return translations.active;
      case 'completed': return translations.completed;
      case 'cancelled': return translations.cancelled;
      default: return status;
    }
  };

  const getStatusStyle = (status: string) => {
    switch (status) {
      case 'active': return { badge: styles.activeBadge, text: styles.activeText };
      case 'completed': return { badge: styles.completedBadge, text: styles.completedText };
      case 'cancelled': return { badge: styles.cancelledBadge, text: styles.cancelledText };
      default: return { badge: styles.activeBadge, text: styles.activeText };
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
      </View>

      <View style={styles.filterRow}>
        {(['all', 'active', 'completed'] as const).map(f => (
          <TouchableOpacity
            key={f}
            style={[styles.filterButton, filter === f && styles.filterButtonActive]}
            onPress={() => setFilter(f)}
          >
            <Text style={[styles.filterText, filter === f && styles.filterTextActive]}>
              {f === 'all' ? translations.all : f === 'active' ? translations.active : translations.completed}
            </Text>
          </TouchableOpacity>
        ))}
      </View>

      {filteredServices.length === 0 ? (
        <View style={styles.emptyCard}>
          <Ionicons name="time-outline" size={48} color="#94a3b8" />
          <Text style={styles.emptyText}>{translations.noServices}</Text>
        </View>
      ) : (
        <View style={styles.servicesList}>
          {filteredServices.map(service => {
            const statusStyle = getStatusStyle(service.status);
            return (
              <View key={service.id} style={styles.serviceCard}>
                <View style={styles.serviceAvatar}>
                  <Ionicons name="person" size={24} color="#ffffff" />
                </View>
                <View style={styles.serviceInfo}>
                  <Text style={styles.serviceName}>
                    {service.traveler?.name || `${translations.traveler} #${service.travelerId.slice(0, 8)}`}
                  </Text>
                  <Text style={styles.serviceDate}>
                    {translations.since}: {formatDate(service.createdAt)}
                  </Text>
                </View>
                <View style={[styles.statusBadge, statusStyle.badge]}>
                  <Text style={[styles.statusText, statusStyle.text]}>
                    {getStatusLabel(service.status)}
                  </Text>
                </View>
              </View>
            );
          })}
        </View>
      )}
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 24,
    gap: 12,
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  title: {
    fontSize: 24,
    fontWeight: '900',
    color: '#1e293b',
  },
  filterRow: {
    flexDirection: 'row',
    gap: 8,
    marginBottom: 20,
  },
  filterButton: {
    flex: 1,
    paddingVertical: 12,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  filterButtonActive: {
    backgroundColor: '#6366f1',
    borderColor: '#6366f1',
  },
  filterText: {
    fontSize: 14,
    fontWeight: '600',
    color: '#64748b',
  },
  filterTextActive: {
    color: '#ffffff',
  },
  emptyCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 12,
  },
  servicesList: {
    gap: 12,
  },
  serviceCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  serviceAvatar: {
    width: 48,
    height: 48,
    borderRadius: 24,
    backgroundColor: '#6366f1',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  serviceInfo: {
    flex: 1,
  },
  serviceName: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  serviceDate: {
    fontSize: 13,
    color: '#64748b',
  },
  statusBadge: {
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  statusText: {
    fontSize: 12,
    fontWeight: '600',
  },
  activeBadge: {
    backgroundColor: '#dcfce7',
  },
  activeText: {
    color: '#16a34a',
  },
  completedBadge: {
    backgroundColor: '#e0e7ff',
  },
  completedText: {
    color: '#6366f1',
  },
  cancelledBadge: {
    backgroundColor: '#fef2f2',
  },
  cancelledText: {
    color: '#ef4444',
  },
});

=== File: src/screens/SpecialistProfileScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  Switch,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { SpecialistInfo } from '../types';

export function SpecialistProfileScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [specialist, setSpecialist] = useState<SpecialistInfo | null>(null);
  const [loading, setLoading] = useState(true);
  const [updating, setUpdating] = useState(false);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å°ˆå“¡è³‡æ–™' : 'Specialist Profile',
    name: isZh ? 'å§“å' : 'Name',
    region: isZh ? 'æœå‹™åœ°å€' : 'Service Region',
    status: isZh ? 'å¸³è™Ÿç‹€æ…‹' : 'Account Status',
    online: isZh ? 'ä¸Šç·šç‹€æ…‹' : 'Online Status',
    available: isZh ? 'å¯æ¥å–®' : 'Available',
    unavailable: isZh ? 'æš«åœæ¥å–®' : 'Unavailable',
    onlineYes: isZh ? 'ä¸Šç·šä¸­' : 'Online',
    onlineNo: isZh ? 'é›¢ç·š' : 'Offline',
    currentTravelers: isZh ? 'ç›®å‰æœå‹™ä¸­' : 'Currently Serving',
    maxTravelers: isZh ? 'æœ€å¤§æœå‹™äººæ•¸' : 'Max Travelers',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    people: isZh ? 'äºº' : '',
  };

  useEffect(() => {
    loadSpecialist();
  }, []);

  const loadSpecialist = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;
      const data = await apiService.getSpecialistMe(token);
      setSpecialist(data);
    } catch (error) {
      console.error('Failed to load specialist:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleToggleAvailable = async () => {
    if (!specialist) return;
    try {
      setUpdating(true);
      const token = await getToken();
      if (!token) return;
      const data = await apiService.updateSpecialistAvailability(token, !specialist.isAvailable);
      setSpecialist(data.specialist);
    } catch (error) {
      console.error('Failed to update availability:', error);
    } finally {
      setUpdating(false);
    }
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <ScrollView style={styles.container} contentContainerStyle={styles.content}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
      </View>

      <View style={styles.avatarSection}>
        <View style={styles.avatar}>
          <Ionicons name="person" size={48} color="#6366f1" />
        </View>
        <Text style={styles.name}>{specialist?.name || state.user?.name || '-'}</Text>
        <View style={[
          styles.onlineBadge,
          specialist?.isOnline ? styles.onlineBadgeActive : styles.onlineBadgeInactive
        ]}>
          <View style={[
            styles.onlineDot,
            specialist?.isOnline ? styles.onlineDotActive : styles.onlineDotInactive
          ]} />
          <Text style={[
            styles.onlineText,
            specialist?.isOnline ? styles.onlineTextActive : styles.onlineTextInactive
          ]}>
            {specialist?.isOnline ? translations.onlineYes : translations.onlineNo}
          </Text>
        </View>
      </View>

      <View style={styles.availabilityCard}>
        <View style={styles.availabilityInfo}>
          <View style={styles.availabilityIcon}>
            <Ionicons 
              name={specialist?.isAvailable ? "checkmark-circle" : "pause-circle"} 
              size={24} 
              color={specialist?.isAvailable ? "#22c55e" : "#f59e0b"} 
            />
          </View>
          <View style={styles.availabilityContent}>
            <Text style={styles.availabilityLabel}>
              {specialist?.isAvailable ? translations.available : translations.unavailable}
            </Text>
          </View>
        </View>
        {updating ? (
          <ActivityIndicator size="small" color="#6366f1" />
        ) : (
          <Switch
            value={specialist?.isAvailable || false}
            onValueChange={handleToggleAvailable}
            trackColor={{ false: '#e2e8f0', true: '#c7d2fe' }}
            thumbColor={specialist?.isAvailable ? '#6366f1' : '#94a3b8'}
          />
        )}
      </View>

      <View style={styles.infoCard}>
        <View style={styles.infoRow}>
          <View style={styles.infoIcon}>
            <Ionicons name="location-outline" size={20} color="#6366f1" />
          </View>
          <View style={styles.infoContent}>
            <Text style={styles.infoLabel}>{translations.region}</Text>
            <Text style={styles.infoValue}>
              {specialist?.serviceRegion || '-'}
            </Text>
          </View>
        </View>

        <View style={styles.divider} />

        <View style={styles.infoRow}>
          <View style={styles.infoIcon}>
            <Ionicons name="people-outline" size={20} color="#6366f1" />
          </View>
          <View style={styles.infoContent}>
            <Text style={styles.infoLabel}>{translations.currentTravelers}</Text>
            <Text style={styles.infoValue}>
              {specialist?.currentTravelers ?? 0} {translations.people}
            </Text>
          </View>
        </View>

        <View style={styles.divider} />

        <View style={styles.infoRow}>
          <View style={styles.infoIcon}>
            <Ionicons name="person-add-outline" size={20} color="#6366f1" />
          </View>
          <View style={styles.infoContent}>
            <Text style={styles.infoLabel}>{translations.maxTravelers}</Text>
            <Text style={styles.infoValue}>
              {specialist?.maxTravelers ?? 5} {translations.people}
            </Text>
          </View>
        </View>
      </View>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  content: {
    padding: 20,
    paddingTop: 60,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 24,
    gap: 12,
  },
  backButton: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: '#ffffff',
    alignItems: 'center',
    justifyContent: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  title: {
    fontSize: 24,
    fontWeight: '900',
    color: '#1e293b',
  },
  avatarSection: {
    alignItems: 'center',
    marginBottom: 24,
  },
  avatar: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: '#eef2ff',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: 16,
    borderWidth: 3,
    borderColor: '#c7d2fe',
  },
  name: {
    fontSize: 24,
    fontWeight: '800',
    color: '#1e293b',
    marginBottom: 12,
  },
  onlineBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 8,
    paddingHorizontal: 16,
    paddingVertical: 8,
    borderRadius: 20,
  },
  onlineBadgeActive: {
    backgroundColor: '#dcfce7',
  },
  onlineBadgeInactive: {
    backgroundColor: '#f1f5f9',
  },
  onlineDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  onlineDotActive: {
    backgroundColor: '#22c55e',
  },
  onlineDotInactive: {
    backgroundColor: '#94a3b8',
  },
  onlineText: {
    fontSize: 14,
    fontWeight: '600',
  },
  onlineTextActive: {
    color: '#16a34a',
  },
  onlineTextInactive: {
    color: '#64748b',
  },
  availabilityCard: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 20,
    marginBottom: 20,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  availabilityInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  availabilityIcon: {
    marginRight: 12,
  },
  availabilityContent: {
    flex: 1,
  },
  availabilityLabel: {
    fontSize: 16,
    fontWeight: '700',
    color: '#1e293b',
  },
  infoCard: {
    backgroundColor: '#ffffff',
    borderRadius: 20,
    padding: 20,
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  infoRow: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingVertical: 12,
  },
  infoIcon: {
    width: 40,
    height: 40,
    borderRadius: 12,
    backgroundColor: '#eef2ff',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 16,
  },
  infoContent: {
    flex: 1,
  },
  infoLabel: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 4,
  },
  infoValue: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1e293b',
  },
  divider: {
    height: 1,
    backgroundColor: '#e2e8f0',
    marginVertical: 4,
  },
});

=== File: src/screens/SpecialistTrackingScreen.tsx ===

import React, { useState, useEffect, useRef } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Platform,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter, useLocalSearchParams } from 'expo-router';
import { io, Socket } from 'socket.io-client';
import { useApp } from '../context/AppContext';
import { API_BASE_URL } from '../constants/translations';

interface TravelerLocation {
  travelerId: string;
  serviceId?: number;
  lat: number;
  lng: number;
  timestamp: string;
  travelerName?: string;
}

export function SpecialistTrackingScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const params = useLocalSearchParams();
  const socketRef = useRef<Socket | null>(null);
  const [locations, setLocations] = useState<Map<string, TravelerLocation>>(new Map());
  const [connected, setConnected] = useState(false);
  const [loading, setLoading] = useState(true);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'å³æ™‚ä½ç½®è¿½è¹¤' : 'Live Location Tracking',
    connecting: isZh ? 'é€£ç·šä¸­...' : 'Connecting...',
    connected: isZh ? 'å·²é€£ç·š' : 'Connected',
    disconnected: isZh ? 'å·²æ–·ç·š' : 'Disconnected',
    noLocations: isZh ? 'å°šç„¡æ—…å®¢ä½ç½®è³‡æ–™' : 'No traveler locations yet',
    lastUpdate: isZh ? 'æœ€å¾Œæ›´æ–°' : 'Last update',
    travelers: isZh ? 'æ—…å®¢' : 'travelers',
  };

  useEffect(() => {
    initSocket();
    return () => {
      if (socketRef.current) {
        socketRef.current.disconnect();
      }
    };
  }, []);

  const initSocket = async () => {
    try {
      const token = await getToken();
      if (!token) {
        setLoading(false);
        return;
      }

      socketRef.current = io(API_BASE_URL, {
        auth: { token },
        transports: ['websocket', 'polling'],
      });

      socketRef.current.on('connect', () => {
        setConnected(true);
        setLoading(false);
        socketRef.current?.emit('specialist_subscribe', {});
      });

      socketRef.current.on('disconnect', () => {
        setConnected(false);
      });

      socketRef.current.on('traveler_location', (data: TravelerLocation) => {
        setLocations(prev => {
          const updated = new Map(prev);
          updated.set(data.travelerId, data);
          return updated;
        });
      });

      socketRef.current.on('active_travelers', (data: { count: number; travelers: TravelerLocation[] }) => {
        const newLocations = new Map<string, TravelerLocation>();
        data.travelers.forEach(t => {
          newLocations.set(t.travelerId, t);
        });
        setLocations(newLocations);
      });

      socketRef.current.on('connect_error', (error) => {
        console.error('Socket connection error:', error);
        setLoading(false);
      });
    } catch (error) {
      console.error('Failed to initialize socket:', error);
      setLoading(false);
    }
  };

  const formatTime = (timestamp: string) => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString(isZh ? 'zh-TW' : 'en-US', {
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
    });
  };

  const locationArray = Array.from(locations.values());

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.connecting}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
        <View style={[styles.connectionStatus, connected ? styles.statusConnected : styles.statusDisconnected]}>
          <View style={[styles.statusDot, connected ? styles.dotConnected : styles.dotDisconnected]} />
          <Text style={styles.statusText}>
            {connected ? translations.connected : translations.disconnected}
          </Text>
        </View>
      </View>

      <View style={styles.content}>
        {Platform.OS === 'web' ? (
          <View style={styles.webMapPlaceholder}>
            <Ionicons name="map-outline" size={64} color="#94a3b8" />
            <Text style={styles.webMapText}>
              {isZh ? 'åœ°åœ–åœ¨ç¶²é ç‰ˆä¸å¯ç”¨' : 'Map not available on web'}
            </Text>
            <Text style={styles.travelerCount}>
              {locationArray.length} {translations.travelers}
            </Text>
          </View>
        ) : (
          <View style={styles.mapContainer}>
            <Text style={styles.mapPlaceholderText}>
              {isZh ? 'åœ°åœ–å€åŸŸ - éœ€è¦ react-native-maps' : 'Map Area - requires react-native-maps'}
            </Text>
          </View>
        )}

        <View style={styles.travelerListCard}>
          <Text style={styles.listTitle}>
            {isZh ? 'æ—…å®¢ä½ç½®' : 'Traveler Locations'} ({locationArray.length})
          </Text>
          {locationArray.length === 0 ? (
            <Text style={styles.noDataText}>{translations.noLocations}</Text>
          ) : (
            <View style={styles.travelerList}>
              {locationArray.map(loc => (
                <View key={loc.travelerId} style={styles.travelerItem}>
                  <View style={styles.travelerIcon}>
                    <Ionicons name="person-circle" size={36} color="#6366f1" />
                  </View>
                  <View style={styles.travelerDetails}>
                    <Text style={styles.travelerName}>
                      {loc.travelerName || `Traveler #${loc.travelerId.slice(-6)}`}
                    </Text>
                    <Text style={styles.travelerCoords}>
                      {loc.lat.toFixed(6)}, {loc.lng.toFixed(6)}
                    </Text>
                    <Text style={styles.travelerTime}>
                      {translations.lastUpdate}: {formatTime(loc.timestamp)}
                    </Text>
                  </View>
                  <TouchableOpacity style={styles.focusButton}>
                    <Ionicons name="locate" size={20} color="#6366f1" />
                  </TouchableOpacity>
                </View>
              ))}
            </View>
          )}
        </View>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    marginRight: 16,
  },
  title: {
    flex: 1,
    fontSize: 20,
    fontWeight: '800',
    color: '#1e293b',
  },
  connectionStatus: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 20,
  },
  statusConnected: {
    backgroundColor: '#dcfce7',
  },
  statusDisconnected: {
    backgroundColor: '#fef2f2',
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
  },
  dotConnected: {
    backgroundColor: '#22c55e',
  },
  dotDisconnected: {
    backgroundColor: '#ef4444',
  },
  statusText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#64748b',
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  content: {
    flex: 1,
  },
  webMapPlaceholder: {
    height: 200,
    backgroundColor: '#e2e8f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  webMapText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  travelerCount: {
    marginTop: 8,
    fontSize: 14,
    fontWeight: '600',
    color: '#6366f1',
  },
  mapContainer: {
    height: 300,
    backgroundColor: '#e2e8f0',
    alignItems: 'center',
    justifyContent: 'center',
  },
  mapPlaceholderText: {
    color: '#64748b',
    fontSize: 14,
  },
  travelerListCard: {
    flex: 1,
    backgroundColor: '#ffffff',
    borderTopLeftRadius: 24,
    borderTopRightRadius: 24,
    padding: 20,
    marginTop: -20,
  },
  listTitle: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 16,
  },
  noDataText: {
    textAlign: 'center',
    color: '#94a3b8',
    fontSize: 16,
    paddingVertical: 40,
  },
  travelerList: {
    gap: 12,
  },
  travelerItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 12,
    backgroundColor: '#f8fafc',
    borderRadius: 12,
    borderWidth: 1,
    borderColor: '#e2e8f0',
  },
  travelerIcon: {
    marginRight: 12,
  },
  travelerDetails: {
    flex: 1,
  },
  travelerName: {
    fontSize: 16,
    fontWeight: '600',
    color: '#1e293b',
    marginBottom: 2,
  },
  travelerCoords: {
    fontSize: 12,
    color: '#64748b',
    fontFamily: Platform.OS === 'ios' ? 'Menlo' : 'monospace',
  },
  travelerTime: {
    fontSize: 11,
    color: '#94a3b8',
    marginTop: 2,
  },
  focusButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: '#eef2ff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

=== File: src/screens/SpecialistTravelersScreen.tsx ===

import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  RefreshControl,
} from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import { useRouter } from 'expo-router';
import { useApp } from '../context/AppContext';
import { apiService } from '../services/api';
import { ServiceRelation } from '../types';

interface TravelerData {
  serviceRelation: ServiceRelation;
  traveler: {
    id: string;
    firstName: string;
    lastName: string;
  };
}

export function SpecialistTravelersScreen() {
  const { state, getToken } = useApp();
  const router = useRouter();
  const [travelers, setTravelers] = useState<TravelerData[]>([]);
  const [loading, setLoading] = useState(true);
  const [refreshing, setRefreshing] = useState(false);

  const isZh = state.language === 'zh-TW';

  const translations = {
    title: isZh ? 'æœå‹™ä¸­æ—…å®¢' : 'Active Travelers',
    noTravelers: isZh ? 'ç›®å‰ç„¡æœå‹™ä¸­æ—…å®¢' : 'No active travelers',
    loading: isZh ? 'è¼‰å…¥ä¸­...' : 'Loading...',
    since: isZh ? 'é–‹å§‹æ–¼' : 'Since',
    status: isZh ? 'ç‹€æ…‹' : 'Status',
    active: isZh ? 'æœå‹™ä¸­' : 'Active',
    viewLocation: isZh ? 'æŸ¥çœ‹ä½ç½®' : 'View Location',
    chat: isZh ? 'èŠå¤©' : 'Chat',
  };

  useEffect(() => {
    loadTravelers();
  }, []);

  const loadTravelers = async () => {
    try {
      setLoading(true);
      const token = await getToken();
      if (!token) return;

      const response = await apiService.getSpecialistTravelers(token);
      setTravelers(response.travelers || []);
    } catch (error) {
      console.error('Failed to load travelers:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await loadTravelers();
    setRefreshing(false);
  };

  const formatDate = (dateStr: string) => {
    const date = new Date(dateStr);
    return date.toLocaleString(isZh ? 'zh-TW' : 'en-US', {
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
    });
  };

  if (loading) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color="#6366f1" />
        <Text style={styles.loadingText}>{translations.loading}</Text>
      </View>
    );
  }

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <TouchableOpacity style={styles.backButton} onPress={() => router.back()}>
          <Ionicons name="arrow-back" size={24} color="#1e293b" />
        </TouchableOpacity>
        <Text style={styles.title}>{translations.title}</Text>
      </View>

      <ScrollView
        style={styles.scrollView}
        contentContainerStyle={styles.content}
        refreshControl={
          <RefreshControl refreshing={refreshing} onRefresh={handleRefresh} />
        }
      >
        {travelers.length === 0 ? (
          <View style={styles.emptyCard}>
            <Ionicons name="people-outline" size={48} color="#94a3b8" />
            <Text style={styles.emptyText}>{translations.noTravelers}</Text>
          </View>
        ) : (
          <View style={styles.travelersList}>
            {travelers.map(({ serviceRelation, traveler }) => (
              <View key={serviceRelation.id} style={styles.travelerCard}>
                <View style={styles.travelerAvatar}>
                  <Ionicons name="person" size={28} color="#ffffff" />
                </View>
                <View style={styles.travelerInfo}>
                  <Text style={styles.travelerName}>
                    {traveler.firstName} {traveler.lastName}
                  </Text>
                  <Text style={styles.travelerDate}>
                    {translations.since}: {formatDate(serviceRelation.createdAt)}
                  </Text>
                  <View style={styles.statusBadge}>
                    <View style={styles.statusDot} />
                    <Text style={styles.statusText}>{translations.active}</Text>
                  </View>
                </View>
                <View style={styles.actions}>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => router.push(`/specialist/tracking?travelerId=${traveler.id}` as any)}
                  >
                    <Ionicons name="location" size={20} color="#6366f1" />
                  </TouchableOpacity>
                  <TouchableOpacity
                    style={styles.actionButton}
                    onPress={() => router.push(`/specialist/chat/${traveler.id}` as any)}
                  >
                    <Ionicons name="chatbubble" size={20} color="#6366f1" />
                  </TouchableOpacity>
                </View>
              </View>
            ))}
          </View>
        )}
      </ScrollView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#f8fafc',
  },
  header: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 20,
    paddingTop: 60,
    paddingBottom: 20,
    backgroundColor: '#ffffff',
    borderBottomWidth: 1,
    borderBottomColor: '#e2e8f0',
  },
  backButton: {
    marginRight: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: '800',
    color: '#1e293b',
  },
  scrollView: {
    flex: 1,
  },
  content: {
    padding: 20,
    paddingBottom: 100,
  },
  loadingContainer: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
  },
  loadingText: {
    marginTop: 12,
    color: '#64748b',
    fontSize: 16,
  },
  emptyCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 40,
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  emptyText: {
    fontSize: 16,
    color: '#64748b',
    marginTop: 12,
  },
  travelersList: {
    gap: 12,
  },
  travelerCard: {
    backgroundColor: '#ffffff',
    borderRadius: 16,
    padding: 16,
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: '#e2e8f0',
  },
  travelerAvatar: {
    width: 56,
    height: 56,
    borderRadius: 28,
    backgroundColor: '#6366f1',
    alignItems: 'center',
    justifyContent: 'center',
    marginRight: 12,
  },
  travelerInfo: {
    flex: 1,
  },
  travelerName: {
    fontSize: 18,
    fontWeight: '700',
    color: '#1e293b',
    marginBottom: 4,
  },
  travelerDate: {
    fontSize: 13,
    color: '#64748b',
    marginBottom: 6,
  },
  statusBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: 6,
    backgroundColor: '#dcfce7',
    paddingHorizontal: 10,
    paddingVertical: 4,
    borderRadius: 12,
    alignSelf: 'flex-start',
  },
  statusDot: {
    width: 8,
    height: 8,
    borderRadius: 4,
    backgroundColor: '#22c55e',
  },
  statusText: {
    fontSize: 12,
    fontWeight: '600',
    color: '#16a34a',
  },
  actions: {
    flexDirection: 'row',
    gap: 8,
  },
  actionButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: '#eef2ff',
    alignItems: 'center',
    justifyContent: 'center',
  },
});

=== File: src/services/api.ts ===

import { API_BASE_URL } from '../constants/translations';
import { Country, Region, User, GachaItem, Language, GachaPoolResponse, GachaPullPayload, GachaPullResponse, GlobalExclusion, AuthResponse, UserRole, MerchantDailyCode, MerchantCredits, SpecialistInfo, ServiceRelation, MerchantMe, MerchantTransaction, MerchantPlace, MerchantProduct, PlaceSearchResult, AdminUser, PlaceDraft, Announcement, AnnouncementsResponse, CreateAnnouncementParams, UpdateAnnouncementParams, RegionPoolCoupon, InventoryItem, InventoryResponse, InventoryConfig, RarityConfig, RedeemResponse, CollectionWithPromoResponse, AutoSaveCollectionResponse, AdConfig, NotificationStatus, MerchantRedemptionCode, AdPlacement, ItineraryGenerateResponse, UserProfile, UpdateProfileParams, ProfileResponse, SosEligibility, SosSendParams, SosSendResponse, SosAlertsResponse, SosAlert, MerchantApplyParams, MerchantApplyResponse, MerchantAnalytics, MerchantCoupon, MerchantCouponsResponse, CreateMerchantCouponParams, UpdateMerchantCouponParams, AnnouncementType, PrizePoolResponse, UnreadCounts, CollectionItem, CollectionResponse, DeleteAccountResponse } from '../types';
import { Platform } from 'react-native';

class ApiService {
  private baseUrl = API_BASE_URL;

  private async request<T>(endpoint: string, options: RequestInit = {}): Promise<T> {
    const url = `${this.baseUrl}${endpoint}`;
    const response = await fetch(url, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        ...options.headers,
      },
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    return response.json();
  }

  async getCountries(): Promise<Country[]> {
    const data = await this.request<{ countries: Country[] }>('/api/locations/countries');
    return data.countries || [];
  }

  async getRegions(countryId: number): Promise<Region[]> {
    const data = await this.request<{ regions: Region[] }>(`/api/locations/regions/${countryId}`);
    return data.regions || [];
  }

  async getDistricts(regionId: number): Promise<{ count: number; districts: { id: number; name: string; nameZh?: string; nameEn?: string; nameJa?: string; nameKo?: string }[] }> {
    const data = await this.request<{ districts: any[]; count?: number }>(`/api/locations/districts/${regionId}`);
    return { 
      count: data.districts?.length || data.count || 0,
      districts: data.districts || []
    };
  }

  async generateItinerary(params: {
    regionId?: number;
    countryId?: number;
    itemCount?: number;
    pace?: 'relaxed' | 'moderate' | 'packed';
    language?: string;
  }, token?: string): Promise<ItineraryGenerateResponse> {
    const url = `${this.baseUrl}/api/gacha/itinerary/v3`;
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
    };
    if (token) {
      headers['Authorization'] = `Bearer ${token}`;
    }
    const response = await fetch(url, {
      method: 'POST',
      headers,
      body: JSON.stringify(params),
    });
    
    const data = await response.json();
    return data;
  }

  async getCurrentUser(): Promise<User | null> {
    try {
      const data = await this.request<User>('/api/auth/user');
      return data;
    } catch {
      return null;
    }
  }

  async saveToCollection(item: Partial<GachaItem>): Promise<void> {
    await this.request('/api/collections', {
      method: 'POST',
      body: JSON.stringify(item),
    });
  }

  async excludePlace(params: {
    placeName: string;
    district: string;
    city: string;
    placeCacheId?: string | null;
  }): Promise<void> {
    await this.request('/api/feedback/exclude', {
      method: 'POST',
      body: JSON.stringify(params),
    });
  }

  async getPlacePromo(params: {
    placeId?: string;
    placeName?: string;
    district?: string;
    city?: string;
  }): Promise<{ promo: any | null }> {
    const queryParams = new URLSearchParams();
    if (params.placeId) queryParams.append('placeId', params.placeId);
    if (params.placeName) queryParams.append('placeName', params.placeName);
    if (params.district) queryParams.append('district', params.district);
    if (params.city) queryParams.append('city', params.city);
    
    return this.request(`/api/place/promo?${queryParams}`);
  }

  async getGachaPool(city: string): Promise<GachaPoolResponse> {
    try {
      const params = new URLSearchParams({ city });
      const data = await this.request<GachaPoolResponse>(`/api/gacha/pool?${params}`);
      return data;
    } catch (error) {
      console.error('Failed to get gacha pool:', error);
      throw error;
    }
  }

  async pullGacha(payload: GachaPullPayload): Promise<GachaPullResponse> {
    try {
      const data = await this.request<GachaPullResponse>('/api/gacha/pull', {
        method: 'POST',
        body: JSON.stringify(payload),
      });
      return data;
    } catch (error) {
      console.error('Failed to pull gacha:', error);
      throw error;
    }
  }

  async getGlobalExclusions(token: string): Promise<GlobalExclusion[]> {
    try {
      const data = await this.request<{ exclusions: GlobalExclusion[] }>('/api/admin/global-exclusions', {
        headers: {
          'Authorization': `Bearer ${token}`,
        },
      });
      return data.exclusions || [];
    } catch (error) {
      console.error('Failed to get global exclusions:', error);
      throw error;
    }
  }

  async addGlobalExclusion(token: string, params: {
    placeName: string;
    district: string;
    city: string;
  }): Promise<GlobalExclusion> {
    const data = await this.request<{ success: boolean; exclusion: GlobalExclusion }>('/api/admin/global-exclusions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
    return data.exclusion;
  }

  async removeGlobalExclusion(token: string, id: number): Promise<void> {
    await this.request(`/api/admin/global-exclusions/${id}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async register(params: {
    username: string;
    password: string;
    name: string;
    role: UserRole;
  }): Promise<AuthResponse> {
    return this.request<AuthResponse>('/api/auth/register', {
      method: 'POST',
      body: JSON.stringify(params),
    });
  }

  async login(username: string, password: string): Promise<AuthResponse> {
    return this.request<AuthResponse>('/api/auth/login', {
      method: 'POST',
      body: JSON.stringify({ username, password }),
    });
  }

  async getUserWithToken(token: string): Promise<User> {
    return this.request<User>('/api/auth/user', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async switchRole(token: string, role: UserRole): Promise<{ user: User; activeRole: string }> {
    return this.request<{ user: User; activeRole: string }>('/api/auth/switch-role', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ role }),
    });
  }

  async getMerchantDailyCode(token: string): Promise<MerchantDailyCode> {
    return this.request<MerchantDailyCode>('/api/merchant/daily-code', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getMerchantCredits(token: string): Promise<MerchantCredits> {
    return this.request<MerchantCredits>('/api/merchant/credits', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async purchaseCredits(token: string, amount: number, provider: 'stripe' | 'recur' = 'stripe'): Promise<{ 
    transactionId: number;
    amount: number;
    provider: 'stripe' | 'recur';
    checkoutUrl: string | null;
    status: string;
    message: string;
  }> {
    return this.request('/api/merchant/credits/purchase', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ amount, provider }),
    });
  }

  async getChatToken(token: string): Promise<{ token: string; identity: string }> {
    return this.request<{ token: string; identity: string }>('/api/chat/token', {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getSpecialistMe(token: string): Promise<SpecialistInfo> {
    return this.request<SpecialistInfo>('/api/specialist/me', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async toggleSpecialistOnline(token: string): Promise<{ specialist: SpecialistInfo }> {
    return this.request<{ specialist: SpecialistInfo }>('/api/specialist/toggle-online', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async updateSpecialistAvailability(token: string, isAvailable: boolean): Promise<{ specialist: SpecialistInfo }> {
    return this.request<{ specialist: SpecialistInfo }>('/api/specialist/availability', {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ isAvailable }),
    });
  }

  async getSpecialistTravelers(token: string): Promise<{ travelers: Array<{ serviceRelation: ServiceRelation; traveler: { id: string; firstName: string; lastName: string } }> }> {
    return this.request('/api/specialist/travelers', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getSpecialistServices(token: string): Promise<{ relations: ServiceRelation[] }> {
    return this.request<{ relations: ServiceRelation[] }>('/api/specialist/services', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getMerchantMe(token: string): Promise<MerchantMe> {
    return this.request<MerchantMe>('/api/merchant/me', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async registerMerchant(token: string, params: {
    businessName: string;
    contactEmail?: string;
  }): Promise<{ merchant: MerchantMe }> {
    return this.request('/api/merchant/register', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async verifyMerchantCode(token: string, merchantId: number, code: string): Promise<{ valid: boolean; merchant?: any; error?: string }> {
    return this.request('/api/merchant/verify', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ merchantId, code }),
    });
  }

  async getMerchantTransactions(token: string): Promise<{ transactions: MerchantTransaction[] }> {
    return this.request('/api/merchant/transactions', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async searchMerchantPlaces(token: string, query: string): Promise<{ places: PlaceSearchResult[] }> {
    console.log('ğŸ” Search query:', query);
    console.log('ğŸ” Token:', token ? 'exists' : 'missing');
    
    const response = await fetch(`${this.baseUrl}/api/merchant/places/search?query=${encodeURIComponent(query)}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });
    
    console.log('ğŸ“¡ Response status:', response.status);
    
    if (response.status === 401) {
      console.log('âŒ 401 Unauthorized - redirecting to login');
      throw new Error('UNAUTHORIZED');
    }
    
    if (!response.ok) {
      const errorText = await response.text();
      console.log('âŒ Error response:', errorText);
      throw new Error(`Search failed: ${response.status}`);
    }
    
    const data = await response.json();
    console.log('âœ… Search results:', data);
    return data;
  }

  async claimMerchantPlace(token: string, place: {
    placeName: string;
    district?: string;
    city?: string;
    country?: string;
    placeCacheId?: string;
    googlePlaceId?: string;
  }): Promise<{ place: MerchantPlace }> {
    const requestBody = {
      placeName: place.placeName,
      district: place.district || '',
      city: place.city || '',
      country: place.country || 'å°ç£',
      placeCacheId: place.placeCacheId,
      googlePlaceId: place.googlePlaceId,
    };
    console.log('ğŸª Claim request body:', requestBody);
    
    return this.request('/api/merchant/places/claim', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(requestBody),
    });
  }

  async getMerchantPlaces(token: string): Promise<{ places: MerchantPlace[] }> {
    return this.request('/api/merchant/places', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async updateMerchantPlace(token: string, linkId: string, params: Partial<MerchantPlace>): Promise<{ place: MerchantPlace }> {
    return this.request(`/api/merchant/places/${linkId}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async getMerchantProducts(token: string): Promise<{ products: MerchantProduct[] }> {
    return this.request('/api/merchant/products', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async createMerchantProduct(token: string, params: {
    name: string;
    description?: string;
    price?: number;
    discountPrice?: number;
    placeId?: number;
  }): Promise<{ product: MerchantProduct }> {
    return this.request('/api/merchant/products', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async updateMerchantProduct(token: string, productId: number, params: Partial<MerchantProduct>): Promise<{ product: MerchantProduct }> {
    return this.request(`/api/merchant/products/${productId}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async deleteMerchantProduct(token: string, productId: number): Promise<{ success: boolean }> {
    return this.request(`/api/merchant/products/${productId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async registerSpecialist(token: string, params: {
    serviceRegion?: string;
  }): Promise<{ specialist: SpecialistInfo }> {
    return this.request('/api/specialist/register', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  // Merchant Apply & Analytics
  async applyMerchant(token: string, params: MerchantApplyParams): Promise<MerchantApplyResponse> {
    return this.request('/api/merchant/apply', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async getMerchantAnalytics(token: string): Promise<MerchantAnalytics> {
    return this.request('/api/merchant/analytics', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // Merchant Coupons CRUD
  async getMerchantCoupons(token: string): Promise<MerchantCouponsResponse> {
    return this.request('/api/merchant/coupons', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async createMerchantCoupon(token: string, params: CreateMerchantCouponParams): Promise<{ success: boolean; coupon: MerchantCoupon }> {
    return this.request('/api/merchant/coupons', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async updateMerchantCoupon(token: string, couponId: number, params: UpdateMerchantCouponParams): Promise<{ success: boolean; coupon: MerchantCoupon }> {
    return this.request(`/api/merchant/coupons/${couponId}`, {
      method: 'PUT',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async deleteMerchantCoupon(token: string, couponId: number): Promise<{ success: boolean }> {
    return this.request(`/api/merchant/coupons/${couponId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getAdminUsers(token: string): Promise<{ users: AdminUser[] }> {
    return this.request('/api/admin/users', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getAdminPendingUsers(token: string): Promise<{ users: AdminUser[] }> {
    return this.request('/api/admin/users/pending', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async approveUser(token: string, userId: string, isApproved: boolean): Promise<{ user: AdminUser }> {
    return this.request(`/api/admin/users/${userId}/approve`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ isApproved }),
    });
  }

  async getPlaceDrafts(token: string): Promise<{ drafts: PlaceDraft[] }> {
    return this.request('/api/admin/place-drafts', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async createPlaceDraft(token: string, params: {
    placeName: string;
    district?: string;
    city?: string;
    category?: string;
  }): Promise<{ draft: PlaceDraft }> {
    return this.request('/api/admin/place-drafts', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async deletePlaceDraft(token: string, draftId: number): Promise<{ success: boolean }> {
    return this.request(`/api/admin/place-drafts/${draftId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async publishPlaceDraft(token: string, draftId: number): Promise<{ success: boolean }> {
    return this.request(`/api/admin/place-drafts/${draftId}/publish`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getAnnouncements(): Promise<AnnouncementsResponse> {
    return this.request<AnnouncementsResponse>('/api/announcements');
  }

  async getAdminAnnouncements(token: string): Promise<AnnouncementsResponse> {
    return this.request<AnnouncementsResponse>('/api/admin/announcements', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async createAnnouncement(token: string, params: CreateAnnouncementParams): Promise<{ success: boolean; announcement: Announcement }> {
    return this.request('/api/admin/announcements', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async updateAnnouncement(token: string, id: number, params: UpdateAnnouncementParams): Promise<{ success: boolean; announcement: Announcement }> {
    return this.request(`/api/admin/announcements/${id}`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async deleteAnnouncement(token: string, id: number): Promise<{ success: boolean; message: string }> {
    return this.request(`/api/admin/announcements/${id}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getRegionCouponPool(token: string, regionId: number): Promise<RegionPoolCoupon[]> {
    return this.request<RegionPoolCoupon[]>(`/api/coupons/region/${regionId}/pool`, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // Ads API
  async getAdPlacement(placement: AdPlacement, platform: 'ios' | 'android' | 'web'): Promise<{ ad: AdConfig | null }> {
    return this.request<{ ad: AdConfig | null }>(`/api/ads/placements?placement=${placement}&platform=${platform}`);
  }

  // Notifications API
  async getNotifications(token: string): Promise<UnreadCounts> {
    return this.request<UnreadCounts>('/api/notifications', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async markNotificationSeen(token: string, type: 'itembox' | 'collection' | 'announcement'): Promise<{ success: boolean }> {
    return this.request<{ success: boolean }>(`/api/notifications/${type}/seen`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // Inventory / Itembox API
  async getInventory(token: string): Promise<InventoryResponse> {
    return this.request<InventoryResponse>('/api/inventory', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getInventoryItem(token: string, itemId: number): Promise<{ item: InventoryItem }> {
    return this.request<{ item: InventoryItem }>(`/api/inventory/${itemId}`, {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getInventoryConfig(): Promise<InventoryConfig> {
    return this.request<InventoryConfig>('/api/inventory/config');
  }

  async getRarityConfig(): Promise<{ config: RarityConfig }> {
    return this.request<{ config: RarityConfig }>('/api/rarity-config');
  }

  async markInventoryItemRead(token: string, itemId: number): Promise<{ success: boolean }> {
    return this.request<{ success: boolean }>(`/api/inventory/${itemId}/read`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async deleteInventoryItem(token: string, itemId: number): Promise<{ success: boolean; message: string }> {
    return this.request<{ success: boolean; message: string }>(`/api/inventory/${itemId}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async redeemInventoryItem(token: string, itemId: number, redemptionCode: string): Promise<RedeemResponse> {
    return this.request<RedeemResponse>(`/api/inventory/${itemId}/redeem`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify({ redemptionCode }),
    });
  }

  // Collection with Promo API
  async getCollectionWithPromo(token: string): Promise<CollectionWithPromoResponse> {
    return this.request<CollectionWithPromoResponse>('/api/collection/with-promo', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async autoSaveToCollection(token: string, params: {
    placeName: string;
    country: string;
    city: string;
    district: string;
    category: string;
    description?: string;
  }): Promise<AutoSaveCollectionResponse> {
    return this.request<AutoSaveCollectionResponse>('/api/collection/auto-save', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  // Merchant Redemption Code API
  async getMerchantRedemptionCode(token: string): Promise<MerchantRedemptionCode> {
    return this.request<MerchantRedemptionCode>('/api/merchant/redemption-code', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // Profile APIs
  async getProfile(token: string): Promise<UserProfile> {
    return this.request<UserProfile>('/api/profile', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async updateProfile(token: string, params: UpdateProfileParams): Promise<ProfileResponse> {
    return this.request<ProfileResponse>('/api/profile', {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async logout(token: string): Promise<{ success: boolean; message: string }> {
    return this.request<{ success: boolean; message: string }>('/api/auth/logout', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // SOS APIs
  async getSosEligibility(token: string): Promise<SosEligibility> {
    return this.request<SosEligibility>('/api/sos/eligibility', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async sendSosAlert(token: string, params: SosSendParams): Promise<SosSendResponse> {
    return this.request<SosSendResponse>('/api/sos/alert', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async getSosAlerts(token: string): Promise<SosAlertsResponse> {
    return this.request<SosAlertsResponse>('/api/sos/alerts', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async cancelSosAlert(token: string, alertId: number): Promise<{ success: boolean; alert: SosAlert }> {
    return this.request<{ success: boolean; alert: SosAlert }>(`/api/sos/alerts/${alertId}/cancel`, {
      method: 'PATCH',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  async getSosLink(token: string): Promise<{ link: string }> {
    return this.request<{ link: string }>('/api/user/sos-link', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // ============================================
  // å…¬å‘Š API
  // ============================================
  async getAnnouncementsByType(type?: AnnouncementType): Promise<AnnouncementsResponse> {
    const url = type ? `/api/announcements?type=${type}` : '/api/announcements';
    return this.request<AnnouncementsResponse>(url);
  }

  // ============================================
  // çæ±  API
  // ============================================
  async getPrizePool(regionId: number): Promise<PrizePoolResponse> {
    return this.request<PrizePoolResponse>(`/api/gacha/prize-pool?regionId=${regionId}`);
  }

  // ============================================
  // æœªè®€è¨ˆæ•¸ API (ä½¿ç”¨ /api/notifications)
  // ============================================
  async getUnreadCounts(token: string): Promise<UnreadCounts> {
    return this.request<UnreadCounts>('/api/notifications', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // ============================================
  // ä½ç½® API
  // ============================================
  async updateLocation(token: string, params: { latitude: number; longitude: number }): Promise<{ success: boolean }> {
    return this.request<{ success: boolean }>('/api/location/update', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${token}`,
      },
      body: JSON.stringify(params),
    });
  }

  async getMyLocation(token: string): Promise<{ location: { latitude: number; longitude: number } | null }> {
    return this.request<{ location: { latitude: number; longitude: number } | null }>('/api/location/me', {
      headers: {
        'Authorization': `Bearer ${token}`,
      },
    });
  }

  // ============================================
  // åˆªé™¤å¸³è™Ÿ API
  // ============================================
  async deleteAccount(token: string): Promise<DeleteAccountResponse> {
    const url = `${this.baseUrl}/api/user/account`;
    const response = await fetch(url, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });
    return response.json();
  }
}

export const apiService = new ApiService();

=== File: src/services/socket.ts ===

import { io, Socket } from 'socket.io-client';
import * as Location from 'expo-location';
import { API_BASE_URL } from '../constants/translations';

let socket: Socket | null = null;
let locationSubscription: Location.LocationSubscription | null = null;

interface TravelerLocation {
  travelerId: string;
  serviceId: number;
  lat: number;
  lng: number;
  timestamp: number;
}

interface LocationUpdatePayload {
  lat: number;
  lng: number;
  timestamp: number;
}

export function initSocket(token: string): Socket {
  if (socket?.connected) {
    return socket;
  }

  socket = io(API_BASE_URL, {
    auth: { token },
    transports: ['websocket', 'polling'],
  });

  socket.on('connect', () => {
    console.log('Socket connected');
  });

  socket.on('disconnect', () => {
    console.log('Socket disconnected');
  });

  socket.on('connect_error', (error) => {
    console.error('Socket connection error:', error);
  });

  return socket;
}

export function disconnectSocket(): void {
  if (socket) {
    socket.disconnect();
    socket = null;
  }
  stopLocationTracking();
}

export function getSocket(): Socket | null {
  return socket;
}

export async function startLocationTracking(
  onAck?: (data: { lat: number; lng: number; timestamp: number }) => void
): Promise<void> {
  if (!socket) {
    console.error('Socket not initialized');
    return;
  }

  const { status } = await Location.requestForegroundPermissionsAsync();
  if (status !== 'granted') {
    console.error('Location permission denied');
    return;
  }

  if (onAck) {
    socket.on('location_ack', onAck);
  }

  locationSubscription = await Location.watchPositionAsync(
    {
      accuracy: Location.Accuracy.High,
      timeInterval: 5000,
      distanceInterval: 10,
    },
    (location) => {
      const payload: LocationUpdatePayload = {
        lat: location.coords.latitude,
        lng: location.coords.longitude,
        timestamp: Date.now(),
      };
      socket?.emit('location_update', payload);
    }
  );
}

export function stopLocationTracking(): void {
  if (locationSubscription) {
    locationSubscription.remove();
    locationSubscription = null;
  }
}

export function subscribeToTravelerLocations(
  onLocation: (data: TravelerLocation) => void
): void {
  if (!socket) {
    console.error('Socket not initialized');
    return;
  }

  socket.emit('specialist_subscribe', {});
  socket.on('traveler_location', onLocation);
}

export function unsubscribeFromTravelerLocations(): void {
  socket?.off('traveler_location');
}

=== File: src/shared/errors.ts ===

export enum ErrorCode {
  AUTH_REQUIRED = 'E1001',
  AUTH_TOKEN_EXPIRED = 'E1002',
  AUTH_INVALID_CREDENTIALS = 'E1003',
  AUTH_USER_NOT_FOUND = 'E1004',
  
  GACHA_NO_CREDITS = 'E3001',
  GACHA_DAILY_LIMIT = 'E3002',
  GACHA_NO_PLACES = 'E3003',
  
  VALIDATION_ERROR = 'E4001',
  NOT_FOUND = 'E4004',
  
  SERVER_ERROR = 'E5001',
}

export interface ApiError {
  errorCode: string;
  message: string;
}

=== File: src/types/index.ts ===

export enum Category {
  Food = 'Food',
  Stay = 'Stay',
  Education = 'Education',
  Entertainment = 'Entertainment',
  Scenery = 'Scenery',
  Shopping = 'Shopping',
  Activity = 'Activity'
}

export type Language = 'zh-TW' | 'en' | 'ja' | 'ko';
export type LocalizedContent = string | { [key in Language]?: string };

export type PlanTier = 'free' | 'partner' | 'premium';

export type UserRole = 'traveler' | 'merchant' | 'specialist' | 'admin';

export interface User {
  id: string;
  name?: string;
  email: string | null;
  username?: string;
  firstName?: string | null;
  lastName?: string | null;
  avatar?: string | null;
  profileImageUrl?: string | null;
  role?: UserRole;
  activeRole?: UserRole;
  isApproved?: boolean;
  isSuperAdmin?: boolean;
  accessibleRoles?: string[];
  provider?: string | null;
  providerId?: string | null;
  isMerchant?: boolean;
  token?: string;
}

export interface AuthResponse {
  user: User;
  token: string;
}

export interface MerchantDailyCode {
  code: string;
  expiresAt: string;
}

export interface MerchantCredits {
  creditBalance: number;
  merchantId: number;
}

export interface SpecialistInfo {
  id: number;
  userId: string;
  name: string;
  isOnline: boolean;
  isAvailable: boolean;
  serviceRegion?: string;
  currentTravelers?: number;
  maxTravelers?: number;
}

export interface ServiceRelation {
  id: number;
  travelerId: string;
  specialistId: number;
  status: 'active' | 'completed' | 'cancelled';
  createdAt: string;
  traveler?: {
    id: string;
    name: string;
  };
}

export type MerchantStatus = 'pending' | 'approved' | 'rejected';
export type MerchantLevel = 'free' | 'pro' | 'premium';
export type MerchantCouponTier = 'SP' | 'SSR' | 'SR' | 'S' | 'R';

export interface MerchantMe {
  id: number;
  userId: string;
  name?: string;
  email?: string;
  ownerName?: string;
  businessName?: string;
  taxId?: string;
  businessCategory?: string;
  address?: string;
  phone?: string;
  mobile?: string;
  contactEmail?: string;
  status: MerchantStatus;
  merchantLevel: MerchantLevel;
  isApproved: boolean;
  creditBalance: number;
  subscriptionPlan?: string;
  createdAt: string;
}

export interface MerchantApplyParams {
  ownerName: string;
  businessName: string;
  taxId?: string;
  businessCategory: string;
  address: string;
  phone?: string;
  mobile: string;
  email: string;
}

export interface MerchantApplyResponse {
  success: boolean;
  merchant: MerchantMe;
  isNew: boolean;
  message: string;
}

export interface MerchantAnalytics {
  success: boolean;
  merchant?: MerchantMe;
  analytics: {
    totalItineraryCards: number;
    totalCoupons: number;
    activeCoupons: number;
    couponRedemptions: number;
    dailyCollectionCount: number;
    totalCollectionUsers: number;
    collectionClickCount: number;
    couponUsageCount: number;
    couponUsageRate: number;
    prizePoolViews: number;
  };
  stats?: {
    totalCoupons: number;
    activeCoupons: number;
    redeemedCoupons: number;
    totalRedemptions: number;
    monthlyRedemptions: number;
    viewCount: number;
  };
  placeLinks?: {
    id: number;
    placeName: string;
    district?: string;
    city?: string;
    isVerified: boolean;
  }[];
}

export interface MerchantCoupon {
  id: number;
  merchantId: number;
  name: string;
  tier: MerchantCouponTier;
  content: string;
  terms: string | null;
  quantity: number;
  remainingQuantity: number;
  validFrom: string | null;
  validUntil: string | null;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateMerchantCouponParams {
  name: string;
  tier: MerchantCouponTier;
  content: string;
  terms?: string;
  quantity: number;
  validFrom?: string;
  validUntil?: string;
  isActive?: boolean;
}

export interface UpdateMerchantCouponParams {
  name?: string;
  tier?: MerchantCouponTier;
  content?: string;
  terms?: string;
  quantity?: number;
  validFrom?: string;
  validUntil?: string;
  isActive?: boolean;
}

export interface MerchantCouponsResponse {
  success: boolean;
  coupons: MerchantCoupon[];
}

export interface MerchantTransaction {
  id: number;
  merchantId: number;
  amount: number;
  type: 'purchase' | 'usage' | 'refund';
  description?: string;
  createdAt: string;
}

export interface MerchantPlace {
  id: number;
  linkId: string;
  merchantId: number;
  placeName: string;
  district?: string;
  city?: string;
  isVerified: boolean;
  createdAt: string;
}

export interface MerchantProduct {
  id: number;
  merchantId: number;
  placeId?: number;
  name: string;
  description?: string;
  price?: number;
  discountPrice?: number;
  isActive: boolean;
  createdAt: string;
}

export interface PlaceSearchResult {
  id: number;
  placeId: string;
  placeName: string;
  district?: string;
  city?: string;
  isClaimed: boolean;
}

export interface SosEvent {
  id: string;
  userId: string;
  status: 'pending' | 'active' | 'resolved' | 'cancelled';
  locationLat?: number;
  locationLng?: number;
  createdAt: string;
  updatedAt: string;
}

export interface ServiceOrder {
  id: string;
  userId: string;
  type: string;
  status: 'pending' | 'in_progress' | 'completed' | 'cancelled';
  verificationCode?: string;
  createdAt: string;
  updatedAt: string;
}

export interface Merchant {
  id: string;
  name: string;
  email: string;
  claimedPlaceNames: string[];
  subscriptionPlan: PlanTier;
}

export interface CouponData {
  title: LocalizedContent;
  code: string;
  terms: LocalizedContent;
}

export interface MerchantInfo {
  id: string;
  name: string;
  badge?: string;
  discount?: string;
  description?: string;
  brandColor?: string;
  isPro?: boolean;
  promo?: string;
}

export interface GachaPoolItem {
  id: string;
  name: LocalizedContent;
  category: string;
  rarity: 'N' | 'R' | 'SR' | 'SSR' | 'SP';
  imageUrl?: string;
  merchant?: MerchantInfo;
}

export interface GachaPoolResponse {
  success: boolean;
  pool: {
    city: string;
    jackpots: Array<{
      id: number;
      placeName: string;
      category: string;
      subCategory: string;
      rating: string | null;
    }>;
    totalInPool: number;
    jackpotCount: number;
  };
}

export interface GachaPullPayload {
  userId: string;
  city: string;
  district: string;
  itemCount: number;
}

export interface GachaPullResponse {
  success: boolean;
  items: GachaItem[];
  meta: GachaMeta;
}

export interface GachaItem {
  id: number;
  place_name: LocalizedContent;
  description: LocalizedContent;
  ai_description?: LocalizedContent;
  category: Category;
  subcategory?: LocalizedContent;
  suggested_time: string;
  duration: string;
  search_query: string;
  color_hex: string;
  city?: string;
  cityDisplay?: string;
  country?: string;
  district?: string;
  districtDisplay?: string;
  collectedAt?: string;
  operating_status?: string;
  is_coupon: boolean;
  coupon_data: CouponData | null;
  store_promo?: LocalizedContent;
  is_promo_active?: boolean;
  merchant_id?: string;
  merchant?: MerchantInfo;
  remaining_coupons?: number;
  place_id?: string | null;
  verified_name?: string | null;
  verified_address?: string | null;
  google_rating?: number | null;
  google_types?: string[];
  primary_type?: string | null;
  location?: { lat: number; lng: number } | null;
  is_location_verified?: boolean;
  imageUrl?: string;
  rarity?: 'N' | 'R' | 'SR' | 'SSR' | 'SP';
}

export interface GachaMeta {
  date: string;
  country: string;
  city: string;
  locked_district: LocalizedContent;
  user_level: number;
  coupons_won?: number;
}

export interface CouponWon {
  tier: CouponTier;
  placeName: string;
  couponName: string;
  inventoryId?: number;
}

export interface ItineraryV3Meta {
  city?: string;
  district?: string | null;
  message?: string;
  code?: string;
  sortingMethod?: 'coordinate' | 'ai_reordered';
  aiReorderResult?: 'reordered' | 'no_change' | 'no_numbers' | 'error';
  categoryDistribution?: Record<string, number>;
}

export interface ItineraryGenerateResponse {
  success?: boolean;
  itinerary?: any[];
  couponsWon?: CouponWon[];
  themeIntro?: string;
  meta?: ItineraryV3Meta;
  anchorDistrict?: string;
  pace?: string;
  totalPlaces?: number;
  totalCouponsWon?: number;
  categoryDistribution?: Record<string, number>;
  sortingMethod?: string;
  targetDistrict?: string;
  city?: string;
  country?: string;
  districtId?: number;
  coupons_won?: CouponWon[];
  error?: string;
  errorCode?: string;
  message?: string;
}

export interface GachaResponse {
  status: string;
  meta: GachaMeta;
  inventory: GachaItem[];
}

export interface Country {
  id: number;
  code: string;
  nameEn: string;
  nameZh: string;
  nameJa: string | null;
  nameKo: string | null;
}

export interface Region {
  id: number;
  countryId: number;
  name?: string;
  nameEn: string;
  nameZh: string;
  nameJa: string | null;
  nameKo: string | null;
}

export type ItineraryPace = 'relaxed' | 'moderate' | 'packed';
export type TimeSlot = 'breakfast' | 'morning' | 'lunch' | 'afternoon' | 'dinner' | 'evening';

export interface ItineraryCoupon {
  id: string;
  title: string;
  code: string;
  terms: string;
}

export interface ItineraryPlace {
  id: number;
  placeName: LocalizedContent;
  category: string;
  subcategory?: string;
  description?: LocalizedContent;
  imageUrl?: string;
  google_rating?: number;
  location?: { lat: number; lng: number };
  verified_address?: string;
}

export interface ItineraryItem {
  timeSlot: TimeSlot;
  place: ItineraryPlace;
  couponWon: ItineraryCoupon | null;
}

export interface ItineraryV3Response {
  success: boolean;
  itinerary: ItineraryItem[];
  couponsWon: ItineraryCoupon[];
  meta: {
    city: string;
    district: string;
    pace: ItineraryPace;
    totalPlaces: number;
    totalCouponsWon: number;
  };
}

export interface ItineraryV3Payload {
  city: string;
  district: string;
  pace: ItineraryPace;
}

export interface GlobalExclusion {
  id: number;
  userId: null;
  placeName: string;
  district: string;
  city: string;
  penaltyScore: number;
  createdAt: string;
}

export interface AdminUser {
  id: string;
  email: string | null;
  name?: string;
  role: UserRole;
  isApproved: boolean;
  createdAt: string;
}

export interface PlaceDraft {
  id: number;
  placeName: string;
  district?: string;
  city?: string;
  category?: string;
  submittedBy?: string;
  status: 'pending' | 'approved' | 'rejected';
  createdAt: string;
}

export type AppView = 'home' | 'gacha_module' | 'planner_module' | 'settings' | 'result' | 'login';
export type GachaSubView = 'gacha' | 'collection' | 'itembox';
export type PlannerSubView = 'location' | 'itinerary' | 'chat' | 'service';

export interface AppState {
  language: Language;
  user: User | null;
  country: string;
  city: string;
  countryId: number | null;
  regionId: number | null;
  level: number;
  loading: boolean;
  error: string | null;
  result: GachaResponse | null;
  collection: GachaItem[];
  view: AppView;
  isAuthenticated: boolean;
  unreadItemCount: number;
}

export type AnnouncementType = 'announcement' | 'flash_event' | 'holiday_event';

export interface Announcement {
  id: number;
  type: AnnouncementType;
  title: string;
  content: string;
  imageUrl?: string;
  linkUrl?: string;
  startDate?: string;
  endDate?: string;
  isActive: boolean;
  priority: number;
  createdAt: string;
  updatedAt: string;
}

export interface AnnouncementsResponse {
  announcements: Announcement[];
}

export interface CreateAnnouncementParams {
  type: AnnouncementType;
  title: string;
  content: string;
  imageUrl?: string;
  linkUrl?: string;
  startDate?: string;
  endDate?: string;
  isActive?: boolean;
  priority?: number;
}

export interface UpdateAnnouncementParams {
  type?: AnnouncementType;
  title?: string;
  content?: string;
  imageUrl?: string;
  linkUrl?: string;
  startDate?: string;
  endDate?: string;
  isActive?: boolean;
  priority?: number;
}

export type CouponRarity = 'SP' | 'SSR';

export interface RegionPoolCoupon {
  id: number;
  title: string;
  description: string | null;
  rarity: CouponRarity;
  merchantName: string;
  discount: string | null;
  merchantId: number;
}

// Inventory / Itembox Types
export type InventoryItemType = 'coupon' | 'ticket' | 'gift';
export type InventoryItemStatus = 'active' | 'expired' | 'redeemed' | 'deleted';
export type CouponTier = 'SP' | 'SSR' | 'SR' | 'S' | 'R';

export interface InventoryItem {
  id: number;
  userId: string;
  itemType: InventoryItemType;
  title: string;
  description: string | null;
  merchantId: number | null;
  merchantName?: string;
  isRead: boolean;
  isRedeemed: boolean;
  expiresAt: string | null;
  createdAt: string;
  slotIndex: number;
  tier: CouponTier;
  status: InventoryItemStatus;
  isExpired: boolean;
  isDeleted: boolean;
}

export interface InventoryResponse {
  items: InventoryItem[];
  slotCount: number;
  maxSlots: number;
  isFull: boolean;
}

export interface InventoryConfig {
  maxSlots: number;
}

export interface RarityConfig {
  spRate: number;
  ssrRate: number;
  srRate: number;
  sRate: number;
  rRate: number;
}

export interface RedeemResponse {
  success: boolean;
  message: string;
  expiresAt: string;
  redemptionId: number;
}

// Collection with Promo
export interface CollectionWithPromo {
  id: number;
  placeName: string;
  country: string;
  city: string;
  district: string;
  category: string;
  hasPromo: boolean;
  promoTitle: string | null;
  promoDescription: string | null;
}

export interface CollectionWithPromoResponse {
  collections: CollectionWithPromo[];
  grouped: Record<string, CollectionWithPromo[]>;
  hasPromoItems: boolean;
}

export interface AutoSaveCollectionResponse {
  success: boolean;
  isNew: boolean;
  hasPromo: boolean;
  promoTitle: string | null;
}

// Ads
export type AdPlacement = 'gacha_start' | 'gacha_result' | 'collection_view' | 'item_use';

export interface AdConfig {
  placementKey: string;
  adUnitIdIos: string;
  adUnitIdAndroid: string;
  adType: string;
  fallbackImageUrl: string | null;
  showFrequency: number;
}

// Notifications
export interface NotificationStatus {
  itembox: number;
  collection: number;
}

// Merchant Redemption Code
export interface MerchantRedemptionCode {
  code: string;
  expiresAt: string;
}

// User Profile (Settings Page)
export type Gender = 'male' | 'female' | 'other';

export interface UserProfile {
  id: string;
  email: string;
  firstName: string | null;
  lastName: string | null;
  profileImageUrl: string | null;
  role: UserRole;
  gender: Gender | null;
  birthDate: string | null;
  phone: string | null;
  dietaryRestrictions: string[];
  medicalHistory: string[];
  emergencyContactName: string | null;
  emergencyContactPhone: string | null;
  emergencyContactRelation: string | null;
  preferredLanguage: Language;
}

export interface UpdateProfileParams {
  firstName?: string;
  lastName?: string;
  gender?: Gender;
  birthDate?: string;
  phone?: string;
  dietaryRestrictions?: string[];
  medicalHistory?: string[];
  emergencyContactName?: string;
  emergencyContactPhone?: string;
  emergencyContactRelation?: string;
  preferredLanguage?: Language;
}

export interface ProfileResponse {
  success: boolean;
  message: string;
  profile: UserProfile;
}

// SOS System
export type SosAlertStatus = 'pending' | 'acknowledged' | 'resolved' | 'cancelled';

export interface SosAlert {
  id: number;
  userId: string;
  serviceOrderId: number | null;
  plannerId: number | null;
  location: string | null;
  locationAddress: string | null;
  message: string | null;
  status: SosAlertStatus;
  acknowledgedBy: string | null;
  acknowledgedAt: string | null;
  resolvedAt: string | null;
  createdAt: string;
}

export interface SosEligibility {
  eligible: boolean;
  reason: string | null;
}

export interface SosSendParams {
  serviceOrderId?: number;
  plannerId?: number;
  location?: string;
  locationAddress?: string;
  message?: string;
}

export interface SosSendResponse {
  success: boolean;
  alertId: number;
  message: string;
}

export interface SosAlertsResponse {
  alerts: SosAlert[];
}

// ============================================
// è¡Œç¨‹å¡å•†å®¶/å„ªæƒ åˆ¸æ¬„ä½
// ============================================
export interface ItineraryCardMerchantPromo {
  title: string;
  description: string;
}

export interface ItineraryCardCouponData {
  tier: CouponTier;
  name: string;
  validUntil: string;
}

export interface ItineraryCard {
  id: number;
  place_name: LocalizedContent;
  description: LocalizedContent;
  category: Category;
  district?: string;
  city?: string;
  country?: string;
  has_merchant: boolean;
  merchant_promo?: ItineraryCardMerchantPromo;
  is_coupon?: boolean;
  coupon_data?: ItineraryCardCouponData;
}

// ============================================
// åœ–é‘‘é …ç›®ï¼ˆå«å•†å®¶å„ªæƒ ç‹€æ…‹ï¼‰
// ============================================
export interface CollectionItem {
  id: number;
  placeName: string;
  category: string;
  district: string;
  city: string;
  country: string;
  hasPromo: boolean;
  promoTitle?: string;
  promoDescription?: string;
  createdAt?: string;
}

export interface CollectionResponse {
  items: CollectionItem[];
  total: number;
}

// ============================================
// çæ± ç›¸é—œ
// ============================================
export interface PrizePoolCoupon {
  id: number;
  title: string;
  rarity: 'SP' | 'SSR';
  merchantId: string;
  placeLinkId: number;
  placeName: string;
}

export interface PrizePoolResponse {
  success: boolean;
  coupons: PrizePoolCoupon[];
  region: {
    id: number;
    name: string;
  };
}

// ============================================
// æœªè®€è¨ˆæ•¸
// ============================================
export interface UnreadCounts {
  unread: {
    collection: number;
    itembox: number;
    announcement: number;
  };
  total: number;
}

// ============================================
// æ¯æ—¥æŠ½å¡é™åˆ¶
// ============================================
export interface GachaItineraryMeta {
  city: string;
  anchorDistrict: string | null;
  pace: 'relaxed' | 'moderate' | 'packed';
  totalPlaces: number;
  totalCouponsWon: number;
  categoryDistribution: Record<string, number>;
  sortingMethod: 'coordinate' | 'ai_reordered';
  aiReorderResult: string;
  dailyLimit: number;
  dailyPullCount: number;
  remainingQuota: number;
}

export interface DailyLimitExceededResponse {
  success: false;
  error: string;
  code: 'DAILY_LIMIT_EXCEEDED' | 'EXCEEDS_REMAINING_QUOTA';
  dailyLimit: number;
  currentCount: number;
  remainingQuota: number;
}

// ============================================
// åˆªé™¤å¸³è™Ÿ
// ============================================
export interface DeleteAccountResponse {
  success: boolean;
  message?: string;
  error?: string;
  code?: 'UNAUTHORIZED' | 'MERCHANT_ACCOUNT_EXISTS' | 'DELETE_FAILED' | 'SERVER_ERROR';
}
